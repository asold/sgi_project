{
    "title": "JMathNorm: A Database Normalization Tool Using Mathematica",
    "url": "https://openalex.org/W1563291236",
    "year": 2007,
    "authors": [
        {
            "id": "https://openalex.org/A2153917385",
            "name": "Ali Yazici",
            "affiliations": [
                "TOBB University of Economics and Technology"
            ]
        },
        {
            "id": "https://openalex.org/A2093220099",
            "name": "Ziya Karakaya",
            "affiliations": [
                "Atilim University"
            ]
        },
        {
            "id": "https://openalex.org/A2153917385",
            "name": "Ali Yazici",
            "affiliations": [
                "TOBB University of Economics and Technology"
            ]
        },
        {
            "id": "https://openalex.org/A2093220099",
            "name": "Ziya Karakaya",
            "affiliations": [
                "Atilim University"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W1528090796",
        "https://openalex.org/W2031300469",
        "https://openalex.org/W1980479002",
        "https://openalex.org/W2093003289",
        "https://openalex.org/W2140100614",
        "https://openalex.org/W2023663289",
        "https://openalex.org/W2341204729",
        "https://openalex.org/W1568401719",
        "https://openalex.org/W2128784714",
        "https://openalex.org/W1487401545",
        "https://openalex.org/W2751199251",
        "https://openalex.org/W3010782316",
        "https://openalex.org/W2747076629",
        "https://openalex.org/W2895646556",
        "https://openalex.org/W1484599239",
        "https://openalex.org/W2112858958"
    ],
    "abstract": null,
    "full_text": "JMathNorm: A Database Normalization Tool\nUsing Mathematica\nAli Yazici1 and Ziya Karakaya2\n1 Computer Engineering Department, TOBB University of Economics & Technology,\nAnkara - Turkey\naliyazici@etu.edu.tr\n2 Computer Engineering Department, Atilim University, Ankara - Turkey\nziya@atilim.edu.tr\nAbstract. This paper is about designing a complete interactive tool,\nnamed JMathNorm, for relational database (RDB) normalization us-\ning Mathematica. It is an extension of the prototype developed by the\nsame authors [1] with the inclusion of Second Normal Form (2NF), and\nBoyce-Codd Normal Form (BCNF) in addition to the existing Third\nnormal Form (3NF) module. The tool developed in this study is com-\nplete and can be used for real-time database design as well as an aid\nin teaching fundamental concepts of DB normalization to students with\nlimited mathematical background. JMathNorm also supports interactive\nuse of modules for experimenting the fundamental set operations such\nas closure, and full closure together with modules to obtain the minimal\ncover of the functional dependency set and testing an attribute for a can-\ndidate key. JMathNorm’s GUI interface is written in Java and utilizes\nMathematica’s JLink facility to drive the Mathematica kernel.\n1 Introduction\nDesign of a RDB system consists of four main phases, namely, (i) determination\nof user requirements, (ii) conceptual design, (ii) logical design, and ﬁnally, (iv)\nphysical design [2]. During the conceptual design phase, set of business rules is\ntransformed into a set of entities with a set attributes and relationships among\nthem. Extended Entity Relationship (EER) modeling tool can be utilized for the\ngraphical representation of this transformation. The entity set in the EER model\nis then mapped into a set of relation schemas{R1,R 2,R 3, ..., Rn} where each Ri\nrepresents one of the relations of the DB schema. A temporary primary key is\ndesignated, and a set of functional dependencies (FD’s) among the attributes of\neach schema are established as an outcome of this phase.\nAs a side product of the logical design phase, each Ri is transformed into\nwell-formed groupings such that one fact in one group is connected to other\nfacts in other groups through relationships [3]. The ultimate aim of this article is\nto perform this rather mechanical transformation process, called normalization,\neﬃciently in an automatic fashion.\nY. Shi et al. (Eds.): ICCS 2007, Part II, LNCS 4488, pp. 186–193, 2007.\nc⃝ Springer-Verlag Berlin Heidelberg 2007\nJMathNorm: A Database Normalization Tool Using Mathematica 187\nCommercial DB design tools do not provide a complete solution for automatic\nnormalization and existing normalization tools for the purpose require high level\nprogramming skills and complex data structures. Two such implementations in\nProlog language are discussed in [4,5]. Another study on automatic transforma-\ntion is given in [6] in which UML is used to access Object Constraint Language\n(OCL) to construct expressions that encode FD’s using classes at a meta-level.\nAn alternative approach to normalization is given in [3] that focus on address-\ning FD’s to normalize DB schema in place of relying on the formal deﬁnitions\nof normal forms. The impact of this method on IS/IT students perceptions is\nalso measured in the same study. It appears that this approach is only useful\nfor small sets of FD’s in a classroom environment and in particular not suited\nfor automatic normalization. A web-based tool for automatic normalization is\ngiven in [7] which can normalize a DB schema up to 3NF for a maximum of 10\nFD’s only.\nThis article is an extension of the work [1] and discusses a complete normaliza-\ntion tool called JMathNorm which implements 2NF, 3NF, and BCNF using the\nabstract algorithms found in the literature [2,9,13]. JMathNorm’s normalization\nmodules are written in Mathematica [8] using the basic list/set operations, the\nuser interface is designed using Java language, and ﬁnally, execution of Mathe-\nmatica modules is accomplished by employing Mathematica’s Java Link (JLink)\nutility. The design approach in this study is similar to the Micro tool given in\n[9]. However, JMathNorm provides additional aspects for educational purposes\nand is implemented eﬃciently without using any complex data structures such\nas pointers.\nThe remainder of this article is organized as follows. Section 2 brieﬂy reviews\nthe DB normalization and some of the basic functions used in normalization\nalgorithms. In Section 3 Mathematica implementation of BCNF algorithm is\ngiven. JMathNorm tool is demonstrated in Section 4. Remarks about the tool\nand discussion for future work are provided in the ﬁnal section.\n2 A Discussion on Normalization Algorithms\nA functional dependency (FD) is a constraint about sets of attributes of a re-\nlation Ri in the DB schema. A FD between two sets of attributes X and Y,\ndenoted by, X → Y speciﬁes that there exists at most one value of Y for every\nvalue of X (determinant)[2,10,11]. In this case, one asserts that X determines Y\nor Y is functionally dependent on X.\nFor example, for a DB schema PURCHASE-ITEM = {orderNo, partNo,\npartDescription, quantity, price},w i t hPK = {orderNo, partNo},u s i n gas e to f\nbusiness rule one can speciﬁy the following FD’s:\nFD 1: {orderNo, partNo}→{ partDescription, quantity, price}\nFD 2: partNo → partDescription\nFor a given schema, other FD’s among the attributes can be inferred from the\nArmstrong’s inference rules [2]. Alternatively, for an attribute set X, one can\n188 A. Yazici and Z. Karakaya\ndeduce the others known as X closure, X+, determined by X, based on the FD\nset F of the schema. Set closure is one of the fundamental functions for the\nnormalization algorithms and will be referred to as ClosureX [1] in the sequel.\nFullClosureX, X++, is yet another function similar to ClosureX which returns\nall attributes that are fully dependent on X with respect to FD set. This function\nis used to remove partial dependencies for transforming a relation into 2NF. An\nalgorithm for full closure function is given below[9]:\nAlgorithmFullClosureX (X :a t t r i b u t es e t ;F :F Ds e t): return closure in tempX;\n1. tempX := X;\n2. repeat\noldX := tempX;\nfor each FD Y → Z in F do\nif Y ⊂ tempX then if not(Y ⊂ X)t h e ntempX := Z ∪ tempX\nelse if Y = X then tempX := Z ∪ tempX;\nuntil (length(oldX)= length(tempX));\n3. return tempX;\nGiven a set of FD’s F, an attribute B is said to be extraneous [11] in X → A\nwith respect to F if X = ZB, X ̸= Z,a n dA ∈ Z+. A set of FD’s H is called a\nminimal cover[1,5] for a set F if each dependency in H as exactly one attribute\non the right-hand side, if no attribute on the left-hand side is extraneous, and\nif no dependency in H can be derived from the other dependencies in H. Actu-\nally, the calculation of a minimal cover consists of ”Elimination of Extraneous\nAttributes” followed by the ”Elimination of Redundant Dependencies”. Normal-\nization algorithms considered in this study makes use of the minimal cover of\na given set of FD’s. Moreover, they are computationally eﬃcient with at most\nO(n2) operations where n is the number of FD’s in the schema.\nNormalization is a step by step processt ot r a n s f o r mt h eD Bs c h e m ai n t oas e t\nof subschemas. For the normal forms used in this study (2NF, 3NF and BCNF)\nthis is achieved by decomposing each Ri into a set of relations by removing\ncertain kind of redundancies in the relation. Lack of normalization in a DB\nschema causes update anomalies [13] which may destroy the integrity of the DB.\nIf a relation has no repeating groups, it is said to be in the ﬁrst normal form\n(1NF). In this study, it is assumed that all relations do satisfy this condition. A\nrelation is in the second normal form (2NF) if no part of a PK determines nonkey\nattributes of the relation. Note that, for the example above, because ofFD 2, the\nrelation is not in 2NF. 3NF relations prohibit transitive dependencies among its\nattributes. And, ﬁnally, in Boyce-Codd Normal Form (BCNF) a nonkey attribute\ncannot determine a prime attribute (any part of PK).\nA 2NF algorithm with the attribute preservation property is given in [9].\nJMathNorm uses a slightly modiﬁed version of this algorithm to remove partial\ndependencies and hence transform the D B schema into 2NF. Bernstein’s Syn-\nthesis algorithm [1,12] is implemented to provide 3NF relations directly for a\ngiven set of attributes and a set of FD’s F. Original dependencies are preserved,\nhowever, lossless join property [1] is not guaranteed by this algorithm.\nJMathNorm: A Database Normalization Tool Using Mathematica 189\nIn certain 3NF DB schemas, a FD from a nonprime attribute into a prime one\nmay exist. Boyce-Codd Normal Form (BCNF) of a 3NF relation is achieved by\nremoving such dependencies. A sketch of the BCNF algorithm with the lossless\njoin properties [2,12] is given below.\nAlgorithm BCNF (R: attribute set in 3NF; F: FD set): return Q in BCNF;\n1. D := R;\n2. while there is a left-hand side X of a FD X → Y in F do\nif X → Y violatesBCNF then\ndecompose Ri n t ot w os c h e m a sRm := D − Y ; and Rn := X ∪ Y ;\n3. return Q := Rm ∪ Rn;\nThe function violateBCNF tests if a given FD violates the BCNF condition by\ncalculating the X closure. If it includes all the attributes from R then R does\nnot violate the BCNF constraint, otherwise R violates the constraint and needs\nto be decomposed into Rm and Rn as given above.\n3 Mathematica Implementation\n3.1 BCNF with Mathematica\nIn Fig.1, a use case diagram is given to demonstrate the functions and modules\nused in the tool.\nTasks in Fig.1 are eﬀectively implemented as Mathematica modules by uti-\nlizing only the Mathematica’s list structure and the well-known set operations\n[8]. These operations are Union[], Complement[], Intersection[], MemberQ[],\nExtract[], Append[], Length[], and Sort[].\nA FD set F of a schema is represented by two lists, one for the left hand\nsides (FL), and the other for the right hand sides of F (FR). Obviously, the\norder of attributes in such a list is important and should be maintained by care\nthroughout the normalization process.\nFor the example above, the FD set is represented in Mathematica as follows:\nFL = {{orderNo, partNo}, {orderNo, partNo},{orderNo, partNo},partNo}\nFR = {partDescription, quantity, price, partDescription}\nAccordingly, FL[[i]] → FR[[i]], for i =1 , 2, 3, 4 as speciﬁed by the FD set F.\nAs an illustration, the Mathematica code for the BCNF algorithm is given\nbelow. Given a FD set and a 3NF relation R, BCNF algorithm ﬁrst looks for a\nBCNF violation using the function violatesBCNF. When found, it returns in Q\ntwo sub relations satisfying the BCNF constraint.\nBCNF[FL_, FR_, R_] := Module[{i, X, D, Q, DIF, REL},D=R ;Q={ } ;\nFor[i = 1, i <= Length[FL], i++,\nIf[Length[FL[[i]]] > 1, X = Sort[FL[[i]]], X = {FL[[i]]}];\nflag = violatesBCNF[FL, FR, X, FR[[i]], U];\n190 A. Yazici and Z. Karakaya\nIf[flag == 1, REL = Union[X, {FR[[i]]}];\nQ = Union[Q, {REL}]; RC = Complement[R, {FR[[i]]}];\nDIF = Intersection[R, RC]; Q = Union[Q, {DIF}];];];Return[Q];];\nviolatesBCNF[FL_,FR_,X_,Y_,R_]:=Module[{XP, flag},\nXP=Sort[ClosureX[FL,FR,X]];\nIf[XP==Sort[U], flag=0,flag=1];Return[flag];];\n3NF\nMinimal Cover\nElim. Red. Deps.\nClosureX\n«uses»\n«uses» «uses»\n«uses»\n«uses»*\n*\n*\n*\n*\n*\nE l i m .E x t r a .A t t r i b s .\n*\n*\n2NF\nBCNF\nFullClosureX\nviolatesBCNF\n«uses»\n«uses»\n«uses»\n*\n*\n*\n*\nIsItaKey\n*\n*\n*\n*\nFig. 1.Use Case Diagram for Normalization Modules\nAn example of a relation with BCNF violation and it’s decomposition by the\ncode above is given below. Consider a relation CLIENT-INTERVIEW ={clientno,\ninterviewdate, interviewtime, staﬀno, roomno} with the following FD’s:\nFD 1: {clientNo, interviewdate}→{ interviewtime,staﬀno,roomno}\nFD 2: {staﬀno,interviewdate,interviewtime}→ clientno\nFD 3: {staﬀno,interviewdate}→ roomNo\nIn this relation {clientno, interviewdate},a n d{staﬀno, interviewdate} are both\ncandidate keys and share a common attribute. And, BCNF constraint is violated\nby FD2. The result of running the BCNF module by providing the required\nparameters produces the following decomposition Q.\nQ = {{interviewdate, roomno, staffno},\n{clientno, interviewdate, interviewtime, staffno}}\n4 JMathNorm User Interface\nAn interactive tool, JMathNorm, with a GUI written in Java is designed to\nimplement the system given in Fig.1. Each algorithm is implemented as a Math-\nematica module. JLink (Java Link) facility of Mathematica is utilized to load the\nJMathNorm: A Database Normalization Tool Using Mathematica 191\nFig.2. JMathNorm’s menu options\nFig. 3.Dialog box to deﬁne FD’s\nMathematica kernel and execute these modules as required. JMathNorm starts\nwith a dialogue box asking for the relevant path of Mathematica kernel. Math-\nematica functions for the normalization are loaded afterwards. Consequently,\nonly the calling statement of those modules is passed to Mathematica to receive\na result string. The result returned is just the set representation in a string. This\nstring is to be parsed into the desired data structure. In JMathNorm, results are\nstored into java’s Vector data structure.\nThe interface oﬀers a menu driven interaction with the system. The main and\nOperations submenus are displayed in Fig.2. JMathNorm’sFD pull-down menu\ncan be used to set up a new set of FD’s, open an existing one, save or edit FD’s\nusing a data entry dialog box. One can experiment with basic normalization\ntasks, namely, set closure, set full closure, elimination of redundant attributes,\n192 A. Yazici and Z. Karakaya\nFig.4. A sample run for 3NF decomposition\nelimination of redundant dependencies, testing for primary key and obtaining\nminimal cover by utilizing the Basic Operations submenu. These set theoretic\noperations form the basis of all of the normalization algorithms discussed in the\npreceding sections. Moreover, because of t heir symbolic nature, veriﬁcation of\nthe result returned from each manually israther cumbersome.J M a t h N o r mo v e r -\ncomes this problem, by providing a veriﬁcation mechanism as a background for\nteaching normalization theory eﬀectively in a classroom environment. Database\nschemas can be transformed into the required normal form directly from the\nNForm submenu. As a result of normalization, the original relations of the DB\nschema are decomposed into sub relations which is displayed systematically by\nthe Results submenu. In Fig.3, the dialog box for deﬁning FD’s are shown. A\nsample run to decompose the relation into 3NF for is displayed in Fig.4.\n5 Tests and Discussions\nSeveral benchmark tests found in the literature are successfully applied with\nvarying number of FD’s having diﬀerent initial normal forms. Normalization\nalgorithms used in the tool possess at most quadratic time complexity providing\nin the number of FD’s and are computationally eﬀective.\nJMathNorm was also used in a classroom environment during a Database Sys-\ntems course oﬀered to about 25 third year computer engineering majors during\nthe Spring semester of 2006-07 academic year. Students are requested to form\nproject teams and design a medium size database system involving 8-10 rela-\ntions. During the design process, they ended up with normalizing the relational\nschema. Students usually preferred using JMathNorm to support or validate the\nnormalization process. It was reported that each team used JMathNorm on av-\nerage of four times. In addition to the use in the project, students utilized the\ntool to understand the normalization process and the underlying theory based\non the set theoretic operations discussed earlier.\nJMathNorm: A Database Normalization Tool Using Mathematica 193\nIn the course evaluation forms, majority of the students have indicated that\nthe tool was quite useful to check their manual work in studying the normaliza-\ntion algorithms and to normalize schemas for the database design project of the\ncourse.\nModules of JMathNorm was written in Mathematica utilizing only basic\nlist/set operations as the fundamental data structure. These operations empow-\nered by the symbolic nature of Mathematica resulted in an eﬀective normaliza-\ntion tool. Currently, it does not have the ability to create SQL statements for\nthe normalized schema. A table creation facility geared towards a speciﬁc DBMS\nis to be included to JMathNorm.\nReferences\n1. Yazici, A. and Karakaya, Z.: Normalizing Relational Database Schemas Using\nMathematica, LNCS, Springer-Verlag, Vol.3992 (2006) 375-382.\n2. Elmasri, R. and Navathe, S.B.: Fundamentals of Database Systems, 5th Ed., Ad-\ndison Wesley (2007).\n3. Kung, H. and Case, T.: Traditional and Alternative Database Normalization Tech-\nniques: Their Impacts on IS/IT Students’ Perceptions and Performance, Interna-\ntional Journal of Information Technology Education, Vol.1, No.1 (2004) 53-76.\n4. Ceri, S. and Gottlob, G.: Normalization of Relations and Prolog, Communications\nof the ACM, Vol.29, No.6 (1986)\n5. Welzer, W., Rozman, I. and Gyrks, J.G.: Automated Normalization Tool, Micro-\nprocessing and Microprogramming, Vol.25 (1989) 375-380.\n6. Akehurst, D.H., Bordbar, B., Rodgers, P.J., and Dalgliesh, N.T.G.: Automatic\nNormalization via Metamodelling, Proc. of the ASE 2002 Workshop on Declarative\nMeta Programming to Support Software Development (2002)\n7. Kung, H-J. and Tung, H-L.: A Web-based Tool to Enhance Teaching/Learning\nDatabase Normalization, Proc. of the 2006 Southern Association for Information\nSystems Conference (2006) 251-258.\n8. Wolfram, S.: The Mathematica Book, 4th Ed., Cambridge University Press (1999).\n9. Du, H. and Wery, L.: Micro: A Normalization Tool for Relational Database De-\nsigners, Journal of Network and Computer Applications, Vol.22 (1999) 215-232.\n10. Manning, M.V.: Database Design, Application Development and Administration,\n2nd. Ed., McGraw-Hill (2004).\n11. Diederich, J. and Milton, J.: New Methods and Fast Algorithms for Database\nNormalization, ACM Trans. on Database Systems, Vol.13, No.3(1988) 339-365.\n12. Ozharahan, E.: Database Management: Concepts, Design and Practice, Prentice\nHall (1990).\n13. Bernstein, P.A.: Synthesizing Third Norm Relations from Functional Dependencies,\nACM Trans. on Database Systems, Vol.1, No.4 (1976) 277-298."
}