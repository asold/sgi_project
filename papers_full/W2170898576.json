{
  "title": "A Logic for the Java Modeling Language JML",
  "url": "https://openalex.org/W2170898576",
  "year": 2001,
  "authors": [
    {
      "id": null,
      "name": "Jacobs, B.P.F.",
      "affiliations": [
        "Radboud University Nijmegen"
      ]
    },
    {
      "id": null,
      "name": "Poll, E.",
      "affiliations": [
        "Radboud University Nijmegen"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W1535103785",
    "https://openalex.org/W2111619838",
    "https://openalex.org/W2104506944",
    "https://openalex.org/W1553335919",
    "https://openalex.org/W2097185397",
    "https://openalex.org/W1923766689",
    "https://openalex.org/W1544646281",
    "https://openalex.org/W2131664385",
    "https://openalex.org/W3000560506",
    "https://openalex.org/W1583826417",
    "https://openalex.org/W7052154333",
    "https://openalex.org/W6674223293",
    "https://openalex.org/W221670187",
    "https://openalex.org/W1659048632",
    "https://openalex.org/W4234528212",
    "https://openalex.org/W1573258001",
    "https://openalex.org/W4212913914",
    "https://openalex.org/W1578560741",
    "https://openalex.org/W2121953666",
    "https://openalex.org/W4285719527",
    "https://openalex.org/W2094160561",
    "https://openalex.org/W2107283383",
    "https://openalex.org/W2096601022",
    "https://openalex.org/W1981572083",
    "https://openalex.org/W2164810907",
    "https://openalex.org/W2161825580",
    "https://openalex.org/W2114879684",
    "https://openalex.org/W2057835515",
    "https://openalex.org/W2097488638",
    "https://openalex.org/W2159484187",
    "https://openalex.org/W1586167239"
  ],
  "abstract": null,
  "full_text": "A Logic for the Java Modeling Language JML\nBart Jacobs and Erik Poll\nDept. Computer Science, Univ. Nijmegen,\nP.O. Box 9010, 6500 GL Nijmegen, The Netherlands.\nfbart,erikpollg@cs.kun.nl http://www.cs.kun.nl/ \u0018fbart,erikpollg\nAbstract. This paper describes a specialised logic for proving speci-\n\fcations in the Java Modeling Language (JML). JML is an interface\nspeci\fcation language for Java. It allows assertions like invariants, con-\nstraints, pre- and post-conditions, and modi\fable clauses as annotations\nto Java classes, in a design-by-contract style. Within the LOOP project\nat the University of Nijmegen JML is used for speci\fcation and veri\f-\ncation of Java programs. A special compiler has been developed which\ntranslates Java classes together with their JML annotations into logical\ntheories for a theorem prover (PVS or Isabelle). The logic for JML that\nwill be described here consists of tailor-made proof rules in the higher\norder logic of the back-end theorem prover for verifying translated JML\nspeci\fcations. The rules e\u000eciently combine partial and total correctness\n(like in Hoare logic) for all possible termination modes in Java, in a single\ncorrectness formula.\n1 Introduction\nJML (for Java Modeling Language) [15,14] is a speci\fcation language tailored\nto Java, primarily developed at Iowa State University. It allows assertions to\nbe included in Java code, specifying for instance pre- and postconditions and\ninvariants in the style of Ei\u000bel and the design-by-contract approach [18]. JML has\nbeen integrated with the speci\fcation language used for ESC/Java, the extended\nstatic checker developed at Compaq System Research Center [17,27].\nAt Nijmegen, a formal denotational semantics has been developed for essen-\ntially all of sequential Java. A compiler has been built, the LOOP tool [5], which\ntranslates a Java program into logical theories describing its semantics [13,4,10,\n9,12,8,26]. These logical theories are in a format that can serve as input for the-\norem provers, which can then be used to prove properties of the Java program,\nthus achieving a high level of reliability for this program. The LOOP tool sup-\nports output for the theorem provers PVS [20] and Isabelle [21]. This approach\nto veri\fcation of Java has demonstrated its usefulness for instance with the proof\nof a non-trivial invariant for the Vector class in the standard Java API [11]. The\ncurrent main application area is JavaCard [1], see [24,25]. The LOOP tool is\nbeing extended to JML, so that it can be used to verify JML-annotated Java\nsource code. At the moment this works for a kernel of JML.\nH. Hussmann (Ed.): FASE 2001, LNCS 2029, pp. 284{299, 2001.\nc⃝ Springer-Verlag Berlin Heidelberg 2001\nA Logic for the Java Modeling Language JML 285\nOne advantage of using a formal speci\fcation language is that tool support\nbecomes possible. Work on tool support for JML focuses on the generation of run-\ntime checks on preconditions for testing, at Iowa State University [6] extended\nstatic checking, at Compaq System Research Center, and veri\fcation using the\nLOOP tool, at the University of Nijmegen. This o\u000bers a wide range of validation\noptions|a key advantage of JML.\nThis paper presents a logic for reasoning about (sequential) Java programs\nwhich is the result of several years of experience in this area. The semantical and\nlogical approach to Java within the LOOP project is bottom-up: it starts from\nan (automatic) translation of Java programs into what is ultimately a series of\nlow level get- and put-operations on a suitable memory model [4]. From this\npoint onwards, several steps have been taken up the abstraction ladder.\n1. At \frst, the results to be proved (about the Java program under consider-\nation) were formulated in the higher order logic of the back-end theorem\nprover (PVS or Isabelle), and proved by fully unpacking their meaning in\nterms of the low level (get and put) operations on the memory. Only rel-\natively small programs can be handled like this, despite the usefulness of\nautomatic rewriting.\n2. Next a suitable Hoare logic for Java was introduced (in PVS and Isabelle) [10]\nfor compositional reasoning about programs at a higher level of abstraction.\nThis logic has di\u000berent Hoare triples, corresponding to partial / total cor-\nrectness for each of the possible termination modes of Java statements and\nexpressions (normal / exception / return / break / continue). In theory this\nlogic is appropriate, but in practice it involves too many rules and leads\nto too many duplications of proof obligations (for the di\u000berent termination\nmodes).\n3. In a further abstraction step, the results to be proved were no longer for-\nmulated in PVS or Isabelle, but in a suitable speci\fcation language for\nJava, namely JML [14]. JML makes it possible to write speci\fcations for\nJava programs without the need to know the details of these programs in\nPVS/Isabelle. Again, the translation from (a kernel of) JML to PVS/Isabelle\nis done automatically.\n4. In a \fnal step|the topic of this paper|a tailor-made logic is devel-\noped for proving (in PVS/Isabelle) these JML speci\fcations. This logic in-\nvolves syntax-driven rules (in PVS/Isabelle), supported by appropriate proof\nstrategies, enabling the user to go step-by-step through a method body. The\nlogic combines partial and total correctness together with the \fve di\u000berent\ntermination modes in a single correctness formula, resembling JML method\nspeci\fcations. This makes the logic both powerful and e\u000ecient in its use.\nSoundness of all these rules has been proved on the basis of the underly-\ning semantics for Java. Most of the proofs are easy and just involve many\ncase distinctions. The soundness of the while rule, see Subsection 5.6, is\nnon-trivial.\nThe rules we describe below only handle the standard, imperative part of\n(sequential) Java, and not its typically object-oriented features (dealing for ex-\n286 B. Jacobs and E. Poll\nample with dynamic binding), as in [22,19]. We do not need these rules because\nwe can always fall back on our low level semantics where these issues are han-\ndled automatically [9]. This is a crucial point. Our logic for JML is not used\ndirectly at the Java source code level|as is standard in Hoare logics, see [3,16,\n7,22]|but at the translated Java code in the back-end theorem prover, i.e. on\nthe semantical level. But since the translation performed by the LOOP tool is\ncompositional, there is not much di\u000berence: during proofs in the logic for JML\none still follows the original code structurally. In a forward approach (following\nthe execution order) one typically peels o\u000b the leading statements step-by-step,\nadapting the precondition in a suitable way. In every step one has to prove this\nadaptation of the precondition, as a result of the leading statement. In our ap-\nproach the latter is typically done without the logic for JML, by going down\nto the lowest semantical level (as in 1 above), making e\u000ecient use of automatic\nrewriting. As mentioned, this works well for small programs. Note that an im-\nportant consequence of working at the semantic level\nThis combination of high level proof rules and low level automatic rewriting\non the basis of the underlying semantics forms the strength of our pragmatic\napproach, where we only introduce logical rules when this really suits us, in order\nto achieve a higher level of abstraction in proofs. A consequence of working at\nthe semantical level is that we cannot really de\fne a notion of completeness for\nour higher level rules (like in [19]), because completeness can only be de\fned for\na syntactic level w.r.t. some lower semantic level.\nIn this paper we shall only talk about proving JML speci\fcations for cer-\ntain Java implementations. We shall not use this here, but in certain cases these\nproofs may actually rely on other JML speci\fcations, for example for methods\nwhich are native (implemented in some other language than Java), or which may\nbe overridden. In the latter case one cannot rely on a speci\fc implementation,\nbecause it may be di\u000berent in subclasses. In a behavioural approach to subtyp-\ning [2] (see also [23]) one then assumes that all implementations in subclasses\nsatisfy the speci\fcation in the class in which the method is \frst introduced. This\nspeci\fcation will form the basis for veri\fcations.\nIn order to explain our logic for JML, the paper will have to introduce quite\na few languages: Java and its JML annotations (Section 2), higher order logic\n(as used in PVS and Isabelle) and the representation of Java statements and\nexpressions therein (Section 3), the meaning of JML method speci\fcations in\nlogic (Section 4), and \fnally the rules themselves. Necessarily we cannot describe\nall details, and are forced to concentrate on the essentials. The paper involves\nan example speci\fcation in JML, veri\fed in PVS using the logic for JML. It is\nthe same example as in [10]|this time not on abstraction level 2 but on level 4,\nas described above.\n2 Class and Method Speci\fcations in JML\nThis section gives a brief impression of JML, concentrating on method spec-\ni\fcations. For more information, see [15,14]. JML adds assertions to Java by\nA Logic for the Java Modeling Language JML 287\nwriting them as special comments ( /*@ ... @*/ or //@ ...). These assertions\nare Java Boolean expressions extended with special operators, like nforall,\nnexists, nresult or nold(-). Classes can be enriched with invariants (predi-\ncates that should be preserved by all methods) or history constraints (relations\nthat should hold between all pre- and post-states of all methods). Methods can be\nannotated with behaviour speci\fcations which can be either normal\nbehavior,\nexceptional behavior or simply behavior. The latter is typically used as fol-\nlows for specifying a method m.\n/*@ behavior\n@ diverges: <pre-condition for non-termination>\n@ requires: <precondition>\n@ modifiable: <items that can be modified>\n@ ensures: <postcondition for normal termination>\n@ signals: <postcondition for exceptional termination>\n@*/\nvoid m() { ... }\nRoughly, this says that if the precondition holds, then if the method m hangs /\nterminates normally / terminates abruptly, then the diverges / ensures / signals\nclause holds (respectively). When the diverges is true (resp. false)w eh a v e\npartial (resp. total) correctness. But note that when it is false, the method\ncan still terminate abruptly. A normal behavior (or exceptional behavior)\ndescribes a situation where a method must terminate normally (or exception-\nally), assuming that the precondition holds. For example, the class in Figure 1\ncontains an annotated method (from [10]) that searches for a certain pattern in\nan array using a single while loop. It has a non-trivial postcondition.\n3 Semantics of Java Statements and Expressions\nThis section introduces a denotational semantics of Java statements and expres-\nsions in higher order logic. This logic is a common abstraction of the logics used\nby PVS and Isabelle/HOL, and will be introduced as we proceed.\nFirst, there is a complicated type OM, for object memory, with various get-\nand put-operations, see [4]. In this paper the internal structure of OM is not\nrelevant. The type OM serves as our state space on which statements and ex-\npressions act, as functions OM ! StatResult and OM ! ExprResult[\u000b], for a\nsuitable result type \u000b. These result types are introduced as labeled coproduct\n(also called variant or sum) types:\nStatResult : TYPE\ndef=\nfhang: unit\nj norm: OM\nj abnorm: StatAbng\nExprResult[\u000b]: TYPE def=\nfhang: unit\nj norm:[ ns: OM;res: \u000b]\nj abnorm: ExprAbng\nwith labels hang, norm and abnorm corresponding to the three termination modes\nin Java: non-termination, normal termination and abrupt termination. Notice\n288 B. Jacobs and E. Poll\nclass Pattern {\nint [] base, pattern;\n/*@ normal_behavior\n@ requires: base != null && pattern != null &&\n@ pattern.length <= base.length;\n@ modifiable: \\nothing;\n@ ensures: ( /// pattern occurs;\n@ \\result >= 0 &&\n@ \\result <= base.length - pattern.length &&\n@ /// \\result gives the start position\n@ (\\forall (int i)\n@ 0 <= i && i < pattern.length\n@ ==> pattern[i] == base[\\result+i]) &&\n@ /// pattern does not occur earlier\n@ (\\forall (int j)\n@ 0 <= j && j < \\result\n@ ==> (\\exists (int i)\n@ 0 <= i && i < pattern.length\n@ && pattern[i] != base[j+i])))\n@| |\n@ ( /// pattern does not occur\n@ \\result == -1 &&\n@ (\\forall (int j)\n@ 0 <= j && j < base.length - pattern.length\n@ ==> (\\exists (int i)\n@ 0 <= i && i < pattern.length\n@ && pattern[i] != base[j+i])));\n@*/\nint find_first_occurrence () {\ni n tp=0 ,s=0 ;\nwhile (true)\nif (p == pattern.length) return s;\nelse if ( s+p= = base.length) return -1;\nelse if (base[s + p] == pattern[p]) p++;\ne l s e{p=0 ; s++; }\n}\n}\nFig. 1.A pattern search method in Java with JML annotation\nthat a normally termination expression returns both a state (incorporating the\npossible side-e\u000bect) and a result value. This is indicated by a labeled product\n(record) type [ ns: OM;res: \u000b ]. The result types StatAbn and ExprAbn for abrupt\ntermination are subdivided di\u000berently for statements and expressions:\nA Logic for the Java Modeling Language JML 289\nStatAbn : TYPE def=\nf excp:[ es: OM;ex: RefType]\nj rtrn: OM\nj break:[ bs: OM;blab: lift[string]]\nj cont:[ cs: OM;clab: lift[string]] g\nExprAbn : TYPE def=\n[ es: OM;ex: RefType]\nThe type RefType is used for references, containing either the null-reference or a\npointer to a memory location. It describes the reference to an exception object,\nin case an exception is thrown. The lift type constructor adds a bottom element\nbot to an arbitrary type, and keeps all original elements a as up a. It is used\nbecause break and continue statements in Java can be used both with and\nwithout label (represented as string).\nOn the basis of this representation of statements and expressions all language\nconstructs from (sequential) Java are formalised in type theory (and used in the\ntranslation performed by the LOOP tool). For instance, the composition of two\nstatements s; t: OM ! StatResult is de\fned as:\n(s; t)\ndef= \u0015x: OM:CASES s \u0001 x OF f hang 7! hang\nj norm y 7! t \u0001 y\nj abnorm a 7! abnorm ag\nwhere \u0001 is used for function application, and CASES for pattern matching on the\nlabels of the StatResult coproduct type. What is important to note is that if the\nstatement s hangs or terminates abruptly, then so does the composition s; t.\nThere is no space to describe all these constructs in detail. We mention some\nof them that will be used later. Sometimes we need to execute an expression\nonly for its side-e\u000bect (if any). This is done via the function E2S, de\fned as:\nE2S \u0001 e : OM ! StatResult\ndef=\n\u0015x: OM: CASES e \u0001 x OF f\nhang 7! hang\nj norm y 7! norm(y:ns)\nj abnorm a 7! abnorm(excp(es = a:es;ex = a:ex)) g\nfor e: OM ! ExprResult[\u000b]. The notation y:ns describes \feld selection associated\nwith y in the labeled product [ ns: OM;res: \u000b ]. In the last line an expression\nabnormality (an exception) is transformed into a statement abnormality. Java’s\nif-then-else becomes:\nIF-THEN-ELSE \u0001 c \u0001 s \u0001 t : OM ! StatResult\ndef=\n\u0015x: OM: CASES c \u0001 x OF f\nhang 7! hang\nj norm y 7! IF y:resTHEN s \u0001 (y:ns)ELSE t \u0001 (y:ns)\nj abnorm a 7! abnorm(excp(es = a:es;ex = a:ex)) g\n290 B. Jacobs and E. Poll\nfor c: OM ! ExprResult[bool] and s; t: OM ! StatResult. The formalisation of\nJava’sreturn statement (without argument) is:\nRETURN : OM ! StatResult def= \u0015x: OM:abnorm(rtrn x)\nThis statement produces an abnormal \\return\" state. Such a return abnormality\ncan be undone, via appropriate catch-return functions. In our translation of Java\nprograms, such a function CATCH-RETURN is wrapped around every method\nbody that returns void. First the method body is executed. This may result\nin an abnormal state, because of a return. In that case the function CATCH-\nRETURN turns the state back to normal again. Otherwise, it leaves everything\nunchanged.\nCATCH-RETURN \u0001 s : OM ! StatResult[OM]\ndef=\n\u0015x: OM: CASES s \u0001 x OF f\nhang 7! hang\nj norm y 7! norm y\nj abnorm a 7! CASES a OF f\nexcp e 7! abnorm(excp e)\nj rtrn z 7! norm z\nj break b 7! abnorm(break b)\nj cont c 7! abnorm(cont c) gg\nThe formalisation of creating and catching break and continue abnormalities\nworks similarly, via function CATCH-BREAK and CATCH-CONTINUE.\n4 Semantics of Method Speci\fcations\nTo start we de\fne two labeled product types incorporating appropriately typed\npredicates for the various termination modes of statements and expressions.\nStatBehaviorSpec : TYPE\ndef=\n[ diverges: OM ! boolean;\nrequires: OM ! boolean;\nstatement: OM ! StatResult;\nensures: OM ! boolean;\nsignals: OM ! RefType ! boolean;\nreturn: OM ! boolean;\nbreak: OM ! lift[string] ! boolean;\ncontinue: OM ! lift[string] ! boolean ]\nExprBehaviorSpec[\u000b]: TYPE def=\n[ diverges: OM ! boolean;\nrequires: OM ! boolean;\nexpression: OM!ExprResult[\u000b];\nensures: OM ! \u000b ! boolean;\nsignals: OM ! RefType\n! boolean ]\nNotice that the StatBehaviorSpec type has more entries than ExprBehaviorSpec\nprecisely because a statement in Java can terminate abruptly for more reasons\nthan an expression.\nA Logic for the Java Modeling Language JML 291\nThere are associated predicates which give the \\obvious\" meaning.\nSB \u0001 sbs : boolean def=\n8x 2 OM: sbs:requires \u0001 x =)\nCASES sbs:statement \u0001 x OF f\nhang 7! sbs:diverges \u0001 x\nj norm y 7! sbs:ensures \u0001 y\nj abnorm a 7! CASES a OF f\nexcp e 7! sbs:signals \u0001 (e:es) \u0001 (e:ex)\nj rtrn z 7! sbs:return \u0001 z\nj break b 7! sbs:break \u0001 (b:bs) \u0001 (b:blab)\nj cont c 7! sbs:continue \u0001 (c:cs) \u0001 (c:clab) gg\nEB \u0001 ebs : boolean def=\n8x 2 OM: ebs:requires \u0001 x =)\nCASES ebs:expression \u0001 x OF f\nhang 7! ebs:diverges \u0001 x\nj norm y 7! ebs:ensures \u0001 (y:ns) \u0001 (y:res)\nj abnorm a 7! ebs:signals \u0001 (a:es) \u0001 (a:ex) g\nfor sbs: StatBehaviorSpec and ebs: ExprBehaviorSpec[\u000b]. Notice that the diverges\npredicate is evaluated in the pre-state, in case the statement/expression hangs,\nbecause in that case there is simply no post-state. All other predicates are eval-\nuated in the post-state.\nThe LOOP compiler translates JML method speci\fcations into elements of\nStatBehaviorSpec and ExprBehaviorSpec, depending on whether the method pro-\nduces a result or not. The additional entries in StatBehaviorSpec which do not\noccur in JML speci\fcations (the three last ones) are \flled with default values.\nThey may be \flled with other values during proofs, typically because of catching\nof abnormalities, see Subsection 5.4.\nFor example, consider a JML method speci\fcation\n/*@ behavior\n@ diverges: d;\n@ requires: p;\n@ modifiable: mod;\n@ ensures: q;\n@ signals: (E e) r;\n@*/\nvoid m() { ... }\n292 B. Jacobs and E. Poll\nin a class with invariant I. This speci\fcation gets translated (by the LOOP\ncompiler) into:\n8z: OM: SB \u0001 ( diverges =[ [ d ]];\nrequires = \u0015x: OM: [[I ]]\u0001 x ^ [[p ]]\u0001 x ^ z = x;\nstatement =[ [ m ]];\nensures = \u0015x: OM: [[I ]]\u0001 x ^ [[q ]]\u0001 x \u0001 z ^ z \u0019mod x;\nsignals = \u0015x: OM:\u0015 a: RefType: [[I ]]\u0001 x ^\n[[a instanceof E ]] ^\n[[r ]]\u0001 x \u0001 z \u0001 a ^ z \u0019mod x;\nreturn = \u0015x: OM:false;\nbreak = \u0015x: OM:\u0015 l: lift[string]:false;\ncontinue = \u0015x: OM:\u0015 l: lift[string]:false )\nThe variable z is a logical variable which records the pre-state. It is needed\nbecause the normal and exceptional postconditions q and r may involve an\noperator nold(e), requiring evaluation of e in the pre-state. The term z \u0019mod x\nis an appropriate translation of the modi\fable clause, expressing that x and z\nare almost the same, except for the \felds that are mentioned in the modi\fable\nclause1.\nWhen translating a normal behavior the diverges and signals \felds are set to\nthe constant predicate false; similarly, in an exceptional behavior the diverges\nand ensures \felds become false.\n5 Rules for Proving Method Speci\fcations\nThis section discusses a representative selection of the inference rules that are\nused for verifying JML method speci\fcations. Some of these rules are bureau-\ncratic, but most of them are \\syntax driven\". In a goal-oriented view they should\nbe read up-side-down.\n5.1 Diverges\nUsually, the diverges clause in JML is constant, i.e. either true or false. Some\nof the rules below|for example, the composition rule in Figure 3|actually\nrequire it to be constant. This can always be enforced via the following rule|at\nthe expense of duplication of the number of proof obligations, see Figure 2.\nWe illustrate the soundness of this rule. We assume therefore that the as-\nsumptions above the line hold. In order to prove the conclusion, we have to\ndistinguish three main cases, for an arbitrary state x: OM, satisfying p \u0001 x:\n{ s \u0001 x hangs. According to the de\fnition of SB, we have to prove d \u0001 x. But\n:d \u0001 x, leads to false by the second assumption.\n1 Often it is convenient to weaken the precondition to \u0015x: OM: [[I ]]\u0001 x ^ [[p ]]\u0001 x ^\nz \u0019mod x, to obtain a more symmetric correctness formula.\nA Logic for the Java Modeling Language JML 293\nSB \u0001 ( diverges = \u0015x: OM: true;\nrequires = \u0015x: OM:p \u0001 x ^ d \u0001 x;\nstatement = s;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM: false;\nrequires = \u0015x: OM:p \u0001 x ^: d \u0001 x;\nstatement = s;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = d;\nrequires = p;\nstatement = s;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nFig. 2.Rule to force diverges predicates to be constant\n{ s \u0001 x terminates normally. The normal postcondition q follows in both cases\nd \u0001 x and :d \u0001 x from both the assumptions.\n{ s \u0001 x terminates abruptly. Similarly, one gets the appropriate postcondition\nfrom both the assumptions.\nThe soundness of most of the rules below (except for while) is similarly easy.\nSoundness of all the rules has been proved in PVS.\n5.2 Composition\nThe rule that is most often used is the composition rule. It makes it possible\nto step through a piece of code by handling single statements one at a time, by\nintroducing appropriate intermediate conditions, namely the p\n1 in Figure 3.\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = p;\nstatement = s1;\nensures = p1;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = p1;\nstatement = s2;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = p;\nstatement = s1 ; s2;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nFig. 3.Composition rule\n294 B. Jacobs and E. Poll\nA special case of this rule which is often useful in practice has the intermediate\ncondition p1 of the form \u0015x: OM:p \u0001 x ^ p2 \u0001 x, where p is the precondition of the\ngoal, and p2 is an addition to the precondition which holds because of the \frst\nstatement s1.\n5.3 Return\nRecall from Section 3 that the RETURN statement immediately terminates\nabruptly, by creating a \\return\" abnormality. The associated rule is much like a\nskip rule, see Figure 4.\n5.4 Catching Returns\nRecall that the LOOP compiler wraps a CATCH-RETURN function around each\ntranslated method body, in order to turn possible return abnormalities into\nnormal termination. The associated rule in Figure 4 therefore puts the normal\npostcondition of the goal into the return position.\n8x: OM:p \u0001 x =) R \u0001 x\nSB \u0001 ( diverges = d;\nrequires = p;\nstatement = RETURN;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = d;\nrequires = p;\nstatement = s;\nensures = q;\nsignals = r;\nreturn = q;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = d;\nrequires = p;\nstatement = CATCH-RETURN \u0001 s;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nFig. 4.Rules for the return and catch-return statements\nNotice that via a rule like this an entry which is not used in JML speci\fcations\n(namely return) can get a non-default value during proofs. This is the reason for\nincluding such additional entries in the de\fnition of the type StatBehaviorSpec\nin Section 4.\n5.5 If-Then-Else\nJava has the if-then and if-then-else conditional statements. We only de-\nscribe the relevant rule for the latter, see Figure 5. It deals with the possible\nside-e\u000bect and with the result of the condition c via the intermediate predicate\nqc.\nA Logic for the Java Modeling Language JML 295\nEB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = p;\nexpression = c;\nensures = qc;\nsignals = r )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = \u0015x: OM:\nqc \u0001 x \u0001 true\nstatement = s1;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = \u0015x: OM:\nqc \u0001 x \u0001 false\nstatement = s2;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = p;\nstatement = IF-THEN-ELSE \u0001 c \u0001 s1 \u0001 s2;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nFig. 5.Rule for if-then-else\n5.6 While\nIn a \fnal rule, we consider Java’s while(c)fsg statement. It involves a condition\nc and a statement s which is iterated until the condition becomes false, or a\nform of abrupt termination arises. Especially, a break or continue statement,\npossibly with a label, may be used within a while statement (to jump out of the\nloop, or to jump to the next cycle). We refer to [10] for a detailed description of\nthe formalisation of the while statement, and restrict ourselves to the relevant\nrule, see Figure 6.\nEB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = \u0015x: OM:\ninvariant \u0001 x ^\nvariant \u0001 x = a1;\nexpression = c;\nensures = \u0015x: OM:\u0015 b: bool:\nIF b\nTHEN qc \u0001 x ^ variant \u0001 x = a2\nELSE q \u0001 x;\nsignals = r )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = \u0015x: OM:q c\u0001 x ^\nvariant \u0001 x = a2;\nstatement = CATCH-CONTINUE \u0001 ` \u0001 s;\nensures = \u0015x: OM:\ninvariant \u0001 x ^\nvariant \u0001 x<a 1;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nSB \u0001 ( diverges = \u0015x: OM:b ;\nrequires = invariant;\nstatement = WHILE \u0001 ` \u0001 c \u0001 s;\nensures = q;\nsignals = r;\nreturn = R;\nbreak = B;\ncontinue = C )\nFig. 6.Rule for total reasoning with while\n296 B. Jacobs and E. Poll\nThe parameter `: lift[string] in the goal statement WHILE\u0001`\u0001c\u0001s is up(\\lab\")\nif there is label lab immediately before the while statement in Java, and bot\notherwise. If a statement continue or continue lab is executed within the\nloop body s, the resulting \\continue\" abnormality is caught by the wrapper\nCATCH-CONTINUE\u0001 ` \u0001 s, so that the next cycle can start normally. The LOOP\ntool puts a CATCH-BREAK function around every while statement, in order to\ncatch any breaks within this statement 2. The variant is a function OM ! A to\nsome well-founded order A, which is required to decrease with every normally\nexecuted cycle 3. Notice how an auxiliary predicate qc and values a1;a2 2 A are\nused to pass on the e\u000bect of the condition to the statement|in the case where\nthe condition evaluates to true. In this way the variant can decrease during\nexecution of either the condition c or the statement s.\n6 Example Veri\fcation in PVS\nThe rules from the previous section (plus some more rules) have all been formu-\nlated in PVS, and proven correct. This makes it possible to use these rules to\nprove that Java methods meet their JML speci\fcations in PVS. The translations\nof these speci\fcations are Boolean expressions of the form SB\u0001( diverges = d; \u0001\u0001\u0001 )\nor EB \u0001( diverges = d; \u0001\u0001\u0001 ) involving suitable labeled tuples. These tuples can be-\ncome very big during proofs, but the explicit labels keep them reasonably well-\nstructured and manageable. The proof rules allow us to rewrite these labeled\ntuples into adapted tuples, following the structure of the Java code (of the body\nof the method whose correctness should be proved). This rewriting is continued\nuntil the statement or expression in the labeled tuple is su\u000eciently simple to pro-\nceed with the proof at a purely semantical level (like in the rule for RETURN in\nSubsection 5.3).\nIn this way the example JML speci\fcation of the pattern-search from Figure 1\nhas been proved for the given Java implementation. The latter involves return\nstatements inside a while loop, leading to abrupt termination and a break out\nof the loop, both when it becomes clear that the pattern is present and that it\nis absent. This presents a non-trivial veri\fcation challenge, not only because of\nthese return statements but also because of the non-trivial (in)variant involved,\nsee [10]. The proof makes essential use of the rule for while (once) and for if-\nthen-else (three times), and also for composition (several times), following the\nstructure of the Java code.\nThe same example has been used in [10], where it was veri\fed with the special\nHoare logic (from [10]) with separate triples for the di\u000berent termination modes\nin Java. It is re-used here to enable a comparison. Such a comparison is slightly\n2 The e\u000bect of these CATCH-BREAK and CATCH-CONTINUE functions can be incor-\nporated into the while rule in Figure 6, by adapting the break and continue predicates\nin the assumptions, but this complicates this rule even further.\n3 Note that requiring the existence of the variant restricts the use of this rule to\nterminating while loops. Therefore, this \\total\" while rule only really make sense\nwhen the divergence clause is constantly false.\nA Logic for the Java Modeling Language JML 297\ntricky because when the proof was re-done with the proof rules for JML, both\nthe variant and invariant were already known. Also, no time had to be spent\non formulating the required correctness property in PVS, because this could all\nbe done (more conveniently) in JML. Taking this into account, the new rules\nstill give a considerable speed-up of the proof. The veri\fcation is no longer a\nmatter of days, but has become a matter of hours. The main reason is that the\ncorrectness formulas in the new logic for JML combine all termination modes in\na single formula, and thus requires only one rule per language construct, with\nfewer assumptions.\n7 Conclusion\nIn this paper JML method speci\fcation have been transformed into correctness\nformulas in an associated logic. These formulas extend standard Hoare triples\n(and those from [10]) by combining all possible termination modes for Java, nat-\nurally following the (coalgebraic) representation of statements and expressions.\nThe correctness formulas capture all essential ingredients for an axiomatic se-\nmantics for Java. In combination with the underlying low-level, memory-based\nsemantics of Java, these rules for JML provide an e\u000ecient, powerful and ﬂexible\nsetting for tool-assisted veri\fcation of Java programs with JML annotations.\nAcknowledgements. Thanks are due to Joachim van den Berg and Marieke\nHuisman for discussing various aspects of the rules for JML.\nReferences\n1. JavaCard API 2.1. http://java.sun.com/products/javacard/htmldoc/.\n2. P. America. Designing an object-oriented language with behavioural subtyping.\nIn J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, Foundations of\nObject-Oriented Languages, number 489 in Lect. Notes Comp. Sci., pages 60{90.\nSpringer, Berlin, 1990.\n3. K.R. Apt. Ten years of Hoare’s logic: A survey|part I. ACM Trans. on Progr.\nLang. and Systems , 3(4):431{483, 1981.\n4. J. van den Berg, M. Huisman, B. Jacobs, and E. Poll. A type-theoretic memory\nmodel for veri\fcation of sequential Java programs. In D. Bert, C. Choppy, and\nP. Mosses, editors, Recent Trends in Algebraic Development Techniques , number\n1827 in Lect. Notes Comp. Sci., pages 1{21. Springer, Berlin, 2000.\n5. J. van den Berg and B. Jacobs. The LOOP compiler for Java and JML. Techn.\nRep. CSI-R0019, Comput. Sci. Inst., Univ. of Nijmegen. To appear at TACAS’01.,\n2000.\n6. A. Bhorkar. A run-time assertion checker for Java using JML. Techn. Rep. 00-08,\nDep. of Comp. Science, Iowa State Univ.\n(http://www.cs.iastate.edu/\n\u0018leavens/JML.html), 2000.\n7. F.S. de Boer. A WP-calculus for OO. In W. Thomas, editor, Foundations of\nSoftware Science and Computation Structures , number 1578 in Lect. Notes Comp.\nSci., pages 135{149. Springer, Berlin, 1999.\n298 B. Jacobs and E. Poll\n8. M. Huisman. Reasoning about JAVA Programs in higher order logic with PVS and\nIsabelle. PhD thesis, Univ. Nijmegen, 2001.\n9. M. Huisman and B. Jacobs. Inheritance in higher order logic: Modeling and rea-\nsoning. In M. Aagaard and J. Harrison, editors, Theorem Proving in Higher Order\nLogics, number 1869 in Lect. Notes Comp. Sci., pages 301{319. Springer, Berlin,\n2000.\n10. M. Huisman and B. Jacobs. Java program veri\fcation via a Hoare logic with\nabrupt termination. In T. Maibaum, editor, Fundamental Approaches to Software\nEngineering, number 1783 in Lect. Notes Comp. Sci., pages 284{303. Springer,\nBerlin, 2000.\n11. M. Huisman, B. Jacobs, and J. van den Berg. A case study in class library veri\f-\ncation: Java’s Vector class. Techn. Rep. CSI-R0007, Comput. Sci. Inst., Univ. of\nNijmegen. To appear in Software Tools for Technology Transfer , 2001.\n12. B. Jacobs. A formalisation of Java’s exception mechanism. Techn. Rep. CSI-R0015,\nComput. Sci. Inst., Univ. of Nijmegen. To appear at ESOP’01., 2000.\n13. B. Jacobs, J. van den Berg, M. Huisman, M. van Berkum, U. Hensel, and H. Tews.\nReasoning about classes in Java (preliminary report). In Object-Oriented Pro-\ngramming, Systems, Languages and Applications (OOPSLA) , pages 329{340. ACM\nPress, 1998.\n14. G.T. Leavens, A.L. Baker, and C. Ruby. JML: A notation for detailed design. In\nH. Kilov and B. Rumpe, editors, Behavioral Speci\fcations of Business and Systems ,\npages 175{188. Kluwer, 1999.\n15. G.T. Leavens, A.L. Baker, and C. Ruby. Preliminary design of JML: A behavioral\ninterface speci\fcation language for Java. Techn. Rep. 98-06, Dep. of Comp. Sci.,\nIowa State Univ. ( http://www.cs.iastate.edu/\n\u0018leavens/JML.html), 1999.\n16. K.R.M. Leino. Toward Reliable Modular Programs . PhD thesis, California Inst. of\nTechn., 1995.\n17. K.R.M. Leino, J.B. Saxe, and R. Stata. Checking java programs via guarded com-\nmands. In B. Jacobs, G. T. Leavens, P. M¨ uller, and A. Poetzsch-He\u000bter, editors,\nFormal Techniques for Java Programs. P roceedings of the ECOOP’99 Workshop .\nTechn. Rep. 251, Fernuniversit¨at Hagen, 1999. Also as Technical Note 1999-002,\nCompaq Systems Research Center, Palo Alto.\n18. B. Meyer. Object-Oriented Software Construction . Prentice Hall, 2 nd rev. edition,\n1997.\n19. D. von Oheimb. Axiomatic semantics for Java `ight in Isabelle/HOL. Technical\nReport CSE 00-009, Oregon Graduate Inst., 2000. TPHOLS 2000 Supplemental\nProceedings.\n20. S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M. Srivas. PVS: Combining\nspeci\fcation, proof checking, and model checking. In R. Alur and T.A. Henzinger,\neditors, Computer Aided Veri\fcation , number 1102 in Lect. Notes Comp. Sci.,\npages 411{414. Springer, Berlin, 1996.\n21. L.C. Paulson. Isabelle: A Generic Theorem Prover . Number 828 in Lect. Notes\nComp. Sci. Springer, Berlin, 1994.\n22. A. Poetzsch-He\u000bter and P. M¨ uller. A programming logic for sequential Java. In\nS.D. Swierstra, editor, Programming Languages and Systems , number 1576 in Lect.\nNotes Comp. Sci., pages 162{176. Springer, Berlin, 1999.\n23. E. Poll. A coalgebraic semantics of subtyping. In H. Reichel, editor, Coalgebraic\nMethods in Computer Science , number 33 in Elect. Notes in Theor. Comp. Sci.\nElsevier, Amsterdam, 2000.\nA Logic for the Java Modeling Language JML 299\n24. E. Poll, J. van den Berg, and B. Jacobs. Speci\fcation of the JavaCard API in JML.\nIn J. Domingo-Ferrer, D. Chan, and A. Watson, editors, Smart Card Research and\nAdvanced Application, pages 135{154. Kluwer Acad. Publ., 2000.\n25. E. Poll, J. van den Berg, and B. Jacobs. Formal speci\fcation of the JavaCard API\nin JML: the APDU class. Comp. Networks Mag. , 2001. To appear.\n26. Loop Project. http://www.cs.kun.nl/\u0018bart/LOOP/.\n27. Extended static checker ESC/Java. Compaq System Research Center.\nhttp://www.research.digital.com/SRC/esc/Esc.html.",
  "topic": "Programming language",
  "concepts": [
    {
      "name": "Programming language",
      "score": 0.8843895196914673
    },
    {
      "name": "Computer science",
      "score": 0.8472462892532349
    },
    {
      "name": "Java Modeling Language",
      "score": 0.7811795473098755
    },
    {
      "name": "Java",
      "score": 0.6866052150726318
    },
    {
      "name": "Correctness",
      "score": 0.6593447327613831
    },
    {
      "name": "Gas meter prover",
      "score": 0.6351227760314941
    },
    {
      "name": "Automated theorem proving",
      "score": 0.5165673494338989
    },
    {
      "name": "Compiler",
      "score": 0.49076589941978455
    },
    {
      "name": "Generics in Java",
      "score": 0.4759402275085449
    },
    {
      "name": "Java annotation",
      "score": 0.3940160274505615
    },
    {
      "name": "Real time Java",
      "score": 0.3212020993232727
    },
    {
      "name": "Mathematical proof",
      "score": 0.19378116726875305
    },
    {
      "name": "Mathematics",
      "score": 0.09245023131370544
    },
    {
      "name": "Geometry",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I145872427",
      "name": "Radboud University Nijmegen",
      "country": "NL"
    }
  ],
  "cited_by": 93
}