{
  "title": "Developing a Modeling Tool Using Eclipse",
  "url": "https://openalex.org/W1513641614",
  "year": 2008,
  "authors": [
    {
      "id": "https://openalex.org/A5090162052",
      "name": "Nick Kirtley",
      "affiliations": [
        "University of Groningen"
      ]
    },
    {
      "id": "https://openalex.org/A5108506783",
      "name": "Ahmad Waqas Kamal",
      "affiliations": [
        "University of Groningen"
      ]
    },
    {
      "id": "https://openalex.org/A5083888080",
      "name": "Paris Avgeriou",
      "affiliations": [
        null
      ]
    }
  ],
  "references": [
    "https://openalex.org/W1649645444",
    "https://openalex.org/W1487672899",
    "https://openalex.org/W2176490758",
    "https://openalex.org/W2111023964",
    "https://openalex.org/W1676160052",
    "https://openalex.org/W2013658284",
    "https://openalex.org/W2072025944",
    "https://openalex.org/W2092431575"
  ],
  "abstract": "Tool development using an open source platform provides autonomy to users to change, use, and develop cost-effective software with freedom from licensing requirements. However, open source tool development poses a number of challenges, such as poor documentation and continuous evolution. In this paper, we present our experience of developing a modeling tool in an open source environment. We not only explain the functionality of the tool, but also list the pros and cons of developing in such an environment. The contribution of this paper lies in introducing readers to the modeling tool and draw attention to some of the challenges faced by open source tool developers.",
  "full_text": "University of Groningen\nDeveloping a Modeling Tool Using Eclipse\nKirtley, Nick; Waqas Kamal, Ahmad; Avgeriou, Paris\nPublished in:\nEPRINTS-BOOK-TITLE\nIMPORTANT NOTE: You are advised to consult the publisher's version (publisher's PDF) if you wish to cite from\nit. Please check the document version below.\nDocument Version\nPublisher's PDF, also known as Version of record\nPublication date:\n2008\nLink to publication in University of Groningen/UMCG research database\nCitation for published version (APA):\nKirtley, N., Waqas Kamal, A., & Avgeriou, P. (2008). Developing a Modeling Tool Using Eclipse. In\nEPRINTS-BOOK-TITLE University of Groningen, Johann Bernoulli Institute for Mathematics and Computer\nScience.\nCopyright\nOther than for strictly personal use, it is not permitted to download or to forward/distribute the text or part of it without the consent of the\nauthor(s) and/or copyright holder(s), unless the work is under an open content license (like Creative Commons).\nThe publication may also be distributed here under the terms of Article 25fa of the Dutch Copyright Act, indicated by the “Taverne” license.\nMore information can be found on the University of Groningen website: https://www.rug.nl/library/open-access/self-archiving-pure/taverne-\namendment.\nTake-down policy\nIf you believe that this document breaches copyright please contact us providing details, and we will remove access to the work immediately\nand investigate your claim.\nDownloaded from the University of Groningen/UMCG research database (Pure): http://www.rug.nl/research/portal. For technical reasons the\nnumber of authors shown on this cover page is limited to 10 maximum.\nDownload date: 05-11-2025\nDeveloping a Modeling Tool Using Eclipse\nNick Kirtley, Ahmad Waqas Kamal, Paris Avgeriou\nDepartment of Mathematics and Computer Science\nUniversity of Groningen, the Netherlands\nn.e.kirtley@student.rug.nl, a.w.kamal@rug.nl, paris@cs.rug.nl\nAbstract\nTool development using an open source platform provides autonomy to users to change, use, and \ndevelop cost-effective software with freedom from licensing requirements. However, open source tool \ndevelopment poses a number of challenges, such as poor documentation and continuous evolution. In \nthis paper, we present our experience of developing a modeling tool in an open source environment. \nWe not only explain the functionality of the tool, but also list the pros and cons of developing in such \nan environment. The contribution of this paper lies in introducing readers to the modeling tool and \ndraw attention to some of the challenges faced by open source tool developers.\nKeywords: Open Source; Eclipse; UML; Modeling; Architectural Patterns\n1   Introduction\nDuring the past few years, using open source environments for tool development has \nbecome a widely known paradigm to develop new software [2]. The research projects carried \nout by different research institutions, which often have budget and resource restrictions, can \nbenefit from such environments to provide a practical implementation of their research work. \nCurrently these open source platforms cover a wide range of software disciplines e.g. Eclipse\nMDT [3] provides a modeling framework, Apache [4] provides web-engine support, and \nArgoUML [5] is used for modeling software in UML etc. Such open source environments \nprovide the user with a base of technology and an expert online community of developers to \nshare their experiences in order to exploit ways to develop software that best meets the \nrequirements at hand.\nHowever, using an open source framework such as Eclipse has its advantages and \ndisadvantages. On the one side, Eclipse offers a highly extensible platform, an active \ncommunity of online developers, and a large number of plug-ins that can be further \ncustomized to meet the specific needs of the problems at hand. On the other side, it lacks \nexplicit documentation support and carries an evolving underlying platform.\nIn our previous work, we have discovered a set of architectural primitives that are \nrecurring abstractions found among a number of architectural patterns [1]. One benefit these\nprimitives offer is their use as basic building blocks for modeling patterns. However, such a \nnovel research direction needs a practical implementation with adequate tool support to allow \nusers to systematically model primitives in software design. Moreover, we describe how the \nexisting tools, such as ACME Studio [6], Wright [7], and ArgoUML [8] lack considerably in \nproviding such support, thus requiring either an extension mechanism to extend one of the \nexisting tools or creating a new tool from scratch. \nIn this paper, we use the open source Eclipse framework, which provides a rich technology \nbase to create plug-ins as an extension to its underlying platform. We use the UML2 \nmetamodel using the APIs provided in the Eclipse UML plug-in and create primitive-specific \nprofiles that can be applied to the UML model. The tool, that we have called Primus, allows \nusers to systematically model architectural primitives with the eventual goal of modeling \nsoftware patterns and architecture. UML elements, used for defining the primitives, are \nfurther validated by the use of the Object Constraint Language (OCL) [15]. This not only \nhelps to validate the model but also helps in finding and locating the primitives modeled in \nsoftware design. The main contribution of this paper lies in introducing the research \ncommunity to the Primus modeling tool, and our experiences of developing tool in the Eclipse\nmodeling framework that can serve as guidelines for researchers and developers that wish to \ndevelop similar modeling tools.\nThe remainder of this paper is structured as follows: in Section 2, we present the research \nwork background that provides a base for Primus. Section 3 gives detailed information of the \ngoals for Primus, the approach taken to develop it and we present our approach for \nrepresenting primitives as modeling abstractions, exemplified using an extension of the UML. \nSection 4 describes the design and usage of the tool. Section 5 describes the modeling of a \nfew selected pattern variants using primitives with the help of a non-trivial example. Section 6\ndiscusses the lessons learnt during the development of tool using the open source \nenvironment. Section 7 describes related work and Section 8 discusses future work and \nconcludes this paper.\n2 Motivation and Research Work Background\nIn this section, we briefly present the notions of architectural patterns alongside our \nprevious research work in devising an approach for the systematic modeling of architectural \npatterns. We motivate that the use of architectural primitives, which are recurring abstractions\nfound among a number of patterns, can be used as a way for the systematic modeling of \narchitectural patterns in system design. \nArchitecture Patterns and Architectural Primitives\nAmong a number of software patterns that exist in the literature, architectural patterns [9], \nand design patterns [10] are the most widely known and used. It is difficult to draw a clear \nboundary between both types of these patterns, because it depends on the way these patterns \nare perceived and used by software architects. The work in [9] is more concerned about \narchitectural issues, i.e. high-level components and connectors while the work in [10] lists a \nnumber of specific solutions to design problems. In this paper, we focus on the former and in \nsection 5; we show the modeling of some selected architectural patterns in an example \nsoftware design.\nIn our previous work, we have discovered a number of architectural primitives in the \ncomponent-connector view [1]. These primitives are found repetitively among a number of \narchitectural patterns and serve as the basic building blocks for modeling architectural \npatterns in software design. The base of our work, for developing a modeling tool relies on \nusing architectural primitives for modeling architectural patterns in system design. In the \nupcoming sections, we show the actual modeling of the primitives in the Primus tool while in \nthis section; we briefly describe all the primitives documented during our previous work: \nPrimitive Description\nCallback A component B invokes an operation on Component A, where Component B keeps a reference to \ncomponent A – in order to call back to component A later in time.\nIndirection A mechanism that allows for redirection of a message/communication to a target component with the \npurpose of hiding the location of the target component.\nGrouping Grouping represents a Whole-Part structure where one or more semantically coherent components work as a \nWhole while other components are its parts.\nLayering Layering extends the Grouping primitive, and the participating components follow certain rules, such as the \nrestriction not to bypass lower layer components.\nAggregation \nCascade\nA composite component is composed of a number of subparts, and there is the constraint that composite A \ncan only aggregate components of type B, B only C, etc.\nComposition \nCascade\nA Composition Cascade extends Aggregation Cascade by the further constraint that a component can only \nbe part of one composite at any time.\nShield Shield components protect other components from direct access by an external client. The protected \ncomponents can only be accessed through an intermediary component.\nTyping Custom typing models are defined using with the notion of super type connectors and type connectors.\nVirtual \nConnector\nVirtual connectors reflect indirect communication links among components for which at least one additional \npath exists from the source to the target component.\nPush-Pull Push, Pull, and Push-Pull structures are common abstractions in many software patterns. They occur when a \ntarget component receives a message on behalf of a source component (Push), or when a receiver receives \ninformation by generating a request (Pull). Both structures can also occur together at the same time (Push-\nPull).\nVirtual \nCallback\nConsider two components connected via a callback mechanism. In many cases, the callback between \ncomponents does not exist directly, rather the callback operation takes place through one or more mediator \ncomponents.\nAdaptor This primitive converts the provided interface of a component into the interface that the clients expect.\nPassive \nElement\nConsider an element that is invoked by other elements to perform certain operations. Passive elements do not \ncall operations of other elements.\nControl Calling a method in the target component can involve passing a control from source to the target component.\nMediator Sometimes certain objects in the set of objects cooperate with several other objects. Allowing a direct link \nbetween such objects can overly complicate the communication and result in strong coupling between \nobjects [11]. To solve this problem, mediator components are used.\nTable 1: A brief description of Primitives\n3 Tool Development Goal and Approach\nIn this section, we describe our motive of tool development, rationale behind the selection \nof Eclipse open source platform, and the mechanism to extend UML for defining primitives.\n3.1 Goal\nThe theory of architectural primitives described in the previous sections needs a practical \nimplementation, in the form of a tool, which fulfills at least the following requirements:\n- To provide reusability and visual modeling support to express architectural primitives \n- To provide automated model checking support in order to validate that the primitives are \ncorrectly applied in software design\n- To facilitate the extensibility of the current set of primitives with the definition of newly \ndiscovered architectural primitives\n- To support the customization of the provided primitives in order to meet the specific \nneeds of the problem at hand\n3.2 Tool Development Platform Selection\nThe requirements listed above demand, as explained below, the usage and extension of a \nplatform and modeling language that is extensible enough to capture the semantics of the \nprimitives. We take into consideration the following modeling languages and platforms to \nadvocate the selection of the Eclipse open source platform, as follows:\nACME: ACME provides a template mechanism, which can be used for abstracting common \nreusable architectural idioms and patterns [12]. ACME allows defining user specified \nconstraints on architecture elements to model patterns. Violations of these constraints are \nautomatically checked in ACME studio [6]. However, ACME lacks in documentation and \nthere is virtually no active community to discuss the development issues. Due to the lack of \ndocumentation, it is difficult to determine the structure of the underlying meta-model. \nHowever, ACME scores high in adaptability and reusability. The reusability is the main \nadvantage of ACME. ACME is a close match with our project but the serious lack of \ndocumentation means that we would be very dependent on the ACME development team. \nEclipse Model Development Tools (MDT): The Eclipse MDT project [3] is very large and so \nis the user base. This means that the community support is excellent and a fair amount of \ndocumentation is available. MDT is obviously modeling based so the match is very close to \nPrimus. In fact the meta-model used is based on the UML 2.1 metamodel. Another added \nadvantage of MDT is that it provides a wide range of plug-ins; some of these plug-ins provide \ngraphical support for modeling UML diagrams, which can be further extended to fulfill the \nsoftware requirements. Thus, the Eclipse MDT has excellent support and the reusability is \nhigh due to the model-based features.\nArgo UML: Argo has good documentation but it is not yet very stable. The meta-model is not \nthoroughly documented and there have been many reports of slow fix rate of bugs. \nConsidering these issues, we consider Argo UML as a weak option to develop the Primus \ntool. \nArchium: Archium is an ADL based on documenting the design decisions [18]. Although, the \ntechnical documentation related to the tool is poor, it does have the advantage that it was \ndeveloped locally in our department and thus questions can be answered in person.\nConclusion: The Eclipse MDT is an open source project and it has the advantage that all \nsource code is available online and can be openly distributed upon change. Eclipse provides \ndevelopment support in the form of forums and this is by far the best way to learn about what \nEclipse MDT is capable of and how to extend it in any way. This support is far better than \nsupport offered from other modeling languages described above. The MDT project has a \nnumber of plug-ins and the ones relevant to our tool development include – UML2, OCL, and \nUML2Tools. The UML2 plug-in offers UML 2 metamodel support, the OCL plug-in offers \nOCL model checking support and the UML2Tools plug-in offers visualization support. This \nclear separation of functionality has the advantage that it is clear what part of the package \nneeds to be used for the relevant functionality of the project. \nAnother advantage of the Eclipse framework is the fact that it has the UML2 plug-in that \noffers the UML 2.1 metamodel. The fact that the UML2 plug-in is based on the UML 2.1 \nmetamodel is a huge advantage because it means that any modelers using the Primus system \nwill know exactly what the metamodel consists of because of the very detailed specification \nsupplied by Object Management Group (OMG) [13].\n3.3 Extending UML to define Primitives\nAs described above, an additional benefit that we achieve with the selection of Eclipse\nmodeling framework is its support for UML, which is widely known as an industry standard \nmodeling language and is highly extensible [14]. There are two approaches to extend UML: \nextending the core UML metamodel or creating profiles which extend metaclasses. Our work \nfocuses on the second approach where we create profiles specific to the individual \narchitectural primitives. That is, we define the primitive as extensions of existing metaclasses \nof the UML using stereotypes, tagged values, and constraints:\nStereotypes: Stereotypes are one of the extension mechanisms to extend UML metaclasses. \nWe use stereotypes to extend the properties of existing UML metaclasses. \nConstraints: We use OCL to place additional semantic restrictions on extended UML \nelements. For instance, constraints can be defined on associations between components, \nnavigability, direction of communication, etc. \nTagged Values allow one to associate tags to architectural elements. For example, tags can be \ndefined to represent individual layers in a layered architecture using layer numbers.\n4. The Primus Tool\nThe Primus tool has been developed to provide a practical implementation of architectural \nprimitives. The tool interacts with the UML component diagram by allowing the user to add \nprimitives to the model and for model checking capabilities. The architecture, functionality,\nand usage of the tool are described in the remainder of this paragraph.  \n4.1 Primus Functionality\nThe Primus tool is mainly intended to assist software designers in systematically modeling \narchitectural primitives in system design. The two main areas of functionality of Primus are: \n1) modeling primitives and 2) model checking of primitives. The tool allows for primitives to \nbe applied to existing UML elements in the Component-Connector view or for primitives to \nbe applied with all the necessary UML elements. For example, a Callback primitive consists \nof two components that are connected. It is possible to apply the Callback primitive to two \nexisting components or to create new components automatically. This option allows multiple \nprimitives to be applied to the same component. Adding primitives is achieved via a wizard \nwhereby the wizard is opened via a context menu. A wizard offers the user with a step-by-step \nexplanation of the possible choices and thus requires a smaller learning curve for the user. \nModel checking/validation of primitives in the Component-Connector view consists of 1) \nfinding primitives in a UML model and 2) validating the primitives found and indicating any \nproblems. Finding primitives in a model involves Primus returning the relevant UML \nelements that are part of a primitive. For example, if we have a model with ten components \nand a Callback applied between two components then the result will be the two components \nthat are part of the primitive. Model checking the primitives found consists of checking \nwhether all aspects of the primitives have been applied properly and whether any primitive \nspecific rules have been broken. The results also include problem specific information.\n   \nFigure 1: Wizard and Validation Information\nFigure 3 shows two screenshots from Primus. The left screenshot shows some of the \noptions from the primitive modeling wizard and the right screenshot shows the result of \nmodel checking/validation for the Callback primitive.\n4.2 Challenges\nOne of the main challenges during this project has been the use of OCL for finding (in the \nmodel) and validating primitives while also returning relevant error information if a primitive \nhas been applied incorrectly. The reason we chose to use OCL (Rather than Java) is because \nOCL queries are relatively small and can be understood more easily by those that are \nunfamiliar with the details of the project and users that wish to implement newly found \nprimitives. An example code segment can be found in the next section.\n4.3 Tool Architecture\nThe Eclipse framework consists of a plug-in architecture. Therefore, developing a \nmodeling tool is performed by means of a plug-in that extends the existing framework. The \nplug-ins that we have used and extended are from the Modeling Development Tools project \n[3]. The plug-ins of interest from the MDT project are UML2, OCL and UML2Tools. The \nUML2 plug-in provides the UML 2.1 metamodel and the ability to define UML 2.1 models, \nthe OCL plug-in provides OCL querying and constraint capabilities and the UML2Tools \nplug-in provides UML diagram interaction with the UML 2.1 models. \nThe Primus tool is a fragment plug-in that extends the component diagram plug-in from \nthe UML2Tools plug-in. A fragment plug-in is a type of plug-in that merges the host plug-in \nwith a newly developed plug-in. We chose to use a fragment plug-in because the interaction \nbetween the user and the plug-in is from the component diagram. The plug-ins UML2 and \nOCL are used by Primus.\nThe Primus plug-in follows the event driven style: all functionality starts due to an action \nfrom the user. Once an event is triggered, it is passed to the relevant classes to carry out the \nnecessary action.\nFigure 2: Direct plug-in dependencies\nFigure 2 shows the direct dependencies of Primus while Figure 3 shows the class diagram \nof Primus. The event driven design of the system is used and the relationships between the \nclasses in the diagram show the two main areas of functionality of the system: primitive \nmodeling and model checking. The core implementation of the project is contained within the \nCreatePrimitive, OCLCheck and PrimitiveRegister classes. The CreatePrimitive class deals \nwith the necessary primitive modeling aspects based on user input, the OCLCheck class \ncontains queries and performs them, and the PrimitiveRegister class interprets the OCL query \nresults. Moreover, the inheritance relationship shown between the three UML packages and \nthe Primus classes show that the Primus classes are inheriting the functions one or more \nclasses of these packages.\nFigure 3: Class diagram with dependencies\n4.4 The Eclipse Plug-ins\nThe eclipse platform provides support to create plug-ins, which can later be merged in the \neclipse environment, thus providing a network of plug-ins that can meet the specific \ndevelopment needs of the project at hand. In the previous sub-section, we have listed the plug-\nins that collaborate with the Primus plug-in. In this section, we describe the usage of these \nplug-ins in the context of the Primus plug-in and elaborate on the functions supported by these \nplug-ins.\n UML2 Tools\nThe UML2 tools project is a set of Graphical Modeling Frameworks (GMFs) for visually \nmodeling UML diagrams. Eclipse UML2 tools provide support for nine different kinds of \nUML diagrams namely Class, Profile Definition, Component, Activity, State Machine, \nComposite Structures, Deployment and Use Case [3]. In this work, our focus lies on using \nonly the component diagram package available in UML2 tools. The UML2 tools plug-in \nallow to create UML models both programmatically and by using the UML editors. \nMoreover, the plug-in allows to work with UML profiles, create UML models, and customize \nUML metamodel elements. The Primus uses the UML2 tools editor to create primitives \nspecific profiles to work with UML models using both the existing UML model elements and \nthe UML elements specifically customized for modeling primitives.\n The Object Constraint Language\nThe Eclipse OCL plug-in provides an API for parsing and evaluating OCL constraints and \nqueries on EMF model. In the case of UML2 tools, the UML models are constrained and \nchecked by using OCL. We do not extend the semantics of the OCL parser and only use the \nOCL queries to locate the primitives and identify missing primitive elements in the UML \nmodel.\n5. An Example of Modeling Patterns Using Primitives in Primus\nThe Primus tool is able to model patterns using primitives. This will be shown by \nmodeling an example system called Leela as described in [1]. Due to space restrictions, we \nwill not include the whole design in this section.\nThe simplified Leela system used is a layered peer-to-peer system with a broker to \nfacilitate communication between peers. The purpose of this architecture is for a peer to \ncommunicate with another peer. To this end, the peer component communicates with \ncomponents in lower layers where the Broker component connects the two peers. To model \nthe Layers pattern we will use the Layers primitive. A Broker consists of a client side \nRequestor and a server side Invoker. The Requestor and Invoker require a Marshaller for \ncommunication. The client and server side Marshallers are protected using the Shield \nprimitive. The Requestor and Invoker components are connected via the Broker component. \nThis connection is modeled using the Virtual Connector primitive. The ProtocolPlugin \ncomponents are used to provide the necessary protocols for the Broker component. The server \nside of the ProtocolPlugin has a Callback applied so that the Broker component has a \nreference to the ProtocolPlugin component.       \nNote that the system modeled is only a demonstration of the primitives and not the system \nitself.\nFigure 4 shows the Leela system modeled in Primus. Some tags have been added to \nsimplify reader interpretation. \nFigure 4: Simplified Leela system\nWe will also present a validation example for the Callback primitive. If the Callback \nprimitive has been implemented properly, the feedback to the user will something similar to \nFigure 1. This means that the model-checking feature has found a Callback and that it has \nbeen found between the components stated. If we now change a critical part of the Callback \nthen it should also inform the user of the exact nature of the problem. For example, an \nessential part of the Callback primitive is the stereotyping of one of the interfaces with the \nIEvent stereotype. If we undo the application of the stereotype the model checker will return \nthe message from Figure 5.\nFigure 5: Callback model checking with error\nThis message shows that the model checker is able to find a primitive that has not been \napplied properly and is able to state the exact problem. Therefore the user can easily correct \nthe problem.  \nUsing OCL to achieve the goals stated above has been achieved by returning every sub-\nresult needed to validate a primitive. If a sub-result differs in value from the expected value \nthen an error has been found and we automatically know what the error is. A further \ninterpretation of the results is needed in Java so that the result can be presented properly to the \nuser.\nComponent.allInstances()->collect(i |\ni.ownedConnector->collect(conn |\nlet callerPortSter : Port = conn.end.partWithPort->\nany(owner=i).oclAsType(Port)->\nany(p | p.oclAsType(Port).getAppliedStereotypes()->\nany(name='EventPort')-> notEmpty()),\ncallbackPortSter : Port =conn.end.partWithPort->\nany(owner<>i).oclAsType(Port)-> \nany(p | p.oclAsType(Port).getAppliedStereotypes()->\nany(name='CallbackPort')-> notEmpty()),\nTuple{c1=i,c2=otherComp,callerPort=callerPortSter,callbackPort = callbackPortSter\nThe code above shows a segment of the Callback query. The callerportSter and \ncallbackPortSter are sub-results that we are interested in and if a null value is returned we \nknow that the relevant port was not stereotyped. This query will of course return many \npotential Callbacks within the model. The query can then be filtered to only include potential \nCallbacks that have x or less amount of problems.\n6. Lessons Learnt\nThe Primus tool was developed to investigate the practicality of the research work carried \nout by us. The results, for the systematic modeling of architectural primitives in system \ndesign, are thus far quite encouraging. Based on our experience, we are quite capable to draw \nsome important lessons that we learnt during the development of Primus tool in the open \nsource Eclipse environment, as described below:\nComplexity: Eclipse UML tools’ API support for the visual modeling of software in \nComponent-Connector view is still under development. In the absence of graphical editors for \nmodeling architectural elements in software design, a developer has to interact directly with \nthe UML elements in its metamodel in Component-Connector view. Although, the Eclipse\nUML2 tools community is working to provide visual features for modeling software in \nComponent-Connector view, the current plug-in is hard to use and understand with the \nexisting layout. This introduces the complexity to interact with the Eclipse UML tools plug-in \nin the Component-Connector View.\nConstant Development: The Eclipse MDT provides a solid base for plug-ins development \nwith the purpose of a system where different plug-ins can interact with each other to provide \nbetter reusability and efficient development support. In the case of Primus tool, the plug-ins \nthat we interact with are UML2 tools and OCL. However, being immature open source \nmodules, these plug-ins are in constant development resulting in an evolving state, which is \ndifficult to manage and understand. \nLack of Documentation: Currently, the documentation concentrates on how to use the plug-ins \nwith some basic examples. This proved to be a big challenge during the development of the \nPrimus tool, which involves a complicated interaction with Eclipse plug-ins through a number \nof interfaces. We found the following three challenges during the development of the Primus \ntool:\n There are not enough coding examples documented by the Eclipse community\n There is not enough technical information about how the plug-ins has been developed.\n The general architecture of the plug-in is hard to understand in the absence  of design \ndocuments\nPoor OCL editor: We use OCL queries to locate the primitives in the system design and to \nreturn an error value when a primitive is incorrectly modeled in system design. However, the \nOCL queries, that return an error, can lack detail in the explanation and location of the error. \nAn ideal situation would be the exact nature of the error, what line of code generated the error \nand at what point in the model generated the error. A more advanced editor could help in \ndeveloping queries. Perhaps similar to SQL query editors.\nPerformance Issues in Eclipse : Eclipse poses high requirements on the hardware front on \nwhich the system requires adequate free memory and high processor speed. This at times \nresults in abnormal termination of program or deadlock situation, even when a slightly less \ncapable system is used as compared to the deemed system requirements.\nTime and Cost vs. Learning Curve : We consider the following factors that consumed most of \nour time while working with the Eclipse open source environment:\n Installation: In the absence of concrete guidelines for the installation of Eclipse MDT \nalong with the necessary plug-ins, the correct installation and setup of Eclipse platform \nconsumed extra time and effort. We spent nearly 3 weeks to install and configure the \nEclipse environment.\n Understanding the Eclipse UML tools: Being new to the Eclipse environment, most of the \nEclipse UML tools understanding was done using trial and error approach, which \nconsumed much of the time. The Component-Connector diagram of UML is still in the \ndevelopment phase and considerably lacks in providing adequate information about how \nthe UML specification maps to the Eclipse UML plug-in. Certain aspects of the UML \nspecification are implemented in a very specialized way in the Eclipse environment. For \nexample the connector metaclass is represented in a specific way in the Eclipse UML \nplug-in, making it difficult for users to understand it without the proper documentation.\n Online Community: The most positive aspect of using the Eclipse MDT was its active and \nresponsive online community that shared their experiences and provided us the technical \nfeedback to our queries using online forums. This not only helped us in using the Eclipse\nplug-ins and its platforms but also it provided us the opportunity to report bugs and hence \ngot them fixed either by the regular Eclipse developers or even by the user itself.\n7. Related Work\nThe Primus tool development using the Eclipse environment described in this paper \nprovides a practical implementation of our previous work [1] where we present a set of \nprimitives for modeling architectural patterns. The use of the Eclipse environment and work \nwith its plug-ins is not novel as a large community of developers and users is already actively \ninvolved in working with the Eclipse environment. However, the novelty of our work lies in \ndocumenting the challenges associated in using the Eclipse environment from the \ndevelopment perspective.\nThe related work to our work is two fold in this perspective: a) the developers using the \nEclipse open-source environment; and b) the experiences documented by researchers to \ninvestigate the suitability of using open source platforms. However, as per our knowledge, \nthere exist little documented information in using open source environments in general and \nEclipse in particular. Despite the presence of some of the tools developed using Eclipse (e.g. \nVisual Paradigm [19]), there has been a little focus in documenting the challenges. Few other \nresearchers [2] [16] have documented some of the challenges.\nMichelle [16] highlights the challenges related to user interface, documentation, \nprogramming, etc. in open source environments. He highlights the cost vs. ease of use when \nusing the open source environment. Our work distinctively differs from him as we work with \na tool which involve more depth interaction with the Eclipse open source environment which \nlets us document more solid lessons for using such platforms.\nSimon et al. [17] extends the UML metamodel by creating pattern-specific profiles. The \nwork by Simon et al. maps the MidArch ADL to the UML metamodel for describing patterns \nin software design. However, this approach does not address the issue of modeling a variety \nof patterns documented in the literature. Therefore, rather manual work is required to create \nprofiles for each newly discovered pattern. Our approach distinctively differs from this work \nas we focus on describing a generalized list of patterns using the primitives.\nThe work by Dim et. al. [20] propose a re-factoring approach that uses the Reba tool to \nconnect mismatched software libraries. However, their approach is more helpful in the plug-in \ndevelopment where the base functionality of a pug-in is updated leaving it in a state of \nmismatch with the collaborating plug-ins. Our approach is different because we use only the \ninterfaces of existing eclipse plug-ins without affecting their internal functionality. We expect \nthat the interfaces offered by the Eclipse plug-ins will not be affected with the further \ndevelopment of existing plug-ins.\n8. Conclusion and Further Work\nThis paper describes our experience of developing the Primus modeling tool using the \nEclipse open source environment. The development experience not only provides a practical \nimplementation of our ongoing research work but it reveals many challenges and benefits of \nusing the Eclipse platform for the tool development. During the process, we have found that \nthe Eclipse MDT provides good support to re-use existing plug-ins and rich technical support \nfrom online communities. However, it comes up with numerous challenges such as poor \ndocumentation, constant development of plug-ins, and weak visualization support for UML \ncomponent diagrams due to immature state of relevant plug-in.\nWe may conclude that, relating to tool development using Eclipse environment, Eclipse\nplug-ins still lack maturity. In fact, the significant aspect of underlying Eclipse platform \ndocumentation is missing and the only way to understand the Eclipse MDT domain is through \nthe online community support. However, we do not consider the online community as an \nalternative to thorough documentation especially when it comes to the understanding of \nEclipse MDT design. However, the online community is highly beneficial in sharing \nexperiences and devising an approach that best meets the problem at hand.\nWe have concentrated on the initial step of systematically modeling and finding the \narchitectural primitives in system design. The results generated so far are quite satisfactory \nand provide a solid base for further extending the tool for the systematic modeling of \narchitectural patterns. Moreover, eventually we plan to cover software modeling in other \nviews such as the behavioral view.\nReferences\n[1] Uwe Zdun and Paris Avgeriou. Modeling Architecture Patterns using Architecture Primitives, OOPSLA’ \n05, ACM, October 2005\n[2] Diomidis Spinellis, Clemens Szyperski,, IEEE Software, 0740-7459, Copyright 2004, IEEE\n[3] Model Development Tools, www.Eclipse.org/mdt\n[4] The Apache Software Foundation, http://www.apache.org\n[5] ArgoUML, http://argouml.tigris.org\n[6] ACME Studio, http://www.cs.cmu.edu/~acme/AcmeStudio/tutorials.html\n[7] Robert Allen and David Garlan, A Formal Basis For Architectural Connection, ACM Transactions on \nSoftware Engineering and Methodology, vol. 6, no. 3, pp. 213-249, July 1997\n[8] Borger, Jrobbins, Linus, A UML design tool with cognitive support, http://argouml.tigris.org\n[9] Frank Buschmann, Kevlin Henney, and Douglas C. Schmidt, Pattern-Oriented Software Architecture: On \nPatterns and Pattern Languages, John Wiley & Sons, ISBN 978-0-471-48648-0\n[10] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Design Patterns: Elements of Reusable \nObject Oriented Software, Addison-Wesley Professional Computing Series, 1995\n[11] Frank Buschmann, Kevlin Henney, Douglas C. Schmidt, Pattern-Oriented Software Architecture: A Pattern \nLanguage for Distributed Computing, John Wiley & Sons, ISBN 978-0-470-05902-9\n[12] David Garlan, Robert Monroe, David Wile, ACME: An Architecture Description Interchange Language, \nProceedings of CASCON 97, Toronto, Ontario, pp. 169-183, January 1997\n[13] OMG, , 2007, Model Driven Architecture, http://www.omg.org/mda/\n[14] Nenad Medvidovic, David S. Rosenblum, David F. Redmiles, Jason E. Robbins, Modeling Software \nArchitectures in the unified modeling language, ACM Transactions on Software Engineering and \nMethodology, vol. 11, no. 1, pp. 2-57, January 2002\n[15] Object Constraint Language Specification versions 1.1, OMG standard, http://umlcenter.visual-\nparadigm.com/umlresources/obje_11.pdf\n[16] Michelle Levesquem, http://www.firstmonday.org/issues/issue9_4/levesque, March 1 2004\n[17] Simon Giesecke, Florian Marwede, Matthias Rohr, Willhelm Hasselbring, A Style-Based Architecture \nModeling Approach For UML2 Component Diagrams, In Proceedings of Software Engineering and \nApplications, SEA 2007, Cambridge, MA, USA, 2007 \n[18] Jansen, A. van der Ven, J. Avgeriou, P. Hammer, D. K, Tool Support for Architecting Decisions, Working IEEE \nconference, WICSA 2007\n[19] Visual Paradigm for UML, http://www.visual-paradigm.com/product/vpuml\n[20] Danny Dig, Stas Negara, Ralph Johnson, Vibhu Mohindra, ReBA: Refactoring-aware Binary Adaptation of \nEvolving Libraries, ICSE’08, May 10–18, 2008, Leipzig, Germany",
  "topic": "Eclipse",
  "concepts": [
    {
      "name": "Eclipse",
      "score": 0.7493873834609985
    },
    {
      "name": "Documentation",
      "score": 0.7177892923355103
    },
    {
      "name": "Open source",
      "score": 0.662337601184845
    },
    {
      "name": "Computer science",
      "score": 0.5938365459442139
    },
    {
      "name": "Software engineering",
      "score": 0.5634227395057678
    },
    {
      "name": "Open source software",
      "score": 0.4849851131439209
    },
    {
      "name": "Software",
      "score": 0.42004287242889404
    },
    {
      "name": "Systems engineering",
      "score": 0.37305063009262085
    },
    {
      "name": "Data science",
      "score": 0.35017526149749756
    },
    {
      "name": "Engineering",
      "score": 0.2807885408401489
    },
    {
      "name": "Programming language",
      "score": 0.09106782078742981
    },
    {
      "name": "Astronomy",
      "score": 0.0
    },
    {
      "name": "Physics",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I169381384",
      "name": "University of Groningen",
      "country": "NL"
    }
  ]
}