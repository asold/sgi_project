{
  "title": "On Executable Meta-Languages applied to Model Transformations",
  "url": "https://openalex.org/W1510956003",
  "year": 2005,
  "authors": [
    {
      "id": "https://openalex.org/A4302678538",
      "name": "Muller, Pierre-Alain",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A2993014625",
      "name": "Fleurey, Franck",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A4292227946",
      "name": "Vojtisek, Didier",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A4304268750",
      "name": "Drey, Zoé",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A4360650647",
      "name": "Pollet, Damien",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A2750489941",
      "name": "Fondement Frederic",
      "affiliations": []
    },
    {
      "id": null,
      "name": "Studer, Philippe",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A4227076131",
      "name": "Jézéquel, Jean-Marc",
      "affiliations": [
        "Reliable Software Resources (United States)"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W34068569",
    "https://openalex.org/W1649645444",
    "https://openalex.org/W2149540362",
    "https://openalex.org/W2005915144",
    "https://openalex.org/W146458024",
    "https://openalex.org/W1552255008",
    "https://openalex.org/W2098009157",
    "https://openalex.org/W1532283544",
    "https://openalex.org/W1978613757",
    "https://openalex.org/W2957400920"
  ],
  "abstract": "Domain specific languages for model transformation have recently generated significant interest in the model-driven engineering community. The adopted QVT specification has normalized some scheme of model transformation language; however several different model transformation language paradigms are likely to co-exist in the near future, ranging from imperative to declarative (including hybrid). It remains nevertheless questionable how model transformation specific languages compare to more general purpose languages, in terms of applicability, scalability and robustness. In this paper we report on our specific experience in applying an executable meta-language to the model transformation field.",
  "full_text": "On Executable Meta-Languages applied to Model \nTransformations \nPierre-Alain Muller1, Franck Fleurey1, Didier Vojtisek1, Zoé Drey1, Damien Pollet1,  \nFrédéric Fondement2, Philippe Studer3 and Jean-Marc Jézéquel1 \n \n1 IRISA/INRIA, France {pamuller, ffleurey, dvojtisek, zdrey, dpollet, jmzequel}@irisa.fr \n2 EPFL/IC/UP-LGL, INJ, Switzerland, frederic.fondement@epfl.ch \n3 MIPS, Université de Haute-Alsace, France, philippe.studer@uha.fr \nAbstract. Domain specific languages for model transformation have recently \ngenerated significant interest in the model-driven engineering community. The \nadopted QVT specification has normalized some scheme of model \ntransformation language; however several different model transformation \nlanguage paradigms are likely to co-exist in the near future, ranging from \nimperative to declarative (including hybrid). It remains nevertheless \nquestionable how model transformation specific languages compare to more \ngeneral purpose languages, in terms of applicability, scalability and robustness. \nIn this paper we report on our specific experience in applying an executable \nmeta-language to the model transformation field. \n1 Introduction \nA DSL (Domain-Specific Language) is a specification or programming language \nwhich offers, through appropriate notations and abstractions, expressive power \nfocused on, and usually restricted to, a particular problem domain.  \n \nModel transformation is a key facet of model-engineering, by which models which \nconform to some metamodels are translated into models which conform to some other \nmetamodels. Technologies to perform model transformations range from conventional \nprogramming languages to specific transformation languages. \n \nDomain specific languages for model transformation have recently generated \nsignificant interest in the model-driven engineering community. The OMG has \nadopted the QVT (Query, View, Transformation) specification, which normalizes \nsome scheme of model transformation language. \n \nHowever, many open issues about transformation languages still remain, and it is \nlikely that several alternative paradigms (such as imperative, declarative or hybrid) \nwill co-exist in the foreseeable future of model transformation languages.  \n \nFrom a software engineering point of view, it is highly desirable to gain a better \nunderstanding of how these various kinds of model transformation languages address \n2      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nissues such as applicability, scalability and robustness. Indeed, there is not yet much \npractical experience with dedicated model transformation languages versus general \npurpose languages with respect to model transformations, and the optimal scope of \ndomain specific transformation languages remains unclear. For instance, should these \nmodel transformation languages be limited to model manipulation in general and be \nassociated to specific libraries, or should they emphasize a specific activity performed \nwith models, such as transformation? \n \nIn this paper we report on our experience with executable meta-languages \nassociated to specific frameworks to develop model transformations. Our experience \nis based on the development and use of three different imperative object-oriented \nlanguages for model manipulation, respectively: MTL a transformation language, \nXion an action language and Kermeta an executable meta-language.  \n \nAlthough it has made this paper lengthy, we have decided to give substantial \nexcerpts of the source code of the transformations, because we found it relevant in the \ncontext of a workshop dedicated to language comparison. Hopefully, the impatient \nreader may not have to browse through all these examples to understand our approach \nto model transformation, as we have motivated and summarized our position in the \nfirst sections of the paper. The complete sources of the examples can be found on \nhttp://www.irisa.fr/triskell/Softwares/kermeta/examples/mtip, from where the \nKermeta Workbench can also be downloaded. \n \nThis paper is organized as follows: after this introduction, section 2 highlights the \nrationales for our work and examines some related works, section 3 presents the Xion, \nMTL and Kermeta languages, section 4 discusses model transformation design \noptions with executable meta-languages, section 5 implements and discusses the \nworkshop case-study, and finally section 6 (the conclusion) summarizes our position \nand outlines future directions.  \n2 Rationales for object-oriented executable meta-languages \nIn the model-driven engineering community, meta-languages such as MOF1 are \nwidely used to specify meta-models. The issue of persistence is well understood, and \nis achieved either via a serialization in XML (via XMI, for XML Metadata \nInterchange), or via direct storage in some database (e. g. MDR2). \n \nYet, existing meta-data languages (including MOF, EMOF\n1, ECore3, MetaGME4), \nas their generic name suggests, are languages for defining data about data. Such data-\ndriven languages focus on structural specifications and have no built-in support for \nthe definition of behavior about these structures. There are mainly two options to \nwork with the metamodels (and models) stored in the repositories: \n \nOn Executable Meta-Languages applied to Model Transformations      3 \n· Using conventional programming languages, such as Java, via specific \nlibraries which provide facilities to navigate, create, read or delete models and \nmodel elements. \n· Using domain specific languages, such as action languages, constraint \nlanguages and transformation languages. \n \nWe believe that the rationale for the current separation between data and behavior \nspecifications at the meta-meta level is mainly coincidental and results from the fact \nthat research works in the field of model-driven engineering have been initially \nconducted by technical domains; mainly driven by functional user requirements, such \nas definition of actions, constraints and transformations, with little sharing beyond the \ndata persistence level. \n \nIn our opinion, there is now enough understanding of these functional domains to \ninitiate a convergence under the shape of some kind of common denominator of the \nfundamental current model-driven technologies, i.e. languages for meta-data \ndefinitions (such as MOF, EMOF, Ecore), model transformations (including MTL\n5 \nand ATL6, all more or less QVT7 compliant), constraint and query expressions (such \nas OCL8) and action specifications (such as the Action Semantics9, now integrated in \nUML 2.0). \n \nWe claim in this paper that a common kernel of language constructs can be defined \nto serve all purposes of model manipulations such as definition of metamodels and \nmodels, actions, queries, views and transformations. Moreover, making this kernel \nexecutable provides direct support to express the operational semantics of \nmetamodels. \n \nThis kernel should contain basic instructions to define model structure and \nelements, manipulate the models and the model elements via fundamental create, \nread, update and delete operations, as well as iterators to navigate models or sets of \nmodel elements. \n \n \nFigure 1: Meta-data, action, transformation and constraint languages share a \ncommon subset of language constructs. \n4      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \n \n \n2.1 Related works \nOur work is related to many other works, and can be considered as some kind of \nsynthesis of these works, in the specific context of model-driven engineering applied \nto language definition. The sections below include the major areas of related works. \n \nGrammars, graphs and generic environment generators. Much of the concepts \nbehind our work take their roots in the seminal work conducted in the late sixties on \ngrammars and graphs and in the early eighties in the field of generic environment \ngenerators (such as Centaur\n10) that, when given the formal specification of a \nprogramming language (syntax and semantics), produce a language-specific \nenvironment. The generic environment generators sub-category has recently received \nsignificant industrial interest; this includes approaches such as Xactium11, or Software \nFactories12. Among these efforts, it is Xactium which comes closer to our work. The \nmajor differences are our adherence to OMG standards (such as EMOF) and the fact \nthat we have a fully static type system. \n \nGenerative programming and domain-specific languages. Generative \nprogramming aims at modeling and implementing system families in such a way that \na given system can be automatically generated from a specification written in a \ndomain-specific language. This includes multi-purpose model-aware languages such \nas Xion or MTL\n5, or model transformation languages such as QVT7. \nWe share the vision of generative programming, and we use models to generate \nfully executable code which can be compiled. The Xion and MTL languages have had \na direct impact on our work.  \nQVT is different as it addresses mappings between models. QVT works on \nstructures, by specifying how one structure is mapped into another one; for instance \ntranslating a UML class diagram into a RDBMS schema. QVT is not suitable for the \ndefinition of the behavior of metamodels. \n3 Overview of Xion, MTL and Kermeta \nXion and MTL are the ancestors of the Kermeta language. Xion is a platform \nindependent action language which has been originally developed in the context of \nthe Netsilon environment, for model-driven development of Web information \nsystems13. MTL is an object-oriented model transformation language, which has been \ndeveloped with software engineering concerns in mind, such as robustness, \nmodularity and scalability. Interestingly, the two teams which have developed Xion \nand MTL independently have come to the same kind of conclusions. They have both \ndeveloped a general-purpose, imperative, object-oriented language, with model-\nOn Executable Meta-Languages applied to Model Transformations      5 \nnavigation capabilities based on OCL, control structures such as found in Java or \nEiffel, and with model management capabilities. \nThe lessons learned with Xion and MTL have shaped the requirements of Kermeta. \nKermeta is a multi-faceted language. Kermeta is a small imperative object-oriented \nlanguage, which is both an executable meta-langage and a kernel upon which to build \nother languages (such as Xion or MTL which could be re-expressed in Kermeta). \nAlthough Kermeta is a small language, it provides high-level mechanisms such as \nstatic-typing, genericity and exceptions.  \n3.1 Xion \n \nXion is a general-purpose object-oriented action language, with special support for \nmodel manipulation, and automatic persistence of model elements. Xion is a \nplatform-independent action language which abstracts away the details of data access, \nwhile being translatable into different target languages (such as PHP or Java).  \n \nXion provides modeling concepts such as classes (with attributes, operations and \nmethods), associations and aggregations, class-associations, and simple \ngeneralizations. Xion is a semi-graphical language, classes, attributes, operations and \nrelations are defined via class diagrams; add- and remove-link operations are \ngenerated automatically. User-defined methods are specified in text.  \n \nIn the context of this case study, Xion is used as an executable meta-langage, in \nwhich case the metamodels are expressed in terms of classes and relations, in a \nmanner very similar to what is done with MOF or ECore. \n \nXion provides support to query models and to express methods and state changes \nvia an extension of the OCL query expressions. This means adding side-effects \ncapability to OCL, and providing imperative constructs, such as blocks and control \nflows. Supporting side-effects means: \n· create and delete an object, \n· change an attribute value, \n· create and delete links, \n· change a variable value, \n· call non-query operations. \nIt was also necessary to remove some constructs of the OCL, which are out of the \nscope of our approach: \n· context declaration, only useful for defining constraints, \n· @pre operator and message management, only meaningful in the context of \nan operation post-condition, \n· state machine querying. \n6      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nSince most developers are already familiar with the Java language, we re-used part \nof its concrete syntax. Constructs we took from Java are: \n· instruction blocks, i.e. sequences of expressions, \n· control flow (if, while, do, for), \n· return statement for exiting an operation possibly sending a value, \n· “ super”  initializer for constructors. \nMoreover, for Xion to look like Java as much as possible we decided to keep Java \nvariable declaration, and operators (==, !=, +=, >>, ? ternary operator, etc.) rather \nthan those defined by OCL. The standard OCL library was also slightly extended, by \nadding the Double, Float, Long, Int, Short and Byte primitive types, whose \nsize is clearly defined unlike the OCL Integer or Real. As applications often deal \nwith time, we have also added the Date and Time predefined types. An exhaustive \npresentation of the language is given in the help of the Netsilon tool.  \n3.2 MTL \nMTL (Model Transformation Language) is an imperative object-oriented language, \nwhich has been developed to experiment with new ideas in the context of the MOF \nQVT normalization process, and to make sure that research concerns will be taken \ninto account. \n \nMTL shares much of the description of Xion given beyond, in terms of abstract \n(and even concrete) syntax. A major difference is the requirement of MTL to be tool \nindependent. Whereas Xion was emphasizing automatic object persistence, MTL \nseeks model (and metamodel) representation independence, and can interact in a \nunified way with various model repositories such as MDR (MetaData Repository, \nSun), ModFact\n14 (Lip6) and EMF (Eclipse Modeling Framework, IBM). For instance, \na MTL transformation written for a given model, can then be applied to that model \nindependently of the language (say MOF or ECore) used to express the metamodel of \nthat given model. As a central tool, MTL helps investigate and federate different \nresearch areas and tools related to model transformation which share common \nconcepts: models and meta-models. \n \nMTL was designed with strong software engineering concerns in mind, such as \nscalability and robustness. As model transformations may become quite complex, the \ntransformation developers should be able to re-use popular know-how and best \npractices of software engineering. In other words, the transformation must be \ndesigned, modelled, tested and so forth. The MTL language therefore uses an object-\noriented style similar to popular languages like Java and C#. One of the special \nfeatures is that elements of the models and classes of the language are manipulated in \na consistent way. There is no difference between navigating or modifying a model \nand using transformation classes; for instance, both use the concepts of class, \nattribute, association, etc. Best practices obviously include the ability to apply the \nOn Executable Meta-Languages applied to Model Transformations      7 \nMDE approach to the transformations themselves. This is done within MTL with a \nbootstrap process: the components of the transformation engine are written using the \nengine itself. \n \nMTL is distributed as open-source software. Technically, its user interface is based \non a plug-in within Eclipse which provides a dedicated editor for the textual syntax of \nMTL, an execution environment and an outline view.  \n3.3 Kermeta \nKermeta has been designed to be the core language of a model-oriented platform\n15. \nKermeta, as shown in Figure 1, can be considered as a common denominator of \nseveral model-oriented technologies.  \n \nKermeta consists of an extension to the Essential Meta-Object Facilities (EMOF) \n2.0\n1 to support behavior definition. It provides an action language to specify the body \nof operations in metamodels. The action language of Kermeta is imperative and \nobject-oriented. \n \nKermeta has been defined based on the experience of two existing languages Xion \nand MTL. Xion is an action language for UML class diagrams; it is used to provide a \nhigh level platform independent implementation of operations and methods. The \nNetsilon tool is used to generate either java or PHP code from Xion code.  \n \nMTL (Model Transformation Language) is an object-oriented model \ntransformation language. It provides APIs to allow manipulating models from various \nrepositories (Eclipse EMF, Netbeans MDR...) in a unified manner.  \n \nXion and MTL have been designed for different purposes but they share many \nconstructions such as expression for querying model or CRUD operations on objects. \nKermeta is mainly an object-oriented language which includes features such as \nmultiple inheritance, operation redefinition, class genericity and dynamic binding. \nHowever, for model processing, specific construction were added to handle model \nspecific features such as associations and object containment. In addition to these, and \nfor usability purposes, convenient model navigation expressions such as OCL \niterators (select, collect, reject… ) have been added. The resulting language is fully \nstatically typed to ensure strong reliability concerns. \n \nThe Kermeta platform is developed at INRIA as an open-source project\n16. It \ncurrently includes a parser, a type-checker and an interpreter. It is distributed as en \nEclipse plug-in which includes an editor for Kermeta programs with syntax coloring \nand code completion capabilities. In addition the platform includes libraries to load \nand store models from the Eclipse Modeling Framework and to import ECore \nmetamodels. \n8      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n4 Discussion \nIn this section, we will cover the points of discussion that were listed in the call for \npapers, and some others that we find relevant in the context of Kermeta. \nObject-orientation \n \nKermeta is an object-oriented language, which provide support for classes and \nrelations, multiple inheritance, late binding, static typing, class genericity, exception, \ntyped function objects…  The object-oriented nature of Kermeta has a double origin. \nFirst, as for Xion which is based on UML, the structural part of the Kermeta language \nis based on an object-oriented meta-data language (EMOF). Next, as for MTL, there \nis a strong requirement for Kermeta to support software engineering good-practices \nsuch as modularity, testability and reuse, which are well supported by object-\norientation. \n \nThe refactorings optional part of the case study is a good example of how object-\noriented techniques, such as patterns, may be applied to model transformations. The \nKermeta implementation shows the use of a command patterns to apply a \ntransformation. Interestingly, this also provide an example of doing and undoing a \ntransformation. \n \nFinally, object-orientation eases the learning of the new language, as many \ndevelopers are used to that paradigm, and can immediately apply their programming \nskills in the context of model transformation.  \nComposition of transformations \n \nKermeta provides packages, classes, operations and methods, inheritance and late \nbindings. All these features can be used to encapsulate transformations. Composition \nof transformations can be achieved in several ways, for instance by operations calls or \nmethod overloading. Rule recursivity is handled by function recursivity. \nRobustness and error handling. \n \nReliability is a major concern in the design of Kermeta. The language is statically \ntyped, and the code can be fully checked for correctness at compilation time. For \nunexpected behavior at runtime, the language provides exception handling. \nDebugging support \n \nThe debugger is under development. This is not part of the language itself, but of \nthe Kermeta Workbench. In the meantime, traces are used to help solving problems in \nthe transformation code. \nOn Executable Meta-Languages applied to Model Transformations      9 \nFlexibility, overall usability and power of the chosen approach \n \nTo our opinion, Kermeta is currently a very good compromise between a general-\npurpose language such as Java, and a specific model transformation language such as \nspecified by QVT. The implementation of the workshop case study, given below, \nproofs that the language is usable for model transformation, and also that is can \nhandle all kinds of transformations (either specified via mappings as for the class to \nRDBMS example, or via algorithms as for the determinization/minimization of \nautomata). \nWhether the approach can express bidirectional and / or incremental (sometimes \nknown as change propagating) transformations \n \nThis is really a matter of programming. The Arabic and Roman numbers, and the \nrefactorings, are examples of bidirectional, and change propagating transformations. \nTechnical aspects such as the ability to deal with model exchange formats, \nmodeling tool APIs, and layout updates \n \nKermeta is fully compatible with ECore. The structural part of Kermeta is compliant \nto ECore, and the behavioral part is expressed as an ECore metamodel. Thus, any tool \ncompatible with ECore is compatible with Kermeta. Kermeta can read and write \nECore files to load and save models. The Kermeta workbench is available as an \nEclipse plugin. \nGeneral purpose language vs. model transformation language \nKermeta has nothing specific to model transformation, but being quite general \npurpose, it can be used to implement mechanisms to support model transformations. \nAs with general-purpose languages such as Java, specific support (for instance for \ntransformations triggering, trace and debugging) is added via libraries and \nframeworks. This gives extensive expression freedom to the developer to write the \ntransformations.  \n \nFor instance, in the class to RDBMS example, information has to be stored in one \npass to be used in another one. The Xion example also shows how part of the \ntransformation are queued and triggered later on by other parts, for instance to query \nthe target model when transforming the associations. \n \nHowever, there is a wide variety of potential design choices depending on the \ntransformation developer’s needs, such as the usual trade-offs between complexity \noptimization and memory optimization. This implies that the transformation language \nmust be generic enough to take into account the various needs of the developers. \n \n10      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nDesign variations, libraries vs. DSLs \nWriting a transformation can be done is many different ways. A final design \nreflects a set of tradeoffs made by the developer. The variation of the designs may be \nmore or less constraint by the amount of pre-design and reuse provided by the \nlanguage environment. Libraries and frameworks can be used to provide specific \ncapabilities, such as traceability or information storage about the transformation \nprocess itself. \n \nSuch pre-design decisions can be captured either in libraries or in the language \nitself, and this is the difference between libraries for general purpose languages, and \nDSLs.  \n \nKermeta has precisely been built to facilitate such transition, when the domain \nknowledge is such that it is worth to embed this knowledge directly in a dedicated \nlanguage. Our position is similar to D. Roberts and R. Johnson\n17 who state that a \nprerequisite to developing a DSL is mature domain knowledge. Kermeta can be used \nto represent the abstract syntax of languages, under the shape of metamodels. Then, \nKermeta being executable, the operational semantic of these languages can be further \nspecified in Kermeta, reusing the library code which was previously developed. \nSoftware engineering concerns \nSince model transformation may become quite complex, we believe that \ntransformation developers need to re-use popular know-how and best practices in \nsoftware engineering. Kermeta provides language support for modularity in the small \n(classes) and the large (packages), reliability (static typing, typed function objects and \nexception handling), extensibility and reuse (inheritance, late binding and genericity). \nFuture work \nMaintaining consistency of the relations between transformations is a real challenge \nand requires dedicated language and tool support. Requirements include: \n \n· application of design patterns \n· development of helper frameworks \n· support of the Design by Contract approach \n· weaving of modelling aspects \n· derivation of products from product lines \n· code generation \n· simulation of functional and extra-functional features of a system \n· derivation of state charts from HMSC (High-Level Message Sequence Chart, the \nbasis of UML2.0 sequence diagrams) \n· synthesising test cases from UML models \nOn Executable Meta-Languages applied to Model Transformations      11 \n \n5 MTIP workshop case studies \nThis section presents the transformations that we have written to implement the \nrequirements of the MTIP workshop case study. Sub-sections 5.1, 5.2 and 5.3  present \nthe mandatory transformations, respectively in Xion, MTL and Kermeta, then section \n5.4 shows the optional example of Roman and Arabic numbers in Kermeta, section \n5.5 gives an example of refactoring written in Kermeta, and finally section 5.6 \npresents the determinization and minimization of automata in Kermeta. \n5.1 Mapping classes to tables in Xion \nThe following metamodels are part of the MTIP case study. They have been \nrepresented visually with the Netsilon class diagram editor. Figure 2 and Figure 3 \nshow respectively the source and target metamodels of the MTIP workshop case \nstudy. Notice that various operations have been added to the classes. Adding these \noperations directly in the classes is questionable. On one hand, it promotes \nencapsulation and gives an object-oriented flavor to the transformation; on the other \nhand it establishes some coupling between the static aspect of the metamodel and a \nspecific transformation. Whether this is good or bad depends heavily on the context; \nin this example in Xion we chose the former option. In the following example in \nKermeta we will choose the latter. \n \n12      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \nFigure 2: Source metamodel expressed in Xion. \n \n \nFigure 3: Target metamodel expressed in Xion. \nOn Executable Meta-Languages applied to Model Transformations      13 \nIn addition to the classes defined in the case study, we have also defined two utility \nclasses Transformation and ClassTransformation, to store information \nabout the transformation process itself. \n \n \nFigure 4: Specific Xion classes to support transformations. \n The transformation process (initiated when the Run method of the \nTransformation class is invoked) first traverses all the classes in the source \nmodel, and creates a ClassTransformation instance (a pair Class, Table) \nfor each class which has to be made persistent. In a second step, the Transform \nmethod of class ClassTransformation creates the columns required to ensure \npersistence of all the attributes and relations present in the source model. \nTransformation Class \n \nThe Transformation class contains the top-level transformation methods. The \nprocess of transformation starts when the Run method is invoked.  \n \n \nFigure 5: Specification of the Transformation Class. \n14      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nFor all class hierarchy which contain persistent classes, a table is created for the \nroot class. The allInstances operation retrieves the collection of all the instances \nof the Class class. Xion is a persistent language; all the instances are automatically \nstored in permanent storage.  \n \nThe following Xion expression, creates a table for all topmost classes which are \neither persistent, or have at least one persistent subclass. All the metamodel classes \nare defined in a package named MM (for metamodel). \n \npublic Void Transformation::Run (Class class, Table table) { \n   MM::Class.allInstances() \n      ->select(parent == null) \n      ->select(c : c.is_persistent || c.hasPersistentChildren()) \n      ->collect(c : transformPersistentClass(c)); \n \n   this.classTransformation->collect(t : t.transform()); \n} \n \nwith \n \nprivate Void Transformation::transformPersistentClass (Class class) { \n   MM::ClassTransformation t =  \n      new MM::ClassTransformation(class, new MM::Table(class.name)); \n \n   this.addclassTransformation(t); \n   this.addremaining(t); \n} \nClass Class \n \n \nFigure 6: Specification of the Class Class. \n \nRule 6 states that attributes in subclasses with the same name as an attribute in a \nparent class are considered to override the parent attribute. The operation \ngetDistinctAttributesDown builds the set of attributes within a class \nhierarchy, while removing those overridden in subclasses. The operation starts from a \nroot class, and then collects recursively down the attributes defined in subclasses. \n \n \nOn Executable Meta-Languages applied to Model Transformations      15 \npublic Set(MM::Attribute) Class::getDistinctAttributesDown (){ \n   if (this.children == null) \n      return this.attribute; \n \n   Set(MM::Attribute) children =  \n      this.children.getDistinctAttributesDown()->asSet(); \n \n   return this.attribute \n      ->select(a : !children->exists(c : c.name == a.name)) \n      ->union(children); \n} \n \n \nAccording to the CFP, there is not association overriding. \n \nPublic Set(MM::Association) Class::getAssociationsDown(){ \n   Set(MM::Association) associations =  \n      MM::Association.allInstances()->select(a : a.src == this); \n \n   if (this.children == null) \n      return associations; \n   else \n      return associations \n         ->union(this.children.getAssociationsDown()->asSet()); \n} \n \n \n \nRule 6 states that when transforming a class, all attributes of its parent class (which \nmust be recursively calculated), and all associations which have such classes as a src, \nshould be considered.  \n \nAttributes in subclasses with the same name as an attribute in a parent class are \nconsidered to override the parent attribute. \n \n \npublic Void Class::map2table (Table t, Transformation transformation) \n{ \n  self.getDistinctAttributesDown().mapPersistentClassAttribute2column \n                                           (this, t, transformation); \n \n  this.getAssociationsDown().map2table(this, t, transformation); \n \n} \n \npublic Void Class::mapReferencedClass( Class sourceClass,  \n           Table sourceTable,  \n           String namespace,  \n           Transformation transformation) \n{ \n   // Be sure that the attributes have already been transformed \n   transformation.transform(this); \n \n   // 2. Classes that are marked as non-persistent should not be \n   // transformed at the top level. \n   if (!this.is_persistent) { \n      this.attribute \n         ->collect(a : a.mapNonPersistentClassAttribute2Column \n                              (sourceClass, sourceTable, namespace)); \n   }  \n   else{ \n      // Retrieve primary attributes \n      MM::Table table = transformation.findTable(this); \n16      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \n      Sequence(MM::Column) columns = table.pkey->asSequence(); \n \n      if (columns->size() > 0) { \n         MM::FKey fkey = sourceTable.createForeignKey(table); \n         for (Integer i = 0; i < columns->size(); i++) { \n            sourceTable.addToForeignKey(fkey,  \n                             new MM::Column (namespace + \"_\" +  \n                                    columns->at(i).name,  \n                                    columns->at(i).type)); \n        } \n      } \n   } \n} \nAttribute class \nTwo operations have been added to the Attribute class. These operations are \nresponsible for mapping an attribute to a column.  \n \n \nFigure 7: Specification of Attribute class. \n \nThe mapNonPersistentAttribute2Column operation is partially \nimplemented. In the case of a primitive type, a column is created, with renaming, and \nprimary key property if required. Other cases would to store information about \nattributes and associated columns, and were not implemented, for lack of time \nressource. \n \nVoid Attribute::mapNonPersistentAttribute2Column(Class sourceClass, \nTable sourceTable, String namespace){ \n   if (self.type.oclIsTypeOf(MM::PrimitiveDataType)) \n   { \n   // Rule 3 \n   // Attributes whose type is a primitive type should be transformed \n   // to a single column whose type is the same as the primitive type \n \n   MM::Column column = new MM::Column (namespace + \"_\" + self.name, \n                                       self.type.name); \n \n   sourceTable.addcols(column); \n \n   if (self.is_primary) \n      sourceTable.addpkey(column); \n   } \n   else if (self.type.oclAsType(MM::Class).is_persistent){ \n      // To Do \n   } \n   else if (self.type.oclAsType(MM::Class).is_persistent == false){ \n      // To Do \n   } \nOn Executable Meta-Languages applied to Model Transformations      17 \n   else{ \n      // should raise an error \n   } \n} \n \n \nVoid Attribute::mapPersistentClassAttribute2Column \n          (Class class,  \n           Table t,  \n           Tranformation transformation) \n   { \n   if (self.type.oclIsTypeOf(MM::PrimitiveDataType)){  \n      // Rule 3 \n      // Attributes whose type is a primitive type should be  \n      // transformed to a single column whose type is the same as the \n      // primitive type \n \n      MM::Column column = new MM::Column (self.name, self.type.name); \n      t.addcols(column); \n      if (self.is_primary) \n         t.addpkey(column); \n   } \n \n   else if (self.type.oclAsType(MM::Class).is_persistent){ \n      // Rule 4 \n      // Attributes whose type is a persistent class should be \n      // transformed to one or more columns, which should be created  \n      // from the persistent classes' primary key attributes.  \n      // The column should ne named name_transformed_attr where name  \n      // is the attributes' name. \n      // The resultant columns should be marked as constituting a \n      // foreign key; the FKey element created should refer to the  \n      // table created from the persistent class \n  \n      MM::FKey fk = t.createForeignKey(MM::Table.allInstances() \n        ->select \n          this.type.oclAsType(MM::Class).getRootAncestor().name == \n             name)->getOne()); \n   \n      self.type.oclAsType(MM::Class).getAttributesUp() \n         ->select(is_primary) \n         ->collect(pk : t.addToForeignKey(fk,  \n                                       new MM::Column \n                                        (pk.name+\"_transformed_attr\", \n                                         pk.type.name))); \n   } \n \n   else if (self.type.oclAsType(MM::Class).is_persistent == false){ \n      // Rule 5 \n      // Attributes whose type is a non-persistent class should be \n      // transformed to one or more columns, as per rule 2. \n      // Note that primary keys and foreign keys of the translated  \n      // non-persistent class need to be merged into the appropriate \n      // table \n   \n      self.type.oclAsType(MM::Class).mapReferencedClass(class,  \n                                                     t,  \n                                                     name, \n                                                     transformation); \n  \n   } \n \n   else{ \n      // should raise an error \n   } \n} \n \n18      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n5.2 Mapping classes to tables in MTL \nThis section presents some of the various techniques used to implement the ‘class \nto RDBMS’ example with MTL. As the reader will discover, these techniques are \nusually well known or simple. The relevance in the scope of this workshop is not to \ndo a precise description of each of them but to consider their simultaneous use in \norder to solve model transformation problems. The reader interested in the concrete \ncode can find an excerpt of the code in annex and the complete source of the \ntransformation on the MTL web site18. The global architecture for the implementation \nof the model transformation sample is organized around two passes into a visitor \npattern19. It is supported by a small framework and the use of some intermediate \nstructures. The interested reader will find the complete transformation on the MTL \nweb site; http://modelware.inria.fr/article71.html \nVisitor \n \nThe visitor pattern provides an easy way to traverse a model. Several points may \nbe tuned when using visitors, as a base, the visitor allows to call specific operations \ndepending on the type of the traversed elements. Another variation point may be \nobtained by defining the traversal order. The inheritance notion of the object oriented \nlanguage is then a simple way to profit of existing visitors. \n \nDepending on how the metamodel has been designed, one can generate some \ndefault visitors that provide a generic traverse order. These default visitors are usually \nbased on the composition relations in the metamodel.  This kind of visitor is useful as \nit ensures that the model elements are traversed only once. However, in our sample, \nnone of the metamodels use the composition. We choose to not change the metamodel \nof the sample because in practice the transformation developer may not have the \nopportunity to do so even if it would be simpler for him. In this situation, as we \ncannot use the default visitor, we provided an ad-hoc one which provides the same \nproperty. \n \nMoreover, MTL has some special aptitude with visitors. It automatically adds the \nneeded accept(visitor) method to any model element or MTL class. Then, writing or \ngenerating a visitor is quite straightforward. \n \nThe following code excerpt presents visitClass method of the \nClassVisitor Class. \n \nClass ClassVisitor \n \nvisitClass (instance : Standard::OclAny; context : Standard::OclAny)  \n : Standard::OclAny \n{ \n   theClass   : source_model::Class; \n   result    : VisitorResult; \n   \n   \n   // we create the result \n   result := resultFactory.create ();// we retrieve the called object \nOn Executable Meta-Languages applied to Model Transformations      19 \n   theClass := instance.oclAsType (!source_model::Class!); \n   // we continue the visit with the Attribute objects \n   foreach(anAttribute : source_model::Attribute) in (theClass.attrs) \n   { \n      result.add(anAttribute.accept (this,    \n       context).oclAsType(!Standard::OclAny!)); \n   } \n   // this would have been better if the association has been \n   // navigable from the class.  \n   // as the metamodel is not navigable this way, we have to retrieve \n   // it using a foreach on the type. \n   \n   foreach (anAssociation : source_model::Association) in  \n (!source_model::Association!.allInstances()){ \n      if( anAssociation.src.[=](theClass)) \n      {  // visit only association for which this class is source  \n         // (ensures that we visit only once)  \n         result.add (anAssociation.accept (this,  \n         context).oclAsType(!Standard::OclAny!)); \n      } \n   } \n   return result; \n} \nMultipass \n \nOne of the difficulties a transformation writer may encounter is about the \nappropriate time to apply some parts of the transformation.  In fact, when writing the \nspecification of the transformation, it looks like a set of rules that doesn’t take care if \nthe elements it refers to already exist or not. The transformation writer has to ensure \nthat an element has been created before linking it. For the case study sample, we have \nsplit the actions in two sets, each of them launched from a visitor. Then, the \ntransformation is applied in two passes. The first pass creates all the main elements in \nthe target model. It also links some of those elements, but only if the traverses order \nof the visitor ensures that the linked elements exist. Now, certain that all the elements \nexist, the next pass is free to apply any remaining rule. In order to clarify the code, the \ntransformation writer, may choose to use more than two passes and then group the \nexecution rules. Splitting the transformation into several passes also helps in writing \nand debugging the transformation as it is possible to visualize the intermediate results, \nconsidering each pass as an independent transformation. \n \n In the case of our sample, the first pass creates all the tables and the columns \naccessible via the primary key link. The second pass creates the remaining columns \nand links. As an illustration, the MTL code of the first pass is given below. \n \nvisitClass (instance : Standard::OclAny; context : Standard::OclAny)  \n : Standard::OclAny \n{ \n   theClass : source_model::Class; \n   result   : VisitorResult; \n   str      : Standard::String; \n   theTable : target_model::Table; \n   \n   // we create a new visitor result \n   result := this.resultFactory.create (); \n   // we retrieve the called object \n   theClass := instance.oclAsType (!source_model::Class!); \n  \n20      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n   // if persistent create a table \n   if classHelper.isClassPersistent(theClass) \n   { \n      // if this is the topmost parent then create the class \n      // otherwise , simply retrieve the table \n      if isNull(theClass.parent) \n      { \n    // create the table \n         theTable := class2RDBMSHelper.getTableForClass(theClass); \n      } \n      else \n      { \n           theTable := class2RDBMSHelper.getTableForClass( \n         \n classHelper.getTopParent(theClass)); \n trace.add(theClass, theTable); \n      } \n     \n      // we call the parent visit method,  \n      // the current class is passed in the context \n      this.oclAsType(!ClassVisitor!).visitClass(instance, instance); \n   } \n   /* else: non persistent classes, connected attributes  \n  and associations cannot be processed in pass 1 */ \n  \n   return result;     \n} \n \nSplitting the transformation also allows using the clearest and most efficient data \nsource for the implementation of the rules. The main logic of the transformation may \nrely on the source model, on the target model, or both. MTL by itself doesn't \npresuppose the transformation to use any of them. In fact, in our implementation, we \nhave used model elements from both the input and the output model. This is because \nwe favour the clearest algorithm as it will help for maintenance. \nIn pass1, we clearly use the source model because we are creating the target \nelements. Moreover, even if we had an existing target model to synchronize with, we \ncannot rely on its completeness and integrity during this phase. \nIn pass2, the scheme is slightly different; we already have a reliable intermediate \nmodel in the target model. Then, if the information in the target model is more \nexpressive than the information in the source model, it would be painful to restrict the \ntransformation writer to the source only. We have used such information while \ncreating the non primary columns. Thanks to pass1, we already have the names of the \nprimary key columns we want to refer with the foreign key. As we also have gathered \nthe path between the source and target classes thanks to the intermediate structure \ndescribed more in detail two sections below. With that information, the task is then \nstraightforward. \nFramework \n \nTo help writing the rules of the transformation in the visitor passes, we use a small \nframework. Typically, it contains reusable code like queries, creations or complex \nalgorithms. \nIn our context, we can distinguish two main kinds of frameworks: metamodel \noriented frameworks and transformation oriented frameworks. \nOn Executable Meta-Languages applied to Model Transformations      21 \nThe metamodel oriented frameworks are dedicated to only one metamodel, such as \nUML, or our case study class metamodel or RDBMS metamodel. Each time we use a \nnew metamodel, we may need to develop such framework. Even for simple \nmetamodels, we may need to repeat some complex requests.  For example in the class \nmetamodel, asking for the persistence of a class seems obvious, but as explained in \nthe Frequently Asked Questions of the workshop site, this is in fact recursive. Asking \nfor the persistency implies to navigate the parent link up to the topmost parent to be \nable to answer. In this way, some of the complexity of a simple metamodel may be \nhidden in the algorithm of an apparently simple request. Another extreme sample is \nthe node and edge metamodel; it is very powerful, but will require much more helper \nmethods to make it useable for simple queries than a dedicated metamodel. The \nvariety of helper methods of such framework is quite vast and depends on the use of \nthis metamodel. \nThe transformation oriented frameworks are related to a given transformation. \nSometimes, they may be considered as part of the transformation itself. However, as \nmore and more transformations are developed, the method which has initially been \ndesigned for a given transformation would be useful in another one. For example, one \ncan think to have two variants of the 'class to RDBMS' transformations: one that take \nonly a class model as source, one that takes a class model and another configuration \nmodel. Both transformations are relevant, and they can share code through this sort of \nframework.  \n \nThe frameworks are useful to capitalize on know how and complex algorithms. \nTypically, some of the recursive queries implied by the case study fit in one of those \nframeworks. \n \nWe present below, two methods to create attributes, excerpted of our \nClass2RDBMS framework. \n \n// add the created columns to the table \n// use the given prefix for column name \ncreateColumnsForNonPersistentClass( \n    theClass: source_model::Class; \n    theTable : target_model::Table; \n    namePrefix : Standard::String) \n{ \n   newPrefix  : Standard::String; \n   \n   foreach ( anAttribute : source_model::Attribute)  \n in (theClass.attrs) \n   { \n      newPrefix := namePrefix; \n      createColumnFromAttribute(anAttribute, theTable, newPrefix); \n   }  \n \n   foreach ( anAssoc : source_model::Association)  \n in (classHelper.getDestAssoc(theClass))  \n   { \n      if not classHelper.isClassPersistent( \n       anAssoc.dest.oclAsType(!source_model::Class!)) \n      {    \n         newPrefix := namePrefix.concat( \n        anAssoc.name.oclAsType(!Standard::String!)); \n         createColumnsForNonPersistentClass( \n     anAssoc.dest.oclAsType(!source_model::Class!), \n22      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n     theTable, \n     newPrefix); \n      } \n   }   \n} \n \ncreateColumnFromAttribute(theAttribute: source_model::Attribute; \n    theTable : target_model::Table; \n    namePrefix : Standard::String) : \ntarget_model::Column \n{ \n   theColumn  : target_model::Column; \n   name     : Standard::String; \n   \n   name := namePrefix.concat( \n        \n theAttribute.name.oclAsType(!Standard::String!));  \n   if \n(theAttribute.type.oclIsKindOf(!source_model::PrimitiveDataType!)) \n   { \n      theColumn := new target_model::Column(); \n      theColumn.name := name; \n      theColumn.type := theAttribute.type.name; \n    \n      associate ( cols := theColumn : target_model::Column, \n       owner := theTable : target_model::Table ); \n      if theAttribute.is_primary \n      { // we also need to associate it as a pkey \n         associate ( pkey := theColumn : target_model::Column, \n          pkeyreferers:= theTable : \ntarget_model::Table ); \n      } \n   } \n   return theColumn; \n} \nTrace metamodel and internal transient data structures \n \nIn order to ease the transformations in the second pass we also use a separate \nstructure, a small trace model. For all the main elements in the source model, this \ntrace model stores the target element created during the first pass. Then during the \nfollowing passes, a query on the traces retrieves the elements, the source or the target \ndepending on the need. As the traces allow retrieving the context of the previous pass, \nwriting the rules of the following passes is easier. \nIn addition to the internal usage, these traces, exposed as a model, can also be \nsaved for use by a following transformation or a reverse transformation. \n \nSometimes, some rules imply to construct intermediate data. Typically, a query \nwill ask for all the elements that match given criteria. The result will be a set of those \nelements which can be processed later. As the set is a structure defined by the MOF, \nthis is natural to use it for that purpose. However, in some case we may need more \nsophisticated structures. \n \nFor example, in the second pass of the 'class to RDBMS' sample, we want to create \nthe foreign key and the columns in the source classes pointing to a persistent target \nclass. To achieve that we need to retrieve all the persistent classes associated as a \nOn Executable Meta-Languages applied to Model Transformations      23 \nsource to the given class. A recursive method will easily create such a list, even if \nthere are several non persistent classes between persistent source classes and \npersistent target classes in the association graph. If we follow this simple approach, \nwe still lack some information in order to create the columns. We need their names, \nand the names depend of the association path between the persistent source classes \nand their persistent targets.  The simple set of Class is not enough here; we need to \nadd some more information along to the Class. A new internal structure will tackle \nthat, it defines a new MTL class that stores a persistent class and the path that lead to \nthat class. Then from this list, we have enough information to create the foreign key \nand the columns in the source classes. \n5.3 Mapping classes to tables in Kermeta \nThis section details step by step the implementation of the mandatory model \ntransformation for the workshop in Kermeta. \nThe metamodels \n \nname: EString\nClassifier\nname: EString\nAssociation\nis_primary: EBoolean\nname: EString\nAttribute\nis_persistent: EBoolean\nClass\nPrimitiveDataType\nClassModel\ntype\n1\nclassifier\n*\ndest1 src1\nassociation\n*\nparent\n0..1 name: EString\nTable\nFKey\nname: EString\ntype: EString\nColumn\nRDBMSModel\npkey\n1..*\ncols\n1..*\nfkeys\n*\ntable1..*\ncols1..*\nreferences1\nInput metamodel Output metamodel  \nFigure 8:  Input and output metamodels expressed in Kermeta visual syntax \nWithin the Kermeta environment, the first step for implementing a model \ntransformation is to provide the input and output metamodels. As Kermeta relies on \nthe Eclipse Modeling Framework (EMF) for model storage, regular EMF metamodels \ncans be used: ECore files. These metamodels can be created and edited using the \ngeneric model editor provided with the EMF. The Omondo UML tool20 provides a \ngraphical editor for ECore metamodels. Figure 1 displays the Class metamodel and \nthe Database metamodel as it has been defined using Omondo UML. \n \nThere are two different ways of using an ECore metamodel in a Kermeta program. \n \n24      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n· This first is to import directly the ECore metamodel in the Kermeta program. \nThis is the simplest manner as it provides the ability to manipulate in Kermeta \ninstances of the classes of the metamodel. \n· The second possibility is to generate from the ECore file the metamodel in \nKermeta. This is especially useful to add behaviors to the metamodel, which is \none of the key features of Kermeta. \n \nFor the implementation of the Class2RDBMS transformation we have chosen, in \norder to present the two approaches, to use the input metamodel directly and to \ngenerate the Kermeta metamodel for the RDBMS metamodel. Figure 9 presents the \nKermeta code generated from the RDBMS metamodel. \n \nFigure 9: RDBMS metamodels expressed in Kermeta text. \nDesign of the transformation \n \nOnce the metamodels for the inputs and outputs of the transformation are provided, \nthe next step is, as for any software development, to design the transformation. The \ndesign stage is more important here, as we use a general-purpose language, than if we \nwere using a language dedicated to model transformation.  \n \nIn effect, a formalism dedicated to model transformation would provide specific \nways of writing transformation where as with Kermeta the transformation is simply \nan object-oriented program that manipulates model elements.  \npackage RDBMSMM; \n \nrequire\n kermeta \nusing kermeta::standard \n \nclass Table \n{ \n attribute name : String \n attribute cols : Column[1..*] \n reference pkey : Column[1..*] \n attribute fkeys : FKey[0..*] \n} \nclass FKey \n{ \n reference references : Table \n reference cols : Column[1..*] \n} \nclass Column \n{ \n attribute name : String \n attribute type : String \n} \nclass RDBMSModel \n{ \n attribute table : Table[1..*] \n} \nOn Executable Meta-Languages applied to Model Transformations      25 \nThe proposed transformation generates tables from classes marked persistent. For \nattributes and associations in these classes it generates columns and foreign keys in \nthe tables. The transformation can be implemented in tree steps: \n \n· Create tables. Tables are created from each class marked persistent in the input \nmodel. \n· Create columns. For each persistent class process all attributes and outgoing \nassociations to create corresponding columns. The foreign keys are created but \nthe cols property cannot be filled and the corresponding columns cannot be \ncreated because primary keys of references table cannot be known before it \nhas been processed. \n· Update foreign-keys. The foreign-key columns are created in the table that \ncontains the foreign-key and the property cols of foreign-keys is updated. \n \nBetween step 1 and 2 a trace information should be kept between persistent classes \nand created tables. Keep mappings from source objects and target objects is a general \nmodel transformation need. In Kermeta this can be done using several techniques. \nThe first is to use an ad-hoc data structure such as a Map to store the correspondence. \nThis would be the simplest solution but as traceability is a common feature to model \ntransformations, it might be interesting to design a reusable solution to handle \nmanagement of trace information. Kermeta provide for such purposes facilities such \nas generic classes and operations in order to make the reuse of generic frameworks \nsafe and easy.  \nFigure 10 presents the implementation of a very simple reusable trace utility. It can \nbe used to represent a one to one mapping between two types of objects. In the \nimplementation of the Class2RDBMS transformation we will use it to store the \nmapping between persistent classes and generated tables. The Trace class is defined a \na generic class with two type parameters SRC and DST that should be bound with the \ntype of the source and target objects.  The implementation of the class is very simple \nand consists of using a Hashtable (available from the Kermeta standard library) to \nstore the mapping between objects. \nThis simple traceability capability is enough for the implementation of the \nclass2RDBMS case study but in practice the traceability framework should be \nenriched to adapt to most model transformation issues. We have already identified \nseveral needs for such a framework such as the ability to store bi-directional \nmappings, on to many or many to many mappings. In addition to the problem of \nstoring object mappings, traces for transformations from model to text or text to \nmodel should also be taken into account. \n \n26      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \nFigure 10: Very simple traceability framework. \n \nAnother design issues when writing a model transformation in Kermeta is how the \ncode of the transformation is encapsulated. One of the important feature of Kermeta is \nto allow adding code directly in metamodels. This is especially interesting to allow \nsharing queries and common behaviors between several transformations that operates \non the same metamodel. However, non-reusable transformation specific features \nshould not be added to the metamodel. To do so, transformation specific classes can \nbe defined directly in Kermeta to contain the implementation of the transformation. \nTraditional OO design techniques should be used to design these classes. \nAs the Class2RDBMS example is pretty simple, we have chosen to implement it in \na Class2RDBMS class and to include a helper method in the RDBMS metamodel to \nhandle the proper creation of foreign-keys (step 3 of the algorithm). As a result, the   \nClass2RDBMS contains a few query methods on class model that could have been \nintegrated in the Class metamodel to be reused by other transformations. The next \nsection details the implementation of the transformation. \nImplementation of the transformation \nThe transformation has been implemented in a class named Class2RDBMS. This \nclass provides a method transform that takes the input model as a parameter and \npackage trace; \n \nrequire kermeta \nusing kermeta::utils \n \n/** \n * This class represents a simple one to one \n * unidirectional mapping \n */ \nclass Trace<SRC, TGT> \n{ \n /** Mapping between source and target objects */   \n reference src2tgt : Hashtable<SRC, TGT> \n  \n operation create() is do \n  src2tgt := Hashtable<SRC, TGT>.new \n end \n  \n /** get a target element */ \n operation getTargetElem(src : SRC) : TGT is do \n  result := src2tgt.getValue(src) \n end \n  \n /** Store a trace */ \n  operation storeTrace(src : SRC, tgt : TGT) is do \n   src2tgt.put(src, tgt) \n  end \n} \nOn Executable Meta-Languages applied to Model Transformations      27 \nreturns the corresponding output model. Figure 4 presents an excerpt of the Kermeta \ncode of the transformation. \n \n \nFigure 11: The three steps of the transformation \nThe three steps of the transformation clearly appear in the body of operation \ntransform. First, classes are created for each persistent class, second columns are \ncreated in the tables and finaly the foreign keys are updated. The mapping between \nclasses and tables is represented by the reference class2table in class Class2RDBMS. \nThe fkeys reference is used to store all created foreign keys during step 2 in order to \nbe able to update them at step 3. \n \npackage Class2RDBMS; \n \nrequire kermeta // The kermerta standard library \nrequire \"trace.kmt\" // The trace framework \nrequire \"../metamodels/ClassMM.ecore\"  // Input metamodel in ecore \nrequire \"../metamodels/RDBMSMM.kmt\"    // Output metamodel in kermeta \n \n[...] \n \nclass Class2RDBMS  \n{ \n   /** The trace of the transformation */ \n   reference class2table : Trace<Class, Table> \n   /** Set of keys of the output model */ \n   reference fkeys : Collection<FKey> \n     \n   operation transform(inputModel : ClassModel) : RDBMSModel is do \n     // Initialize the trace \n     class2table := Trace<Class, Table>.new \n     class2table.create \n     fkeys := Set<FKey>.new \n     result := RDBMSModel.new \n     // Create tables \n     getAllClasses(inputModel).select{ c | c.is_persistent }.each{ c |  \n       var table : Table init Table.new \n       table.name := c.name \n       class2table.storeTrace(c, table) \n       result.table.add(table) \n     } \n     // Create columns \n     getAllClasses(inputModel).select{ c | c.is_persistent }.each{ c |  \n       createColumns(class2table.getTargetElem(c), c, \"\") \n     } \n     // Create foreign keys \n     fkeys.each{ k | k.createFKeyColumns } \n     \n   end \n \n  [...] \n} \n28      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n  \nFigure 12: Implementation of step 2, columns creation. \n \nFigure 12 presents the implementation of method createColumns and \ncreatecolumnsForAttribute. The createColumns operation creates the columns in a \ntable by adding columns for all attributes of the class and all outgoing association \nfrom the class.  The operations getAllAttribute(Class) and \ngetAllAssociation(Class) are defined to get all the attributes and outgoing \nassociation of a class and all its subclasses.  \n \nThe operation createcolumnsForAttribute handles the creation of columns \ncorresponding to an attribute. Three cases have to be considered: \n \n· If the type of the attribute is simple a single column is created. \n· If type of the attribute is persistent, a foreign key is created and the columns in the \ntable will be created at step 3 when all table have been processed. \noperation createColumns(table : Table, cls : Class, prefix : String) is \ndo \n  // add all attributes \n  getAllAttributes(cls).each{ att |  \n    createColumnsForAttribute(table, att, prefix) \n  } \n  // add all associations \n  getAllAssociation(cls).each{ asso |  \n    createColumnsForAssociation(table, asso, prefix) \n  } \nend \n   \noperation createColumnsForAttribute(table : Table, att : Attribute, prefix : String) is \ndo \n  // The type is primitive : create a simple column \n  if PrimitiveDataType.isInstance(att.type) then  \n    var c : Column init Column.new \n    c.name := prefix + att.name \n    c.type := att.type.name \n    table.cols.add(c) \n    if att.is_primary then table.pkey.add(c) end \n  else \n    var type : Class  type ?= att.type \n    // The type is persitant \n    if isPersistentClass(type) then \n      // Create a FKey \n      var fk : FKey init FKey.new \n      fk.prefix := prefix + att.name \n      table.fkeys.add(fk) \n      fk.references:=class2table.getTargetElem(getPersistentClass(type)) \n      fkeys.add(fk) \n    else \n     // Recusively add all attrs and asso of the non persistent table     \n     createColumns(table, type, prefix + att.name) \n    end         \n  end \nend \nOn Executable Meta-Languages applied to Model Transformations      29 \n· If type of the attribute is non-persistent then columns corresponding to attribute in \nthe non-persistent type are added in the table. This is done by a recursive call to \nmethod createColumns. \nThe operation createcolumnsForAssociation handles the creation of columns \ncorresponding to an association. This operation is not detailed on the figure as it is \nvery similar to createcolumnsForAttribute except that the destination type of \nassociation cannot be a simple type. \n \nFigure 13: Implementation of step 3, updating foreign keys. \nFigure 13 presents the implementation of step 3. The code has been directly added \nto the RDBMS metamodel in the class FKey. An attribute prefix has been added to the \nclass to store the name prefix of the columns to create. When a Kermeta metamodel is \ngenerated from an ECore metamodel, any property or operation can be added. The \nadded properties can be considered as “ non-persistent”  because as they are not in the \nECore metamodel the will not be saved when a model is serialized using EMF. \nTesting / using the transformation \n \nThis section briefly presents how the transformation can be practically used within \nthe Kermeta environment. As Kermeta if fully compatible with the EMF, models can \nbe created, modified and visualized using EMF generic tools. Figure 14 is a screen-\nshot of an input model for the transformation. Figure 15 displays the Kermeta \nworkbench which has been developed as an eclipse plug-in. finally Figure 16 displays \nthe output model obtained by running the transformation. \nclass FKey \n{ \n  reference references : Table \n  reference cols : Column[1..*] \n   \n  /** \n   * prefix for the name of the columns \n   * used by the createFKeyColumns method \n   */ \n  attribute prefix : String \n   \n  /** \n   * Create the FKey columns in the table  \n   */ \n  operation createFKeyColumns() is do \n    var src_table : Table \n    src_table ?= container \n    // add columns \n    references.pkey.each{ k |   \n      var c : Column init Column.new \n      c.name := prefix + k.name \n      c.type := k.type \n      self.cols.add(c) \n      src_table.cols.add(c) \n    } \n  end  \n} \n30      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \nFigure 14: An input model. \n \n \nFigure 15: Execution of the transformation. \nOn Executable Meta-Languages applied to Model Transformations      31 \n \nFigure 16: Generated output model. \n5.4 Conversion of Roman to/from Arabic numbers in Kermeta \nThis section presents the implementation of the optional model transformation \nfrom Arabic to Roman number and vice-versa. The transformation has been \nimplemented in Kermeta in both directions. The following presents the metamodel \nthat has been used to represent Arabic and Roman numbers, and then details the \nimplementation of the transformation itself.  \nThe metamodels \n \n \nFigure 18: Visual representation of the metamodels \nAn Arabic number simply consists of a collection of digits and a Roman number in \na collection of letters. \n \nFigure 17 Meta-models ArabicNumber Digit\nRomanNumber Letter\ncontent\n*\ncontent\n*\n32      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nFigure 19: Executable metamodel of arabic numbers in Kermeta. \nFigure 20: Executable metamodel of roman numbers in Kermeta. \nclass ArabicNumber \n{ \n  reference content : Digit[0..*] \n  operation toString() : String is do \n    result := “ ”  \n    content.each{digit  |  \n      result := result + digit.~value.toString() \n    } \n  end \n   \n  operation getValue() : Integer is do \n    result := 0 \n    content.each{n  | result := result*10 + n.~value} \n  end \n   \n  // precondition newValue < 10000 \n  operation setValue(newValue : Integer) is do \n    [...] \n  end \n} \n \nclass Digit  \n{ \n  attribute ~value : Integer \n} \nclass RomanNumber \n{ \n  reference content : Letter[0..*] \n  operation toString() : String is do \n      result := String.new() \n    content.each{letter  | result := result + letter.~value} \n  end \n  operation getValue() : Integer is do \n    [...] \n  end \n} \n \nclass Letter \n{ \n  attribute ~value : String \n  operation getValue() : Integer is do \n    if value == \"I\" then result := 1  \n    else if ~value == \"V\" then result := 5 \n    else if ~value == \"X\" then result := 10  \n    else if ~value == \"L\" then result := 50 \n    else if ~value == \"C\" then result := 100 \n    else if ~value == \"D\" then result := 500 \n    else if ~value == \"M\" then result := 1000 end \n    end end end end end end     \n  end \n} \nOn Executable Meta-Languages applied to Model Transformations      33 \nThe transformation \nFigure 21 presents the implementation of the transformation in Kermeta. The \nmethod roman2arab is very straightforward as the roman number metamodel contains \nalready a method getValue which computes the integer value of a roman number. The \nmethod arab2roman is designed to transform arabic numbers lower than 3999. \nFigure 21: Implementation of the transformation in Kermeta. \nclass Main { \n  // convert a roman number to an arabic one \n  operation roman2arab(r : RomanNumber) : ArabicNumber is do \n      result := ArabicNumber.new() \n    result.setValue(r.getValue()) \n  end \n  // convert an arab number to a roman one \n  // precondition : a < 3999 \n  operation arab2roman(a : ArabicNumber) : RomanNumber is do \n       result := RomanNumber.new() \n       var position : Integer init a.content.size \n       // assertion: position <= 4 \n       if position == 4 then   \n       addDigit2roman(result,a.content.elementAt(0), \"M\",\" overflow\",\" overflow\") \n       position := position - 1 \n     end \n       if position == 3 then   \n       addDigit2roman(result,a.content.elementAt(a.content.size-3), \"C\",\"D\",\"M\") \n       position := position - 1 \n     end \n       if position == 2 then   \n       addDigit2roman(result,a.content.elementAt(a.content.size-2), \"X\",\"L\",\"C\") \n       position := position - 1 \n     end \n       if position == 1 then   \n       addDigit2roman(result,a.content.elementAt(a.content.size-1), \"I\",\"V\",\"X\") \n     end \n  end \n  // convert a single digit to roman style, depending on its position \n  operation addDigit2roman(r: RomanNumber, d : Digit, unit : String, five : String, ten : String) is do \n    if d.~value < 4 then addLetters(r,d.~value, unit) \n    else if d.~value == 4 then addLetters(r,1,unit)  \n      addLetters(r,1,five)  \n    else if d.~value < 9 then do \n      addLetters(r,1,five) \n      addLetters(r,d.~value-5, unit) \n      end \n    else if d.~value == 9 then do addLetters(r,1,unit)  \n      addLetters(r,1,ten) end \n    end end end end \n  end  \n  // add letter 'l' 'times' times \n  operation addLetters(r: RomanNumber, times : Integer, l : String) is  do \n    var aLetter : Letter init Letter.new() \n    aLetter.~value := l \n    from var i : Integer init 0 until i >= times \n    loop \n      r.content.add(aLetter) \n      i := i + 1 \n    end     \n  end \n} \n34      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n5.5 Refactorings in Kermeta \nThis section shows how we can use well-known OO design techniques such as \ndesign patterns to develop model transformations. In contrast with more generative \ntransformations (such as the class to RDBMS example) which map a whole model to \nanother, model refactorings21 are typically used as model edition primitives. A given \nrefactoring can be used multiple times, in different contexts, and each application \ntakes the development process a small step forward. The transformation tool should \nbe as interactive as possible to ease this process by allowing the developer to \nexperiment and progress through trial and error. \nWe don't put the emphasis on the refactoring presented here itself, which is really \nsimple (moving a given method up to a superclass) but on the application of the \nCommand design pattern to specify refactorings. \nRefactorings as Commands \n \nFirstly, a refactoring is a generic transformation which has to be parameterized; in \nour case, we have to specify which method we want to move, and to which superclass \nwe want to move it. Then the tool needs to check the refactoring preconditions; if they \nare respected it will proceed to transform the model. The interface for refactorings \nthus defines three methods as follows: \n \nabstract class RefactoringCommand \n{ \n    operation check() : Boolean is abstract \n    operation transform() : Void is abstract \n    operation revert() : Void is abstract \n} \n \nThis interface specifies three operations playing the Execute() role in the GoF \npattern description: \n \n· check() is called to evaluate preconditions on the model before transformation; \nwhen these preconditions are satisfied the transformation is guaranteed to be a \nrefactoring so it can be applied safely. \n· transform() applies the transformation. \n· revert() should return the refactored model to it's previous state. \n \nConcrete refactorings must subclass RefactoringCommand and provide \nmethods for its three operations: \n \nOn Executable Meta-Languages applied to Model Transformations      35 \nclass MoveUpMethod inherits RefactoringCommand \n{ \n   reference methodToMove : ClassHierarchyMM::Method \n   reference destinationClass : ClassHierarchyMM::Class \n   reference originClass : ClassHierarchyMM::Class \n \n   method check() : Boolean is do \n       \n      // assert destinationClass is a superclass of methodToMove's owner \n      if not destinationClass.isSuperclass \n                                   (methodToMove.owner.asClass) then \n         raise Exception.new \n      end \n \n      // assert new methodToMove won't conflict \n      if not conflicts(methodToMove, destinationClass).empty then \n         raise Exception.new \n      end \n   end \n \n \n    /** Apply the transformation : Move method to destination class */ \n    method transform() : Void boolean \n       // could return a \"successfully applied\" \n    is do \n       // memorize current owner for revert() \n       originClass := methodToMove.owner.asClass \n       // move method to destination \n       methodToMove.owner := destinationClass \n    end \n \n \n    /** undo the transformation : Move method back to original owner */ \n    method revert() : Void \n    is do \n        methodToMove.owner := originClass \n    end \n \n \n    /** list conflicts that would appear if the transformation is \n     *  applied */ \n    operation conflicts(m : ClassHierarchyMM::Method, \n                        someClass : ClassHierarchyMM::Class) : \n                                  Collection<ClassHierarchyMM::Method> \n    is do \n        result := Set<ClassHierarchyMM::Method>.new \n        result := someClass.subclasses.collect{ c | \n            c.features }.select{ f | (f.name == m.name) and (f != m) } \n    end \n} \n \nThe metamodel \n \nFor this example we will use the small subset of the UML metamodel shown \nbelow, which defines classes, inheritance hierarchy and methods. This Kermeta \nmetamodel also defines utility methods in metaclasses: \n \npackage ClassHierarchyMM; \n \nrequire kermeta \n \nusing kermeta::standard \n \n36      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n \nabstract class Classifier inherits GeneralizableElement \n{ \n    attribute feature : seq Feature[0..*]#owner \n    operation asClass() : Class is do \n        result ?= self \n    end \n} \n \nclass Class inherits Classifier \n{ \n    operation superclasses() : Collection<Class> is do \n        result := generalization.collect{ g | \n            var p : Class \n            p ?= g.parent \n        } \n    end \n \n    operation isSuperclass(child : Class) : Boolean is do \n        result := child.superclasses().contains(self) \n    end \n \n    operation subclasses() : Collection<Class> is do \n        result := specalization.collect{ g | \n            var p : Class \n            p ?= g.child \n        } \n    end \n \n    operation isSubclass(child : Class) : Boolean is do \n        result := child.subclasses().contains(self) \n    end \n} \n \nclass Feature inherits ModelElement \n{ \n    reference owner : Classifier[1..1]#feature \n    attribute visibility : String \n} \n \nabstract class GeneralizableElement inherits ModelElement \n{ \n    reference specialization : Generalization[0..*]#parent \n    reference generalization : Generalization[0..*]#child \n} \n \nclass Generalization inherits ModelElement \n{ \n    reference parent : GeneralizableElement[1..1]#specialization \n    reference child : GeneralizableElement[1..1]#generalization \n} \n \nclass Method inherits Feature \n{ \n    attribute body : String \n} \n \nclass Model inherits ModelElement \n{ \n    attribute ownedElement : ModelElement[0..*]#namespace \n} \n \nabstract class ModelElement \n{ \n    reference namespace : Model#ownedElement \n    attribute name : String \n} \nOn Executable Meta-Languages applied to Model Transformations      37 \nUsing the Transformation \n \n@mainClass \"Refactoring::Main\" \n@mainOperation \"main\" \n \npackage Refactoring; \n \nrequire kermeta \nrequire \"../models/ClassHierarchyMM.kmt\" \nusing kermeta::standard \nusing kermeta::utils \nusing kermeta::persistence \nusing kermeta::exceptions \n \n// definition of RefactoringCommand \n// definition of MoveUpMethod \n \nclass Main \n{ \n   reference resource : Resource \n   reference inputModel : ClassHierarchyMM::Model \n \n   operation main() : Void \n   is do \n      loadResource(\"../models/SampleModel.xmi\") \n      inputModel ?= findElement(ClassHierarchyMM::Model, \"root\") \n \n      var transfo : MoveUpMethod init MoveUpMethod.new \n      transfo.methodToMove ?= findElement(ClassHierarchyMM::Method, \"m\") \n      transfo.destinationClass ?= findElement(ClassHierarchyMM::Class, \n       \"AncestorClass\") \n      if transfo.check() then \n         transfo.transform() \n         stdio.println(\"transformation applied\") \n      else \n         stdio.println(\"precondition not satisfied\") \n      end \n      resource.saveWithNewURI(\"../models/SampleModel-out.xmi\") \n    end \n \n    operation loadResource(filename : String) \n    is do \n      var repository : EMFRepository init EMFRepository.new \n      resource := repository.getResource(filename) \n      resource.load() \n    end \n     \n   operation findElement(metaclass : kermeta::reflection::Class, \n                         name : String) : \n                               ClassHierarchyMM::ModelElement \n   is do \n      var found : Boolean init false \n      from var it : Iterator<Object> init resource.instances.iterator \n      until found or it.isOff \n      loop \n         var next : Object init it.next \n         if (metaclass.isInstance(next)) then \n            var n : ClassHierarchyMM::ModelElement \n            n ?= next \n            if n.name == name then \n               result ?= next \n               found := true \n            end \n         end \n      end \n   end \n}\n \n38      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n5.6 Determinization and minimization of automata in Kermeta \nThese transformations show the power of OCL-like constructs to manipulate \ncollections. \nFormal definition of non-determinist finite automaton metamodel \n \nFormally, a non-determinist finite automaton is a A = ( \u0001, Q, T, q0, F), where : \n· \u0001 is an alphabet   \n· Q is a finite set of states \n· T is a set of transitions rules, such as si X a --> sj where si, sj \u0002 Q² and a \u0002 \n\u0001È{e} \n· q0 is the initial state \n· F is the set of final states \nAutomaton metamodel \n \nWe considered as simple case of finite automaton: an automaton that as an initial \nstate, (initialState),  a set of available states (stateSet), a set of transitions \n(transitionSet), an alphabet, an a set of final states (finalStateSet). We chose that our \nautomatons are all e-free (no e-transitions). \n \n \n \nFigure 22: Automaton metamodel. \n \ncombination is an attribute of State that is used for two purposes :  \nOn Executable Meta-Languages applied to Model Transformations      39 \n· For the determinisation implementation : it represents each new group of state \nthat is created for the determinist automaton \n· For the minimisation implementation : it is used as a marker for states of the \ninput automaton that have already been added in the equivalence classes of the \noutput-minimal automaton. This is a light optimisation of the computation of \nthe equivalence classes that constitute the new states of the minimalized \nautomaton. \n \nalphabet is, in Kermeta implementation, a derived property that is computed from \nthe automaton instance (we get all the letters defined on the transitions) \nKermeta representation  \n \nThe following figure shows the Kermeta textual representation of the automaton \nmetamodel. \nclass FiniteAutomaton \n{ \n   reference stateSet : set State[0..*]//Set<State> //#owningFA \n   reference initialState : State  \n   reference finalStateSet : set State[0..*] \n   reference transitionSet : set Transition[0..*] \n   property readonly alphabet : Set<String> \n   getter is do \n      result := self.seqToSet(self.transitionSet.collect{e|e.letter}) \n   end \n  \n   /** Initialize a new automaton from an existing one */ \n   operation initialize(initState : State) is do \n      stateSet.add(initState) \n      initialState := initState \n      initialState.combination := Set<State>.new \n   end \n} \n \nclass State \n{ \n   reference combination : Set<State> \n   reference name : String \n} \n \nclass Transition \n{ \n   reference source : State \n   reference target : State \n   reference letter : String \n} \nFormal definitions of the determinization algorithm \nDeterminist automaton \nA finite automaton is determinist if and only if the relation t is a transition function \nsuch as:  \nt : Q X \u0001 --> Q  (e-transition no more allowed, but in our case we don't work with \nit) \nfrom a state, there is at most one possible transition with the same letter \n40      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nAlgorithm \n \nThe algorithm for determinizing a non-determinist finite automaton is a classical \nproblem for the automata such as defined in our metamodel. An introduction of it can \nbe found in22. Here it is: \n \nInitialisation of A' = (\n\u0001, Q', T', q0', F'), determinist version of an automaton A : \n \n· T' initialized to Æ \n· q0' initialized to { q0 } \n· Q' initialized to { q0' } \n \nq' is a “ new”  state that is a part of Q ( q' Î  P(Q)  ) \n \nfor each state q' of Q' not considered yet do  \n   for each letter a of \n\u0001 do \n     q'' ¬ { y / \u0003 x Î q' and y Î Q / (x, a, y) Î T } \n     T'  ¬  T  È { (q', a, q'') } \n Q' ¬ Q' È {q''} \n   rof \nrof \n \nF' ¬ { q'Î  Q' / q'Ç F ¹ Æ} \nOn Executable Meta-Languages applied to Model Transformations      41 \nImplementation  \n \nclass Determinization \n{ \n   reference processed_states : Set<State> \n \n   operation main() : Void is do  \n     \n      // Input automaton (non-determinist) \n      var input : FiniteAutomaton init Sampler.new.createSample1() \n      var output : FiniteAutomaton init FiniteAutomaton.new \n      // Control variables \n      processed_states := Set<State>.new \n      // Initialize output automaton with input.initialState \n      output.initialize(input.initialState)  \n      // Apply the determinisation \n      determinize(input, output, output.initialState)  \n \n      // Define the final states : q' intersection initial  \n      // Final states is void \n      output.finalStateSet.addAll \n      (  \n        output.seqToSet( output.stateSet.select {  \n          e | e.combination.detect{ a |  \n            input.finalStateSet.contains(a) } != void  } ) \n      )       \n   end \n     \n    \n// THE DETERMINISATION ALGORITHM  \n     //input : initial automaton \n     // output : final determinized automaton \n     // output_state : the next state to consider \n   operation determinize( input : FiniteAutomaton,  \n                          output : FiniteAutomaton,  \n                          output_state : State)  \n     is do \n       // for each state not considered yet \n     if not processed_states.contains(output_state) then \n        processed_states.add(output_state) \n        var newq : State init State.new \n        // For each letter of the alphabet \n        from var lit : Iterator<String> init input.alphabet.iterator \n        until lit.isOff \n        loop \n          // There exists a state x of q'  \n          //(where q' is a P(Q)) and a state y from Q  \n          // such that: x --l--> y belongs to input.transitionSet \n          var nextl : String init lit.next \n          newq.combination := Set<State>.new \n          newq.combination.addAll( \n            input.seqToSet( \n               input.transitionSet. \n                 select { e | e.letter.equals(nextl) }. \n                   select { a | output_state.equals(a.source)  \n                     or output_state.combination.contains(a.source)}. \n                       collect { b | b.target }) \n            ) \n          newq.name := join(newq.combination.collect{ a | a.name })  \n          // Add the state to the output automaton if we found one \n          if (newq.combination.size > 0) then \n             // Add the new transition \n             var newt : Transition init Transition.new \n             newt.initialize(output_state, newq, nextl)  \n             output.transitionSet.add(newt) \n42      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n             // Add the new state if it is not already added \n             if (output.stateSet. \n                         detect { e | newq.name == e.name } == void)  \n             then \n                   output.stateSet.add(newq) \n             end \n               self.determinize(input, output, newq) \n            end \n         end // End of loop \n       end // End of processing of not considered state \n \n    end \n \n    // Create a special name for new states with their combination : \n      //  the state -> { q0, q1 } is name “q0q1” \n    operation join( str_seq : Collection<String>) : String is do \n         result := \"\" \n         from var it : Iterator<String> init str_seq.iterator \n         until it.isOff \n         loop \n             result.append(it.next) \n         end \n    end \n     \n} \nFormal definition of the minimization algorithm \n \nA minimal automaton is an optimized (pre-determinized) automaton that has the \nminimum number of states that performs the same function (i.e. produces the same \nlanguage in a language automaton) of its equivalent automaton. The reader can find a \nformal definition of minimal automaton in23. \nWe chose to implement a simple algorithm provided by23. It is called a layerwise \ncomputation of the equivalence relations. A better implementation should be \nprovided, but would need a few optimizations for the list handling in Kermeta. \nHowever, the language was quite ergonomic, thanks to the implementation of OCL \nconstraints, and made the implementation easier to write. \nThe algorithm \nThe algorithm finds, incrementally, the pair of states (p, q) such as p and q ra \nAFD M = (Q, A, q0, F, d)  \nH : ( Q -F )² U Q²  \nHold : Q*Q \nBegin \n   do \n      Hold := H \n      for each (p, q) in Q*Q do \n         for each letter a in A do \n             s = d(p,a)  \n             t = d(q,a) \n             if (s,t) is not in H then remove (p,q) from H  \n   until Hold == H \nend \nOn Executable Meta-Languages applied to Model Transformations      43 \n \nImplementation \n \nThe implementation of the minimization was a bit more complicated, since we had to \nconstruct also, from the pairs of states given by the algorithm execution, the new \nstates ( which are the equivalence classes of the pairs of equivalent states (p,q in the \nalgorithm), and the new transitions. We show here only the relevant parts of the \nimplementation of minimization algorithm in Kermeta. \n \nclass Minimization \n{ \n  reference equivalent_pairs : set Pair[0..*] \n  reference all_input_pairs : Set<Pair> \n  reference helper : AutomatonHelper \n \n  operation main() : Void is do  \n     \n       helper := AutomatonHelper.new \n       // Input automaton (non-determinist) \n       var input : FiniteAutomaton init Sampler.new.createSampleM1() \n       var output : FiniteAutomaton init FiniteAutomaton.new \n       all_input_pairs := Set<Pair>.new \n \n       // Initialize the complete set of  \n       // possible pairs: all_input_pairs = Q x Q (Q is the stateSet) \n       // Initialize Eo : equivalent_pairs  \n       // = { F \\ Q }Â² ^ FÂ²  (states that accept  \n       // the {e} transition or empty word \n       input.stateSet.each { p | input.stateSet.each { b |  \n       // Check : (p,q) is in Eo, i.e either both are final  \n       // states or both are NOT final states \n       var isFinalLeft : Boolean init input.finalStateSet. \n                                detect { e | p.name == e.name }!=void \n       var isFinalB    : Boolean init input.finalStateSet. \n                                detect { e | b.name == e.name }!=void \n       // Also fill the all input pairs \n       if find_one(all_input_pairs, p, b) == void  \n          then all_input_pairs.add(createPair(p, b)) end \n       if  ((isFinalLeft and isFinalB)  \n                  or (not isFinalLeft and not isFinalB))  \n           and \n             find_one(equivalent_pairs, p, b) == void \n       then  \n             equivalent_pairs.add(createPair(p, b)) \n       end    } }  \n \n       // Minimalize  \n       minimalize(input, output) \n       output.prettyprint() \n  end \n \n  operation minimalize(input : FiniteAutomaton,  \n                       output : FiniteAutomaton) :   Set<Pair> is do \n    result := equivalent_pairs \n    var old_equivalent_pairs : Set<Pair> init all_input_pairs \n    from var it : Iterator<Pair> init old_equivalent_pairs.iterator \n    until old_equivalent_pairs == result \n    loop \n        old_equivalent_pairs := result \n        // For each pair \n        old_equivalent_pairs.each { eqPair | \n        // For each letter of  \n44      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n        if (isNotOwnedTransition(input,  \n                                 eqPair,  \n                                 old_equivalent_pairs) == true)  \n        then \n           // remove this pair from eq. pairs (H) \n           result := old_equivalent_pairs \n           var fp : Pair  \n                     init find_one(result, eqPair.left, eqPair.right) \n           if (fp!=void) then \n               result.remove(fp)  \n           end \n        end \n     } \n \n    end \n    // Set the result \n    result := Set<Pair>.new  \n    result.addAll(old_equivalent_pairs)  \n    // Create the equivalent classes, which become the new states \n    var classSet : Set<Set<State>> init Set<Set<State>>.new \n    createEquivalenceClasses(output,  \n                             input.stateSet,  \n                             old_equivalent_pairs) \n \n    output.stateSet.each  \n   { s | s.name := helper.join(s.combination.collect{ a | a.name }) } \n \n    // Create the transition between the new states \n    // inputStates contains the links to their eq.class \n    createEquivalentTransitions(output.stateSet,  \n                                input.stateSet,  \n                                input.transitionSet) \n  end      \n                \n    // Equivalence relation  xRy == yRx : \n    operation find_one(pairSet : Set<Pair>,  \n                       left : State,  \n                       right : State) : Pair is do \n      result := pairSet.detect { p |  \n      (p.left.name == left.name and p.right.name == right.name) or \n      (p.right.name == left.name and p.left.name == right.name) } \n    end \n          \n          \n  // Returns true if for each letter of the input automaton,  \n  // a pair (p,q) does not satisfy the “T(p, a), T(q, a)  \n  // belongs_to the equivalent_pairs” condition \n  operation isNotOwnedTransition(automaton : FiniteAutomaton,  \n                                 pair : Pair,  \n                                 equivalent_pairs : Set<Pair>) : \n                                              Boolean  \n  is do  \n    // if there exists a letter a in the automaton such as \n    // T(pair.left, a), T(pair.right, a) belongs to distinct_pairs \n    // \"void\" pair is allowed! \n    result := false \n    from var it : Iterator<String> init automaton.alphabet.iterator \n    until it.isOff or result == true \n    loop \n       var letter : String init it.next \n       var tleft : Transition init automaton. \n         transitionSet.detect { t |  t.source.name==pair.left.name  \n             and t.letter == letter } \n       var tright : Transition init automaton. \n         transitionSet.detect { t | t.source.name==pair.right.name \n             and t.letter == letter }       \n       if (tleft!=void and tright!=void) then  \nOn Executable Meta-Languages applied to Model Transformations      45 \n          // empty word belongs to accepted words \n          if find_one(equivalent_pairs,  \n                      tleft.target,  \n                      tright.target) == void then \n              result := true \n          end \n       end \n    end \n  end \n     \n \n \n  // Create the equivalenceClasses that will constitutes  \n  // the states of the minimal output automaton. \n  operation createEquivalenceClasses(output : FiniteAutomaton, \n                                     stateSet : Set<State>, \n                                     equivalent_pairs : Set<Pair>) : \n                                               Set<Set<State>> is do \n    var eqClass : Set<State> init Set<State>.new \n    result := Set<Set<State>>.new \n    from var it : Iterator<State> init stateSet.iterator \n    until it.isOff \n    loop \n       var state : State init it.next \n       var news : State \n       equivalent_pairs.select \n         { pair | pair.left == state }.each \n       { pair | \n       // combination becomes a \"marker\" for classed states \n       // if it is void, it means that it does not  \n       // belong to a eqclass yet \n       if (state.combination == void) then \n            // create the eq. class and the state \n            eqClass := Set<State>.new \n            eqClass.add(pair.left) \n            news := helper.createState(state.name) \n            news.combination.add(eqClass.one)   \n            helper.join(eqClass.collect{ a | a.name }) \n            output.stateSet.add(news) \n            result.add(eqClass) \n            // Mark state that is already added  \n            // we use combination to ease the transition computation \n            state.combination := Set<State>.new  \n            state.combination.add(news) \n        end \n        // Process the right element of the pair :  \n        // add it to the eq.class of the left element! \n        var sright : State init stateSet. \n             detect { s | pair.right == s and s.combination == void } \n        if (sright != void) then \n            sright.combination := Set<State>.new  \n            result.detect{ c | c.contains(state)}. \n               add(State.clone(pair.right)) \n            output.stateSet. \n               collect { s | s.combination}. \n                  detect{ c | c.contains(state) }. \n                     add(State.clone(pair.right)) \n        end \n} \n        // Set the eq-class of current state in its \"combination\" \n        // attribute if it was skipped because already processed \n        // through the left element selection \n        if (state.combination.size ==0) then  \n            state.combination.add(output.stateSet. \n               detect{ s | s.combination.contains(state)}) \n        end \n    end \n  end \n46      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \n     \n \n  // eqClassStateSet : the minimal automaton set of states \n  // stateSet : the input automaton set of states \n  // transitionSet : the intput automaton set of transitions \n  operation createEquivalentTransitions \n                    ( eqClassStateSet : Set<State>,  \n                      stateSet : Set<State>,  \n                      transitionSet : Set<Transition>) : \n                                       Set<Transition> is do \n    result := Set<Transition>.new \n    // for each eq-class \n    from var it : Iterator<State> init stateSet.iterator  \n    until it.isOff \n    loop \n        var nextInputState : State init it.next \n        // Get the eq.class to which the current state belongs \n        var nextEqClassState : State init  \n                                    nextInputState.combination.one  \n        // For each letter, Get the transition for which  \n        // the current state is a source \n        var nextTransitionSet : Sequence<Transition> init \n             transitionSet.select { t | t.source == nextInputState } \n        // The target combination is the eq. class target of  \n        // the new transition! \n        nextTransitionSet.each { t | \n        // Add this transition   \n        if result. \n           detect {  rt | rt.source == nextEqClassState and  \n                          rt.letter == t.letter } == void  \n        then \n            var newt : Transition init Transition.new \n            var nextEqClassStateTarget : State init \n                eqClassStateSet. \n                    detect { s | s.combination.contains(t.target) } \n            newt.initialize(nextEqClassState,  \n                            nextEqClassStateTarget,  \n                            t.letter) \n            result.add(newt) \n        end \n        } \n    end \n    // Print the transition \n    stdio.writeln(\"transitions : \" + result.size.toString) \n    result.each { t | stdio.writeln(t.toString) }  \n  end \n} \n \nOn Executable Meta-Languages applied to Model Transformations      47 \n6 Conclusion \nIn this paper we have shown how executable meta-languages could be used to \nexpress model transformations. \n \nWe have explained the rationales for building object-oriented executable meta-\nlanguages, and then discussed the perceived benefits of these languages applied to the \nmodel transformation field.  \n \nWe are currently in favor of a level of language support for model transformation \nwhich is between totally general purpose languages (such as Java) and model \ntransformation domain specific languages such as specified by QVT. Our approach \ncould be described as model domain specific languages. \n \nNevertheless, Kermeta is first and foremost an executable meta-language, which \ncan be used to for a wide range of purposes, including model transformation but also \nto specify the abstract syntax of languages under the shape of metamodels. As \nKermeta is executable, the operational semantic of these languages can then be further \nspecified, and even implemented by reusing domain specific libraries. Hence, \nKermeta is a language development environment, where domain specific \nexperimentations can be conducted via libraries, and then injected into Kermeta \nmetamodels, which in turn model domain specific languages (for instance for model \ntransformation). \n \nInterestingly, we have found that it was more difficult to understand the description \nof the required transformations than to write the transformations. This leads us to \nbelieve that it would be useful to find more precise ways to specify the \ntransformations. \n \nThe work presented in this paper may be viewed as an experimentation in applying \nexecutable meta-languages to model transformations. Our work is obviously far from \nbringing definitive answers to the complex problems addressed by the MTIP \nworkshop. However the presented material may contribute, with many other ongoing \nresearch works on similar topics, to a better understanding of language requirements \nwith respect to model transformations and software engineering. \n \n48      P.-A. Muller, F. Fleurey, D. Vojtisek, Z. Drey, D. Pollet, F. Fondement, P. Studer, J.-M Jézéquel \n \nReferences \n                                                           \n1 OMG. MOF 2.0 Core Final Adopted Specification, Object Management Group, http://www.omg.org/cgi-\nbin/doc?ptc/03-10-04, 2004. \n2 Netbeans MDR, web site http://mdr.netbeans.org/ \n3 Budinsky, F., Steinberg, D., Merks, E., Ellersick, R. and Grose, T. Eclipse Modeling Framework. Addison \nWesley Professional, 2003. \n4 A. Ledeczi, M. Maroti, A. Bakay, G. Karsai, “ The Generic Modeling Environment” , Proceedings of the \nIEEE International Workshop on Intelligent Signal Processing, WISP'2001, Budapest, Hungary, may 24-\n25, 2001 \n5 Vojtisek, D. and Jézéquel, J.-M. MTL and Umlaut NG: Engine and Framework for Model \nTransformation. ERCIM News, 58. \n6 Bézivin, J, Dupé, G, Jouault , F, Pitette, G, and Rougui, EJ : First experiments with the ATL model \ntransformation language: Transforming XSLT into XQuery. In: OOPSLA 2003 Workshop, Anaheim, \nCalifornia. \n7 OMG. Revised submission for MOF 2.0 Query/View/Transformation, Object Management Group (QVT-\nMerge Group), http://www.omg.org/cgi-bin/apps/doc?ad/2005-03-02, 2005. \n8 OMG. UML 2.0 Object Constraint Language (OCL) Final Adopted specification, Object Management \nGroup, http://www.omg.org/cgi-bin/doc?ptc/2003-10-14, 2003. \n9 Mellor, S., Tockey, S., Arthaud, R. and Leblanc, P. Action Language for UML: Proposal for a Precise \nExecution Semantics. Proceedings of UML 98 (LNCS1618). 307-318. \n10 Borras, P., Clement, D., Despeyroux, T., Incerpi, J., Kahn, G., Lang, B. and Pascual, V. Centaur: the \nsystem. Proceedings of the ACM SIGSOFT/SIGPLAN software engineering symposium on practical \nsoftware development environments, 13 (5). 14 - 24. \n11 Clark, T., Evans, A., Sammut, P. and Willans, J. Applied Metamodelling: A Foundation for Language \nDriven Development, http://albini.xactium.com, 2004. \n12 Greenfield, J., Short, K., Cook, S., Kent, S. and Crupi, J. Software Factories: Assembling Applications \nwith Patterns, Models, Frameworks, and Tools. Wiley, 2004. \n13 Muller, P.-A., Studer, P., Fondement, F. and Bezivin, J. Platform independent Web Application \nModeling and Development with Netsilon. Accepted for publication in Journal on Software and Systems \nModelling (SoSym). http://www.sciences.univ-nantes.fr/lina/atl/www/papers/netsilon_sosym.pdf. \n14 X. Blanc, S. Bouzitouna and M.P. Gervais, A Critical Analysis of MDA Standards through an \nImplementation: the ModFact Tool, First European Workshop on Model Driven Architecture with \nEmphasis on Industrial Application, March 17-18, 2004, Enshede, The Netherlands. \n15 Muller, P.-A., Fleurey, F., Jézéquel, J.-M.: Weaving executability into object-oriented meta-languages. In \nL. Briand, S.K., ed.: Proceedings of MODELS/UML’2005. Volume to be published of LNCS., Montego \nBay, Jamaica, Springer (2005) \n16 http://www.kermeta.org \n17 D. Roberts and R. Johnson. Evolve frameworks into domain-specific languages. In 3rd International \nConference on \nPattern Languages, Allerton Park, Ill., September 1996. \n18 http://modelware.inria.fr/mtl \n19 Gamma Erich, Helm Richard, Johnson Ralph, and Vlissides John. Design Patterns: Elements of \nReusable Object-Oriented Software. Addison-Wesley, 1994. \n20 http://www.omondo.com/ \n21 Gerson Sunye, Damien Pollet, Ives Le Traon, and Jean-Marc Jezequel. Refactoring UML models. In \nProceedings of UML 2001, pp. 134-148 \n22 Julia, Automates finis, University Course, Université de Nice Sofia-Antipolis, France \n23 Watson, B.W, A Taxonomy of finite automata minimization algorithms, Technical Report, Faculty of \nMathematic and Computing Science, Eindhoven University of Technology, the Netherlands (Sep. 1994) ",
  "topic": "Executable",
  "concepts": [
    {
      "name": "Executable",
      "score": 0.8373404741287231
    },
    {
      "name": "Model transformation",
      "score": 0.8365832567214966
    },
    {
      "name": "Computer science",
      "score": 0.7503631114959717
    },
    {
      "name": "Programming language",
      "score": 0.6873658895492554
    },
    {
      "name": "Transformation (genetics)",
      "score": 0.6229540705680847
    },
    {
      "name": "Metamodeling",
      "score": 0.5882967710494995
    },
    {
      "name": "Scalability",
      "score": 0.5547889471054077
    },
    {
      "name": "Robustness (evolution)",
      "score": 0.45577526092529297
    },
    {
      "name": "Model-driven architecture",
      "score": 0.41518038511276245
    },
    {
      "name": "Artificial intelligence",
      "score": 0.3164742588996887
    },
    {
      "name": "Unified Modeling Language",
      "score": 0.2681877613067627
    },
    {
      "name": "Database",
      "score": 0.16299709677696228
    },
    {
      "name": "Consistency (knowledge bases)",
      "score": 0.0
    },
    {
      "name": "Biochemistry",
      "score": 0.0
    },
    {
      "name": "Software",
      "score": 0.0
    },
    {
      "name": "Chemistry",
      "score": 0.0
    },
    {
      "name": "Gene",
      "score": 0.0
    }
  ]
}