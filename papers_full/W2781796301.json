{
    "title": "The effect of subject measurement error on joint kinematics in the conventional gait model: Insights from the open-source pyCGM tool using high performance computing methods",
    "url": "https://openalex.org/W2781796301",
    "year": 2018,
    "authors": [
        {
            "id": "https://openalex.org/A2188594581",
            "name": "Mathew Schwartz",
            "affiliations": [
                "Seoul National University",
                "New Jersey Institute of Technology",
                "Advanced Institute of Convergence Technology"
            ]
        },
        {
            "id": "https://openalex.org/A2139495535",
            "name": "Philippe C Dixon",
            "affiliations": [
                "Liberty Mutual Research Institute for Safety",
                "Harvard University"
            ]
        },
        {
            "id": "https://openalex.org/A2188594581",
            "name": "Mathew Schwartz",
            "affiliations": [
                "New Jersey Institute of Technology",
                "Advanced Institute of Convergence Technology"
            ]
        },
        {
            "id": "https://openalex.org/A2139495535",
            "name": "Philippe C Dixon",
            "affiliations": [
                "Liberty Mutual Research Institute for Safety",
                "Harvard University"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W2159816623",
        "https://openalex.org/W1965341513",
        "https://openalex.org/W2104670628",
        "https://openalex.org/W2086801037",
        "https://openalex.org/W2048365541",
        "https://openalex.org/W2128822529",
        "https://openalex.org/W23220501",
        "https://openalex.org/W1976953979",
        "https://openalex.org/W2078936766",
        "https://openalex.org/W1990871170",
        "https://openalex.org/W2105958576",
        "https://openalex.org/W2138218892",
        "https://openalex.org/W2163704349",
        "https://openalex.org/W2038428415",
        "https://openalex.org/W2049223406",
        "https://openalex.org/W2093188224",
        "https://openalex.org/W2102407895",
        "https://openalex.org/W1969663844",
        "https://openalex.org/W2342163475",
        "https://openalex.org/W1968043607",
        "https://openalex.org/W2154482673",
        "https://openalex.org/W2130281033",
        "https://openalex.org/W2059985438",
        "https://openalex.org/W1999969442",
        "https://openalex.org/W1997401004",
        "https://openalex.org/W6676475837",
        "https://openalex.org/W2136083589",
        "https://openalex.org/W2203630559",
        "https://openalex.org/W2163349370",
        "https://openalex.org/W2122104565",
        "https://openalex.org/W6639990485",
        "https://openalex.org/W2234675890",
        "https://openalex.org/W2108499234",
        "https://openalex.org/W2044234061",
        "https://openalex.org/W1976181437",
        "https://openalex.org/W3204445786",
        "https://openalex.org/W2050578981",
        "https://openalex.org/W2349802342",
        "https://openalex.org/W1924044378",
        "https://openalex.org/W2460943867",
        "https://openalex.org/W4230006697",
        "https://openalex.org/W1790910337",
        "https://openalex.org/W1833108637",
        "https://openalex.org/W157527733",
        "https://openalex.org/W4285719527",
        "https://openalex.org/W2109026728"
    ],
    "abstract": "The conventional gait model (CGM) is a widely used biomechanical model which has been validated over many years. The CGM relies on retro-reflective markers placed along anatomical landmarks, a static calibration pose, and subject measurements as inputs for joint angle calculations. While past literature has shown the possible errors caused by improper marker placement, studies on the effects of inaccurate subject measurements are lacking. Moreover, as many laboratories rely on the commercial version of the CGM, released as the Plug-in Gait (Vicon Motion Systems Ltd, Oxford, UK), integrating improvements into the CGM code is not easily accomplished. This paper introduces a Python implementation for the CGM, referred to as pyCGM, which is an open-source, easily modifiable, cross platform, and high performance computational implementation. The aims of pyCGM are to (1) reproduce joint kinematic outputs from the Vicon CGM and (2) be implemented in a parallel approach to allow integration on a high performance computer. The aims of this paper are to (1) demonstrate that pyCGM can systematically and efficiently examine the effect of subject measurements on joint angles and (2) be updated to include new calculation methods suggested in the literature. The results show that the calculated joint angles from pyCGM agree with Vicon CGM outputs, with a maximum lower body joint angle difference of less than 10-5 degrees. Through the hierarchical system, the ankle joint is the most vulnerable to subject measurement error. Leg length has the greatest effect on all joints as a percentage of measurement error. When compared to the errors previously found through inter-laboratory measurements, the impact of subject measurements is minimal, and researchers should rather focus on marker placement. Finally, we showed that code modifications can be performed to include improved hip, knee, and ankle joint centre estimations suggested in the existing literature. The pyCGM code is provided in open source format and available at https://github.com/cadop/pyCGM.",
    "full_text": "RESEA RCH ARTICL E\nThe effect of subject measurement error on\njoint kinematics in the conventional gait\nmodel: Insights from the open-source pyCGM\ntool using high performance computing\nmethods\nMathew Schwartz\n1,2\n*, Philippe C. Dixon\n3,4\n1 Digital Human Research Center, Advanced Institutes of Conve rgence Technolo gy, Seoul National\nUniversity , Suwon, South Korea, 2 College of Architecture and Design, New Jersey Institute of Technolo gy,\nNewark , NJ, United States of America, 3 Department of Environment al Health, Harvard T.H. Chan School of\nPublic Health, Boston, MA, United States of America, 4 Liberty Mutual Research Institute for Safety,\nHopkinton, MA, United States of America\n* cadop@um ich.edu\nAbstract\nThe conventional gait model (CGM) is a widely used biomechanical model which has been\nvalidated over many years. The CGM relies on retro-reflective markers placed along anatomi-\ncal landmarks, a static calibration pose, and subject measuremen ts as inputs for joint angle\ncalculations. While past literature has shown the possible errors caused by improper marker\nplacement, studies on the effects of inaccurate subject measurement s are lacking. Moreover,\nas many laboratorie s rely on the commercial version of the CGM, released as the Plug-in Gait\n(Vicon Motion Systems Ltd, Oxford, UK), integrating improvemen ts into the CGM code is not\neasily accomplished. This paper introduces a Python implementation for the CGM, referred to\nas pyCGM, which is an open-source, easily modifiable, cross platform, and high performance\ncomputational implementation . The aims of pyCGM are to (1) reproduce joint kinematic out-\nputs from the Vicon CGM and (2) be implemented in a parallel approach to allow integration\non a high performance computer. The aims of this paper are to (1) demonstrate that pyCGM\ncan systematically and efficiently examine the effect of subject measurements on joint angles\nand (2) be updated to include new calculation methods suggested in the literature. The results\nshow that the calculated joint angles from pyCGM agree with Vicon CGM outputs, with a max-\nimum lower body joint angle difference of less than 10\n-5\ndegrees. Through the hierarchical\nsystem, the ankle joint is the most vulnerable to subject measurement error. Leg length has\nthe greatest effect on all joints as a percentage of measurement error. When compared to the\nerrors previously found through inter-laboratory measurement s, the impact of subject mea-\nsurements is minimal, and researchers should rather focus on marker placement. Finally, we\nshowed that code modifications can be performed to include improved hip, knee, and ankle\njoint centre estimations suggested in the existing literature. The pyCGM code is provided in\nopen source format and available at https://github.com/c adop/pyCGM.\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 1 / 24\na1111111111\na1111111111\na1111111111\na1111111111\na1111111111\nOPEN ACCESS\nCitation: Schwartz M, Dixon PC (2018) The effect\nof subject measureme nt error on joint kinema tics\nin the conventional gait model: Insights from the\nopen-sourc e pyCGM tool using high performance\ncomputing methods. PLoS ONE 13(1): e0189984.\nhttps://do i.org/10.1371/j ournal.pone .0189984\nEditor: Christof Markus Aegerter, Univers itat\nZurich, SWITZERLA ND\nReceived: August 7, 2016\nAccepted: December 6, 2017\nPublished: January 2, 2018\nCopyright: © 2018 Schwartz, Dixon. This is an\nopen access article distributed under the terms of\nthe Creative Commons Attributio n License, which\npermits unrestricte d use, distribu tion, and\nreproduction in any medium, provided the original\nauthor and source are credited.\nData Availabilit y Statement: The long motion\ncapture file link is: https://g ithub.com/ca dop/\npyCGM/tree /master/S ampleData.\nFunding: The authors received no specific funding\nfor this work.\nCompeting interests : The authors have declared\nthat no competing interests exist.\n1 Introduction\n1.1 Conventional gait model\nHuman locomotion has been a central theme of biomechanics research for centuries (c.f. [1]\nfor a historical perspective). Fundamental to the evaluation of human motion is the precise\nquantification of three-dimensional joint kinematics (angles); however, as the technology to\nrecord motion grew over time, the translation between engineering and clinical approaches to\nmeasure this motion became a challenge [2]. Biomechanical models with clinical relevant mea-\nsures have been developed to overcome this problem.\nThere are many biomechanical models available for kinematic analyses [3–8]. Of these, the\nCGM, also known as the Newington, Davis, Gage, Helen Hayes, or Kadaba model, has been\nused extensively in clinical and research settings for many years. More specifically, Vicon’s\nCGM implementation via the plug-in-gait modeler [9] is popular as it is distributed in their\nsoftware packages such as Nexus [10]. As with many other models, the CGM relies on retro-\nreflective skin mounted markers capable of tracking body movements in order to compute\njoint kinematics [11]. This paper focuses on the Vicon CGM implementation. This model\nbegan to be defined by Kadaba, first with experiments in repeatability [8] and then as a method\nto calculate lower-limb joint angles [12], based on the orthopedic knee angle definitions of\nGrood and Suntay [13].\nAlthough the CGM has been validated, it is not without problems. Directly related to the\ncalculation methods of the CGM, four main issues appear. (1) As a direct kinematic and hier-\narchal method, a proximal origin’s frame definition influences more distal segments [12, 14].\nFor example, the definition of the tibia local coordinate system (distal) relies on the correct\ndefinition of the femur (proximal) local coordinate system. (2) Incorrect placement of markers\nalong predefined anatomical landmarks is a known source of error in the CGM joint kine-\nmatic outputs [14–16]. (3) As with other marker-based models, the CGM is prone to errors\nfrom skin movement artifacs [17–19]. (4) The definition of the hip joint center location relies\non regression equations from the early work of Davis et al. [20]. In practice, another issue has\nbeen the location of the knee and ankle joint centers having been generated by a proprietary\nformula known as the “Chord function” [9]. Improved approaches have been suggested in the\nliterature (c.f. Harrington et al. [21] for refined regression equations for hip joint center identi-\nfication and Stief et al. [22] for improved methods to identify the locations of the knee and\nankle joints), but have not been natively implemented into the CGM model. An open-source\nCGM distribution could allow researchers to refine model outputs using these, or any other\nmethod described in the literature. Finally, the CGM maintains a low marker count (full kine-\nmatic analysis possible using 16 markers on the lower body and 19 markers on the upper\nbody) through the input of subject anthropometric measurements and a static calibration trial,\nboth of which allow previously defined quantities to act as virtual markers during the compu-\ntation of joint kinematics. This approach introduces subject measurements as another poten-\ntial source of error.\nPrevious work has shown that subject measurement error can propagate to joint kinematic\nquantities [23]. In the work of Benedetti et al. [23], the analysis of a single healthy subject at 7\ndifferent laboratories resulted in inter-laboratory differences of 30 mm in pelvic width (inter\nanterior-superior iliac spine distance), 25 mm in leg length, 5 mm in knee width, and 10 mm\nin ankle width measurements. The extent to which subject measurement error can affect joint\nangles has not been thoroughly explored. This last problem can be systematically investigated\nvia the implementation of high performance computing methods in pyCGM.\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 2 / 24\n1.2 Computational power and parallelization\nComputational power has been continuously increasing for decades [24]. Through these\nadvancements, numerous problems that were previously unsolvable due to the length of time\nneeded for computations have been tackled using High Performance Computers (Computing)\n(HPC). Likewise, parallelization, in which multiple calculations can be executed simulta-\nneously on different computer cores, especially when dealing with large numbers of indepen-\ndent variables, has been vital to understanding complex systems.\nIn the case of kinematic analysis, recording motions at high sampling rates over long peri-\nods of time can result in a significant amount of data to be processed, suggesting an important\nuse-case for HPC and parallelization solutions. For example, a study on the effect of high heels\non gait, in which 10 subjects walked at 5 cadences with 3 different heel heights, resulted a total\nof 150 trials to be analyzed [25]. For analyses of dynamic stability during gait, experiments\noften require considerably more data. In the work of Bruijn et al. [26], data were collected for 9\nsubjects during trials of 10 to 20 minutes. Furthermore, research has shown the usefulness of\nparallelization for auto-labeling of marker sets [27].\nCurrently, open source biomechanics tools such as OpenSim [28] and BTK [29] provide a\nplatform for motion capture data visualization and biomechanics calculation. Additionally, the\nCGM has been implemented by [30]; however, the source code is not readily available and the\nliterature does not discuss computational times and methods. Accessible open source and easy\nto modify code for joint kinematics is lacking, making it difficult for researchers to take advan-\ntage of the long history of motion capture and joint kinematic research for application in their\nown work. Recently Vicon Nexus has released an API to use their CGM, although this still\nrequires a Vicon Nexus license. However, open source code that is only concerned with an\ninput of marker locations disconnects it from any commercial software. This disconnect allows\nfor identical calculations of joint kinematics from any hardware system (ex. Qualisys, Vicon,\nOptiTrack). For example, a user can leverage the Qualisys API to send marker data to pyCGM\nfor kinematic calculations. Similarly, pyCGM could be used in conjunction with OpenSim to\nsimulate and visualize movement. Without readily accessible code, each user must port bio-\nmechanical models to his or her own system, or rely on the real-time streaming ability of com-\nmercial products. For example, in robotics, research has been done on translating human\nmotion to humanoid robots [31–33] and on using human motion capture data and analysis to\nwork with humanoids through the development of HuMoD, an open database of a variety of\ngait motions and related measurements [34], largely in isolation from the developments in the\ngait community. The literature lacks exploration into the role of HPC and parallelization in\nterms of computational performance of joint kinematic analysis algorithms, such as with the\nCGM. At the same time, the introduction of HPC to the masses, such as Amazon Web Ser-\nvices, allows an easy platforms for development [35].\n1.3 Python CGM\nThe basis of this paper is an open source Python script for the CGM, referred to as pyCGM\n[36]. First, a validation of the pyCGM joint kinematic outputs against the CGM model imple-\nmented by Vicon (Vicon Motion Systems Ltd., Oxford, UK) is presented. Second, the non-\noptimized direct kinematic approach of pyCGM allows for a frame-by-frame calculation for\njoint kinematics and, as such, provides an opportunity for easy HPC implementation to assist\nin the kinematic processing. Similarly, the portability and modularity provided by pyCGM\nallows researchers to quickly modify the parameters of the model and distribute workloads of\neither frame-by-frame or trial-to-trial calculations to an HPC. Thus, the reduction in joint\nkinematic computation times using pyCGM through HPC and parallelization approaches are\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 3 / 24\nexplored. Third, the HPC setup is used to systematically explore the effect of subject measure-\nment error on joint kinematics. Finally, examples of how pyCGM can be modified to include\nimprovements to the CGM suggested in the literature are provided.\n2 Methods\n2.1 pyCGM process\nThe pyCGM code can be run through either a command line or by directly calling the func-\ntions. Data can be passed to the joint angle calculations directly or by functions loading files\nwhich store data as a python dictionary. The process for calculating a dynamic trial is detailed\nin Fig 1.\nFiles are loaded or data is created in section B, with an argument passing the number of\ncores to use for calculations. Subject measurements can be loaded through a.VSK file (Vicon\nSkeleton), which may contain either subject measurements or subject measurements and\nFig 1. Process of the pyCGM system. There are five key parts to the computatio n. (A) A python terminal is passed arguments or the pyCGM is integrated into a larger\npython code. (B) Data is loaded for subject measurements , static and dynamic trials, and option al input for the number of cores to use. (C) If static offsets have not\nbeen provid ed, they are calculate d using the static trial; otherwi se, the calculation is passed. (D) Frames of the dynamic trial are divided and distribute d to the number\nof specified cores. Subject measurem ents and static offsets are passed to each core as well. The results are gathered by the original process. (E) Data is saved in a user-\nspecified format.\nhttps://d oi.org/10.1371 /journal.pone. 0189984.g001\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 4 / 24\ncorresponding static calibration information. Joint angles of a static trial can be obtained by\nusing the same file for the dynamic trial. In section C, the static offsets are calculated when this\ninformation is missing. Static offsets rely on the computation of the CGM for each frame of\nthe static trial and averaging the results at the end. Once the subject measurements and offsets\nare known, the frames of the dynamic trial are divided evenly among the number of cores\ndefined and the data is distributed.\nOne of the key aspects to the CGM is estimating a joint center using subject measurements\nand virtual markers. While this method has been explained for the hip in [20], the authors are\nunaware of any paper that mathematically describes how the “Chord function” [9] computes\nknee and ankle joint centers. The calculation used here is with the Rodrigues rotation formula\n[37], as seen in S1 Equation. This formula allows for the minimum marker set by creating a\nvirtual marker in the joint center that is used as the segment frame origin. The description is\nshown in S1 Fig, with the offset value being half of the knee width measurement, denoted by\nkw. As such, this joint center is directly dependent on the subject measurement. Implementa-\ntion of this formula in pyCGM can be seen in the sample code shown in S2 Fig.\nWhile pyCGM has followed the methods defined in the literature, one significant difference\nis implemented in the calculation of joint angles. While Kadaba [12] defined theta using arcsin,\nthis only works up to a 90-degree rotation. As such, motions such as sitting in a chair or walk-\ning up stairs in which hips or knees will bend more than 90 degrees should be calculated using\nthe arctan function, as seen in S3 Fig.\n2.2 Parallelization\nThe CGM has three main parts: a static trial, dynamic trial, and subject measurements. While\na static calibration is required, the calculated values act as constants in the calculations. This\nindependence is important for the parallelization efficiency and scalability of the system. The\nprocess requiring an average or other calculation over all frames can be seen in Fig 2(a), com-\npared to Fig 2(b), in which each frame is independent.\nWhile both Fig 2(a) and 2(b) begin with individual frames in row 1, Fig 2(a) row 2 must col-\nlect results from each process and pass them for further processing in row 3. Each time this\noccurs, an overhead for communication between processes is created. The static calibration of\nthe CGM averages the offset angles of the ankle and neck, and averages the distance between\nASIS markers. For this reason, the short static trials used in static calibration in this research\nare not parallelized and are instead calculated sequentially on a single core. However, the lon-\nger and frame-independent dynamic trials are the focus of the parallelization due to the higher\nincrease in performance through optimal use of cores and low overhead, similar to Fig 2(b).\nIn a similar way, an increase in frames requires a linear increase in computation, giving the\nmethod in Fig 2(b) a computational complexity O ðnÞ. In terms of computational time, an n\nincrease in frames can be mitigated with an n increase in processors, with an overhead consis-\ntent with the communication algorithm.\n2.2.1 Desktop parallelization. While access to HPC is increasing, the use of multi-core\ndesktop computers is nearly ubiquitous, and as such, methods for parallelizing the CGM are\napplicable on these platforms as well. For simple cross-platform testing, the python multipro-\ncessing module was used for parallel processing of dynamic trials (Fig 3). The original process\non core 0 reads the required data such as dynamic trial, static offsets, and subject measure-\nments (1). The data is stored as a python dictionary, which is split between keys and values for\nfast IO communication. Data are divided between frame length and number of cores to be\nused, then written as a temporary file to memory using mmap (2) while passing the file loca-\ntion to each process, which has a lower overhead than full use of serial communication directly\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 5 / 24\nbetween processes. The filename, memory size, and object size are stored, then later read and\ncombined by each process (3) for use in the joint angle calculation. The multiprocessing.Pro-\ncess (an object of the multiprocessing library) method of python is used to instantiate a new\ninstance of python for the calculation. After the result is put and aggregated by the original\nprocess, the open processes are exited(4).\n2.2.2 High performance computation. Similar to the method for desktop parallelization,\na single dynamic trial can be distributed among multiple nodes on an HPC. In this method, an\ninitial processor (rank 0) is responsible for loading and distributing data (Fig 4). Rank 0 loads\nsubject measurements, the static trial, and the dynamic trial. The static offsets are calculated\nand the dynamic trial is divided into dictionary labels and values, which are distributed among\nthe number of ranks available along with the static information.\nCalculation of multiple trials or, in the case of this research, multiple iterations of a single\ndynamic trial can be done by either passing data using MPI or by relying on the IO luster sys-\ntem. In Fig 5, the method for distributing data using MPI is detailed. Rank 0 loads subject mea-\nsurements, the static trial, and the dynamic trial. In addition, an array of subject measurement\noffsets is equally divided among the number of ranks used in the calculation. Rank 0 uses MPI\nscatter to distribute the offsets among ranks, and uses bcast to distribute the static trial, subject\nmeasurements, and dynamic trial to all ranks involved in the calculations. Each rank then uses\nFig 2. Abstraction of averaged calculatio n vs. direct calculatio n. (a) The first row shows data being passed to each theoretical core. Between rows 2 and 6, data is\ncalculate d in relation to itself, which reduces the maximum number of usable cores after each process. This method would be used to parallelize the static trial offsets,\ncreating overhead between each data combinatio n. (b) Calculations that are independen t of the data can be calculate d at once, making the maximu m usable cores\nequal to the number of datum. This is the method used to parallelize the dynamic trial calculations .\nhttps://d oi.org/10.1371 /journal.pone. 0189984.g002\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 6 / 24\nthe given array of subject measurement offsets to recalculate the static trial and calculate the\nnew joint angles from the dynamic trial. Each rank saves the calculated joint angles and iterates\nthrough the array of subject measurements. In this system, rank 0 does not handle the gather-\ning or saving of the data from each rank, and instead tracks computation time and when all\nranks have finished calculations.\nFig 3. Diagram of paralleli zation for desktop. (1) Data is loaded by the root processor. (2) The root processo r divides\nthe data by the number of processes available and writes temporary files to memory. (3) The processes receive the file\nlocation containing their data and calculate the joint angles. (4) The root process gathers the data and each spawned\nprocess exits.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.g0 03\nFig 4. Abstraction diagram of a paralleli zed dynam ic trial calcula tion on the HPC. In this example, processors 0-3\nare located on node 1, and 4-6 are located on node 2. (1) The static trial, subject measurem ents, and the dynamic trial\nare stored on the IO system which are loaded by rank 0. (2) Rank 0 then distributes the frames evenly among the\navailabl e ranks using the MPI.scatter method, and uses the MPI.bcast method to send the calculate d static offsets and\nloaded subject measurem ents. (3) Rank 0 collects the joint angle results with the MPI.gathe r method.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.g0 04\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 7 / 24\n2.3 Data\nFor analyzing the computational performance of a parallel system on large motion capture\ndata, a file containing 59,993 frames was recorded at 100 Hz in Vicon Nexus (v1.8, Vicon\nMotion Systems Ltd, Oxford, UK) using the 35 marker set. This trial is used purely as a method\nfor checking parallelization efficiency and space complexity, and not used for the subject mea-\nsurement analysis.\nTo analyze the effect of subject measurement on joint kinematics, the sample data distrib-\nuted on Vicon Nexus systems was used for its wide availability and unbiased marker position-\ning. This dataset includes, among others, a static trial with 275 frames, a range of motion\n(ROM) trial with 2,076 frames, and complete subject measurements stored in a.VSK file, all\nthree of which are used in this research. The trials contain two additional markers on each\narm, UPA and FRM; however, these markers are not used in the calculations. The ROM file\nwas selected for analysis, as it allows for a thorough understanding of the influence of subject\nmeasurements throughout different motions that may be calculated by the CGM. For example,\nhip flexion that occurs during a sitting motion would not appear during a typical gait cycle.\nWhile most of the data was complete, the squat and bending motion of the ROM had occluded\nmarkers which were gap-filled within the Vicon Nexus software. The ROM file data was cate-\ngorized into the individual movements for analysis. The data displayed in the Results includes\na squat motion, front leg raise, and a side leg raise.\nSaving the results is done with the numpy compressed format NPZ. The advantage of the\nNPZ format over C3D format is the fast data IO and extremely simple programming methods.\nKeywords are used to determine which of the joint angles are to be saved in the file to reduce\nunnecessary time and space in the saving process. In the case of this research, the joint angles\nfor only the lower body are saved in the NPZ format(S1 File). Table 1 shows the space required\nto save various numbers of frames.\nFig 5. Abstraction diagram of distribut ed computatio n of multiple files on the HPC. (1) The dynamic trial, static\ntrial, and subject measurem ents are stored on the IO Luster system. (2) The rank 0 core loads the data from the luster\nsystem. (3) Rank 0 calculate s all variations of subject measurements and distributes them over the available ranks using\nthe MPI.scat ter method. (4) Rank 0 uses MPI.bcas t method to distribute the dynamic trial, static trial, and subject\nmeasurem ents to all ranks. (5) Each rank saves the resulting data directly to the luster system.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.g0 05\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 8 / 24\n2.4 Subject measurements\nThere are 6 subject measurements related to distance that affect the joint angle calculations of\nthe lower body: ASIS to trochanter distance (AT), inter ASIS distance (IAD), leg length (LL),\nknee width (KW), ankle width (AW), and sole delta. While LL, KW, and AW are required\ninputs for the CGM, the AT and IAD can either be input manually or calculated automatically\nfrom marker positions, and sole delta can be set to 0. As the former three are required in all sit-\nuations, the current analysis is focused on these parameters. To demonstrate the HPC perfor-\nmance of numerous dynamic trials, various permutations of these 5 measurements are\ncalculated. Permutations with repetitions are calculated by the n number of possible subject\nmeasurement values to the power of r number of measurements, denoted by n\nr\n. Sampling of\nthe values was done in three steps.\n• Intervals of 0.5 from -5 to 5 are generated for LL, KW, and AW, resulting in 21\n3\ncombinations.\n• A large range from +/- 0 to 80 for LL, KW, and AW with increments doubling for 9\n3\ncombinations.\n• An additional 9\n3\ncombinations involving AT and IAD were used for the computational per-\nformance experiment, but not used for data analysis.\n• Excluding duplicates from each range, such as all measurements being 0.\nThe total number of these combinations results in 10,685 unique dynamic trials being cal-\nculated. Both the analysis and computational times for calculating these files are detailed in the\nResults section.\n2.5 Hardware and software\nExperiments were done on two platforms using Python 2.7. First, the python multiprocessing\nmodule was implemented on a laptop running Windows 7 64-bit with a quad core Intel i7-\n4700MQ processor at 2.4 GHZ, and 16 GB of RAM. This laptop was also used for the timing\nexperiments to compare against Vicon Nexus 1.8. For the HPC experiment a Cray XC30\nsupercomputer was used (Referred to as Darter). Each node consists of two 2.6GHz Intel\n8-core XEON E5-2600 CPUs and 32GB of RAM, with hyper-threading disabled.\n3 Results\n3.1 Kinematic validation\nThe dynamic ROM trial joint kinematic outputs from pyCGM and Vicon’s CGM implentation\nwere compared (Table 2). The results show that both the upper and lower body joint angle esti-\nmations from pyCGM agree with the Vicon CGM outputs within 10\n-5\ndegrees.\nTable 1. Space requiremen t for saving lower body joint angles and axis to a .npz file.\nFrames .npz Angles and Axis .npz Angles .c3d Withou t UPA/FRM .c3d With UPA/FR M\n100 81,884 13,672 61,632 82,080\n1000 827,094 137,901 565,632 751,680\n10000 8,397,657 1,410,613 5,605,632\n50000 42,016,679 7,070,983 Nexus Failed Saving\nValues are in bytes. The Angles and Axis column represent s the file size when both angles and the frames used to calculate the angles are saved. The Angles column is\nwhen only the angles are saved. In both cases, joint angle data is for right and left, hip, knee, ankle, and foot progression angles. The sample data from Vicon Nexus\nincludes the UPA and FRM markers, however, the trial used for longer calculat ions does not.\nhttps://do i.org/10.1371/j ournal.pone .0189984.t001\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 9 / 24\n3.2 Computational performance\nThe first experiment comparing the computational performance of the pyCGM against\nVicon’s CGM implementation in Nexus v1.8 is on a consumer-based four-core laptop. As\nNexus calculates both kinetics and kinematics, it is not possible to compare exact computa-\ntional speed differences against pyCGM. However, the results give a frame of reference for\npractical computation times on any multi-core consumer computer when kinetic calculations\nare not required. Fig 6 shows that with a four-core computer, the parallelized version of the\nCGM implemented in python can provide significant improvements to the calculation times\nspecific for kinematics. As a stand-alone compiled program, comparison against Nexus’s com-\nputation time demonstrates the speed benefit of parallelization.\nScalability on the HPC of the multiple core approach to the CGM can be seen in Fig 7.\nWhile the dynamic trial is parallelized, the file IO and static calibration are not, and as such,\nthese remain nearly constant, as shown in Fig 4. Furthermore, the efficiency in scaling the\nCGM can be seen in Table 3, as the actual increase in performance closely tracks the ideal. By\nutilizing 16 nodes, this implementation can calculate over 27,000 frames per second.\nTo calculate multiple variations of a dynamic trial, an experiment with both 800 and 1,600\ncores was conducted using the method explained in Fig 5. Similar to the previous experiment,\nthe increase in computing nodes scaled the computation time to a near ideal rate with the aver-\nage core calculation time for 10,685 variations of the dynamic ROM trial (2,076 frames) with\n800 cores at 179.6739 seconds, and 1,600 cores at 89.7404 seconds. The latter time demonstrates\nTable 2. Joint angle differences between Vicon CGM and pyCGM for the ROM file.\nLower X Y Z Maximum\nR Pelvis 2.66359E-06 3.31919E-0 6 4.27735E-06 0.000004\nL Hip 6.41988E-06 -1.37459 E-05 2.6727E-05 0.000027\nR Hip 5.38463E-06 -1.08932 E-05 5.17191E-05 0.000052\nL Knee 1.1362E-05 3.41015E-0 5 1.14514E-05 0.000034\nR Knee 1.07576E-05 4.18676E-0 5 1.25827E-05 0.000042\nL Ankle -1.55859E-05 8.80732E-0 6 1.40949E-05 0.000014\nR Ankle -2.91199E-06 2.5783E-05 1.54074E-05 0.000026\nL Foot Progress 5.03701E-05 4.05533E-0 5 8.8887E-06 0.000050\nR Foot Progres s 2.77097E-05 1.27706E-0 5 9.09723E-06 0.000028\nMaximum 0.000050 0.000042 0.000052\nUpper X Y Z\nL Shoulde r 4.26187E-06 5.26738E-0 6 1.16389E-05 0.000012\nR Shoulder 4.27861E-06 5.75079E-0 6 6.06542E-06 0.000006\nL Elbow 7.35977E-06 6.552E-12 6.551E-12 0.000007\nR Elbow 8.83274E-06 7.974E-12 7.603E-12 0.000009\nL Wrist 3.99468E-06 3.60593E-0 6 9.05932E-06 0.000009\nR Wrist 2.37015E-06 3.46521E-0 6 1.08998E-05 0.000011\nR Spine 2.88501E-06 3.3882E-06 3.33372E-06 0.000003\nR Thorax 4.75358E-06 1.69255E-0 6 4.253E-06 0.000005\nR Neck 8.83274E-06 7.974E-12 7.603E-12 0.000009\nR Head 3.3013E-05 1.40494E-0 5 2.51925E-05 0.000033\nMaximum 0.000033 0.000014 0.000025\nValues are calculated over the entire ROM file. Single joints such as the pelvis, spine, thorax, neck, and head output from pyCGM are compared against the “right side”\ncorrespon ding angle as the Vicon CGM uses the same value for both sides.\nhttps://do i.org/10.1371/j ournal.pone .0189984.t002\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 10 / 24\nan overall computation speed of 247,180 frames per second. Fig 8 shows the calculation times\non the initial core and the averaged times for calculations occurring across all cores.\n3.3 Influence of subject measurements\nThree key aspects of the relationship between subject measurement error and joint angle error\nwere analyzed. First, the maximum joint angle error of a +/- 2.5% and +/- 5% error in leg\nlength (LL), +/- 5% and +/- 10% in knee width (KW), and +/- 10% and +/- 20% in ankle width\n(AW) measurements during various motions from the ROM trial was found. The subject mea-\nsurement percentage error corresponds to the errors found from inter-laboratory testing in\n[23]. Second, the joint angles of the original data, along with +/- 5% error in LL and KW are\nshown for a squat motion in the knee joint. Finally, the subject measurement variations are\nranked by the largest error created for each combination, providing insights to the importance\nof each subject measurement and the predictability of this error.\nAs the CGM is based on a hierarchy of relative joints, the subject measurements influence\nthe joint angles in this hierarchy. As such, the modification of LL affects all joints, while the\nmodification of AW will only have a direct effect on the ankle frame, with an indirect effect of\nthe knee kinematics. For both squat and ankle rotation motions extracted from the ROM file,\nTable 4 shows the wide range of joint angle error caused by changing each subject measurement\nindependently. The data suggest that the rotation (z axis) in each joint is the most prone to\nerror in a majority of cases. However, Knee abduction (y axis) is also greatly affected by subject\nFig 6. Computation time comparis ons between Vicon’s CGM implemen tation (Nexus) and parallel programmi ng of pyCGM (Python) on a consumer laptop for\na trial containing 59,993 frames. Note: The laptop has 4 physical cores hyper-thre ading, but displays 8 processors to the multipro cessing module.\nhttps://d oi.org/10.1371 /journal.pone. 0189984.g006\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 11 / 24\nmeasurement errors. Ankle non-sagittal angles (y and z axes) show large error, but are not\noften considered in clinical analysis using the CGM. Importantly, during a squat motion the\nflexion (x) axis was not the largest source of error. Additionally, the range of error between the\nminimum and maximum throughout the motion suggests that the error is not a fixed offset.\nFig 7. Comput ation time of a dynamic trial across multiple cores and nodes. While the dynamic trial scales close to ideal across multiple cores and nodes, the\nsingle core calculations and IO operations remain nearly constant, with small variations over each experime nt. S1 Table provides a more detailed view of these\nresults.\nhttps://doi. org/10.1371/j ournal.pone .0189984.g00 7\nTable 3. Computatio nal performan ce of kinematic calculations for a dynamic trial on the HPC.\nCores Ideal Actual Frames/Seco nd\n2 188.4 188.4 318.5\n4 62.8 66.8 897.9\n16 12.6 14.8 4,063.2\n32 6.1 7.9 7,608.1\n64 3.0 4.5 13,435.0\n128 1.5 3.0 19,734.4\n256 0.7 2.2 27,011.8\nEach node on the HPC consists of 16 cpu cores. One node was used for the calculation s until 16 cores, after which\nthe numb er of nodes increase. Although 2 cores are used to begin with, one core is reserved for managing data and\nrecording times. This explain s the jump in performan ce from 2 to 4 cores. As can be seen, the actual performance\nclosely tracks the ideal performance of a paralleli zed model until 64 cores, after which the ideal metric outperforms\nthe actual by approximatel y 2 to 1. By 256 cores, over 27,000 frames can be calculated per second.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.t00 3\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 12 / 24\nThe irregular effect of subject measurements on joint angles is due in part to both the calcu-\nlation method (S1 Fig) and the hierarchal configuration. During motion such as a squat, the\nknee flexion axis is relatively unchanged, as this primary axis is defined by the lateral knee\nmarker. Additionally, a change in the leg length measurement changes the hip joint center,\nwhich in turn changes the orientation of the knee rotation axis (z). Hence both the leg length\n(Fig 9) and knee width (Fig 10) measurements affect the knee joint angle in a different manner\nover the course of a motion.\nFinally, by analyzing the 9,965 combinations of LL, KW, and AW, the most affected joint\nand axis can be found. Through the hierarchal system, the largest angle error of all combina-\ntions occurrs most often in the ankle joint (Table 5). The frame in which each joint incurs the\nlargest error across all measurements is largely consistent within the individual joint, but varies\nacross joints.\nThe large difference in the most common joint axis angles between right and left sides\nshows that the initial frame orientation and definition greatly influences the resulting errors\nfrom subject measurements(Table 6).\n3.4 CGM modifications\nThe code style of pyCGM was developed to be straight forward to understand and modify.\nBeyond the utility of being cross platform without modification there are no pointers or\nFig 8. Comput ation time of multiple variation s of the ROM trial. The sections prefixed with ‘Root’ refer to operations that occur\nonce at the beginning of the experiment on the initial core. The ‘Node’ prefix refers to calculati ons that occur on each core, with the\naverage values shown in the figure. The numeric results with minim um and maximum times are shown in S2 Table.\nhttps://doi.o rg/10.1371/j ournal.pone .0189984.g008\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 13 / 24\nobjects used in the calculation. Subject measurements are stored in a dictionary and are easily\nreferred to throughout the code.\nImprovement of the original CGM hip joint center location estimations [20] were imple-\nmented based on the work of Harrington et al. [21]. Fig 11 shows the minimal amount of\ncode.\nIt is also possible to determine the knee joint center locations using the method proposed\nby Stief [22]. In the code, the presence of a medial knee marker (R/L KNM) determines if the\nStief method is implemented. The midpoint between medial and lateral markers is used as the\njoint center with the vector defined as the midpoint to the medial marker. Fig 12 shows the\nimplementation in the pyCGM system. As the originally described method in [22] did not give\nexact details, the implementation here is approximate. However, modification of the method is\nsimple.\nTable 4. Joint angle error from variations in subject measureme nts.\nLL KW AW\n±2.5% ±5% ±5% ±10% ±10% ±20%\nSquat\n(3605*38 75)\nHip Flexion(X) 0.38 0.77 0.26 0.53\nAbduction(Y ) 0.23 0.46 0.36 0.73\nRotation(Z) 1.59 3.16 0.26 0.53\nKnee Flexion(X) 0.52 1.04 0.20 0.40 0.23 0.46\nAbduction(Y ) 1.45 2.91 0.69 1.38 0.50 1.00\nRotation(Z) 0.68 1.37 0.95 1.95 0.04 0.09\nAnkle Flexion(X) 0.22 0.44 0.18 0.37 0.30 0.59\nAbduction(Y ) 0.25 0.50 0.23 0.47 0.35 0.70\nRotation(Z) 0.66 1.33 0.75 1.52 0.10 0.22\nFront Kick\n(2925*29 75)\nHip Flexion(X) 0.36 0.72 0.12 0.24\nAbduction(Y ) 0.24 0.48 0.37 0.74\nRotation(Z) 1.37 2.75 0.08 0.17\nKnee Flexion(X) 0.24 0.49 0.12 0.25 0.19 0.38\nAbduction(Y ) 1.09 2.18 0.69 1.38 0.47 0.93\nRotation(Z) 0.64 1.29 0.68 1.40 0.03 0.05\nAnkle Flexion(X) 0.23 0.46 0.11 0.22 0.33 0.66\nAbduction(Y ) 0.30 0.60 0.28 0.57 0.34 0.70\nRotation(Z) 0.71 1.44 0.54 1.12 0.21 0.42\nLeg Swing\n(2200-2500)\nHip Flexion(X) 0.34 0.69 0.20 0.40\nAbduction(Y ) 0.28 0.56 0.36 0.72\nRotation(Z) 1.74 3.47 0.09 0.17\nKnee Flexion(X) 0.33 0.67 0.05 0.10 0.22 0.43\nAbduction(Y ) 0.95 1.90 0.68 1.37 0.44 0.89\nRotation(Z) 0.80 1.60 0.61 1.24 0.02 0.03\nAnkle Flexion(X) 0.40 0.81 0.40 0.83 0.50 1.01\nAbduction(Y ) 0.53 1.09 0.62 1.28 0.37 0.76\nRotation(Z) 0.70 1.41 0.69 1.40 0.25 0.52\nThe original values for Leg Length (LL), Knee Width (KW), and Ankle Width (AW) are 940 mm, 105 mm, and 70 mm, respectively. As such a 5% change in LL is 47\nmm, while the correspond ing chang e for KW is 5.25 mm. The maximu m values are combined from both the left and right joint angles and the positive and negative\ndirections of the offset. The Cells left blank are due to adjustments in ankle width not affectin g the Hip axis. Cells with Bold text are errors over 2 degrees.\nhttps://do i.org/10.1371/j ournal.pone .0189984.t004\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 14 / 24\n4 Discussion\n4.1 Summary\nThis paper presents experimental data for high performance computing of the CGM used for\ncalculating joint kinematics. It demonstrates three methods; specifically, the use of HPC for a\nFig 9. Joint angles of the knee during squat while changing the leg length. Graph of the right and left knee joint angles during a squat motion over 270 frames\n(3,605–3, 875) of the ROM trial. Leg length was changed by +/-5%. The original angle is represented by the grey line and the leg length modific ations are shown by the\nblack line.\nhttps://d oi.org/10.1371 /journal.pone. 0189984.g009\nFig 10. Joint angles of the knee during squat while changin g the knee width. Graph of the right and left knee joint angles during a squat motion over 270 frames\n(3,605–3, 875) of the ROM trial. Knee width was changed by +/-5%, where the original angle is represente d by the grey line, and the knee width modification s in the\nblack line.\nhttps://d oi.org/10.1371 /journal.pone. 0189984.g010\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 15 / 24\nsingle large file of motion capture data by distributing frames to be calculated on separate\ncores and across nodes, and the distribution of frames across cores on a consumer grade desk-\ntop, was investigated. Second, large calculations were performed on a single dataset to derive\nvaluable information about the model, such as the case of subject measurement errors, through\nthe distribution of data across cores.\nTable 5. Total number of subject measure ment errors.\nTotal Joint Joint Count Number of Frames Max Frame # Max Frame Count\nTotal 9965 66 1919 2599\nHip 3736 20 1919 5464\nKnee 1474 90 3773 5130\nAnkle 4755 55 2672 2732\nAcross all frames and measureme nts, the Joint Count lists the numb er of times a particular joint contained the\nhighest angle error, the Number of Frames counts the total number of unique frames which contained the highest\nangle error, the Max Frame # specifies which frame number contained the most frequent angle error, and the Max\nFrame Count is the number of times the correspon ding frame appeared.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.t00 5\nTable 6. Most frequen t axis containing the largest angle error across all subject measure ment variations.\nAxis Hip Knee Ankle\nRight X 27 1 7025\nY 0 8333 1747\nZ 9200 28 1133\nLeft X 0 0 60\nY 675 265 0\nZ 63 1338 0\nThe total number of times that each axis was recorded containing the largest joint angle error across all subject\nmeasureme nt variations. A breakdown of these values can be seen in S2 File.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.t00 6\nFig 11. Impleme ntation of Harrington method. The use of a keyword setting Harrington to True activates the if\nstatement to use the Harrington Hip Regression Method.\nhttps://d oi.org/10.1371/j ournal.pon e.0189984.g0 11\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 16 / 24\nWhile many alternatives and modified versions of the CGM exist, this paper focuses on\nVicon’s CGM implementation via the plug-in-gait modeler distributed in Vicon Nexus soft-\nware [10] due to the large number of studies and laboratories that utilize it. As this implemen-\ntation is based on direct kinematics and uses a single static calibration file, the computation\ntime can easily be reduced through parallelization, an aspect that has been largely left out of\ndiscussions on joint kinematics models.\nThe choice to implement the CGM in Python was made primarily due to the portability\nbetween operating systems and the wide acceptance of Python for scripting purposes in the\nscientific community [38]. The interpreted language and easily understood syntax continues\nto promote the open source aspect of the work.\nAs much of the data reported in the literature is focused on the lower body (due to a focus\non gait), this paper focused on the lower body. While the upper body has been developed in\npyCGM and is included in the computational time, the lack of data relating to marker place-\nment and skin deformation of the upper body makes it difficult to compare the significance of\nsubject measurement errors.\nFig 12. Impleme ntation using knee medial marker. If a Medial marker is detected, the code will use it to determine the knee joint center and axis.\nhttps://do i.org/10.1371/j ournal.pon e.0189984.g0 12\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 17 / 24\n4.2 Kinematic validation\nThere was a strong agreement between pyCGM and Vicon CGM joint kinematic outputs,\nconfirming a correct implementation of the CGM. Small differences observed may be due to\nnumerical implementation differences or rounding differences. Importantly, in the Vicon\nCGM, the method used to compute the knee and ankle joint center is unclear; however, here,\nan exact formulation based on the Rodrigues rotation formula [37] is presented. Moreover,\nthe original work of Kadaba [12] specifies the use of the arcsin function which would result\nin erroneous joint angles during motions greater than 90 degrees. In the pyCGM code, the arc-\ntan function is used to solve this problem. It is likely that a similar correction is coded into the\nVicon CGM; however, the “black box” nature of the software makes exploration of its underly-\ning code impossible. The flexibility of python and straightforward code of pyCGM allows\nresearchers to easily view, modify, and expand the CGM.\n4.3 Computation performance\nThe non-optimized Direct Kinematic (DK) method allows for a frame-by-frame calculation\nfor joint kinematics and, as such, provides an opportunity for easy HPC implementation to\nassist in the kinematic processing. Similarly, the portability and modularity provided by\npyCGM allows researchers to quickly modify the parameters of the model and distribute work-\nloads of either frame-by-frame or trial-to-trial calculations to an HPC. These calculation times\nare dramatically improved by moving from a classical desktop setup to an HPC, as detailed in\nthe results section.\nAs a stand-alone compiled program, comparison against Nexus also demonstrates the real\nspeed benefit of parallelization as the interpreted python code is significantly faster than the\ncompiled code of Nexus. At the same time, under utilizing the parallelized methods by reduc-\ning the number of cores used has an adverse effect on computation time. While the HPC is\norders of magnitude faster than Nexus when using multiple nodes, the use of only 1 core\nshows significantly slower processing times. This is attributed to the lower clock speed of pro-\ncessors containing large numbers of cores.\nHowever, challenges exist for the type of large databases of motion capture data that can\nfully take advantage of HPC. The first is the need to improve the ability to track people in an\nefficient way. While devices such as the Microsoft Kinect may allow for cheaper 3D recon-\nstructions, a more relevant advancement would be the replacement of reflective markers and\ninfrared cameras with a regular RGB camera with tracking markers, such as QR tags, that\ncan be easily implemented on-site in a variety of cases while taking advantage of the research\nalready done on joint landmark kinematic calculations. In the laboratory, more robust gap-fill-\ning and auto-labeling technology using the current motion capture systems would also greatly\nimprove the efficiency and bring the use of HPC to a more common audience.\n4.4 Subject measurement error\nThe primary, or axis of most importance during an analysis, such as knee flexion during a\nsquat motion, is central to understanding the importance of subject measurements. As seen in\nthe experimental data, during a squat motion the flexion axis in both left and right knee axis\nwere almost never the source of the largest error. As such, while subject measurements have an\neffect on joint angles, hip and knee flexion are the least affected and may still provide the most\nvalid results. The percentages of error displayed in Table 4 are based on the data found in [23]\nin which the maximum deviation from 7 laboratories in leg length measurements was 25 mm,\nknee diameter of 5 mm, and ankle diameter of 10 mm.\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 18 / 24\nWhile accurate subject measurements are required for the CGM, the importance of these\nmeasurements should be considered within the context of other possible sources of angle\nerror. In [39], 10 mm of marker placement error resulted in 6.2 degrees of error in knee rota-\ntion and 7.6 degrees in ankle rotation. Comparatively, the 10% change in knee width shown\nin Table 4 translates to 10.5 mm. This results in a 2.0 degree error in knee rotation and a 3.8\ndegree error in ankle flexion. While the kinematic model and subject motion from [39] slightly\nvary from those used in this research, this comparison should give researchers a basis for deter-\nmining both which aspects of subject preparation are most vital and which aspects of the CGM\nnew models should overcome. In a more general sense, the results suggest that subject mea-\nsurements can have a significant impact on joint angles. For example, a 50 mm error (5%) in\nthe measurement of leg length, results in over 3 degrees of hip rotation error). In practice, such\na large error in leg length may not be likely for experienced users of the CGM (c.f [23] where\n25 mm was observed across laboratories), suggesting that more attention should be given to\nmarker placement. Subject measurement errors within the range observed by [23] result in\nclinically negligible angle errors (less than 2 degrees) [40].\n4.5 CGM modifications\nPast work has shown that rather than completely new models, modifications to existing mod-\nels provide familiarity and improved accuracy. In [22], the knee joint center estimation was\nimproved by using medial markers. This method was easily integrated into the pyCGM code\nby adding 18 lines of code directly in the knee joint calculation function with no removal\nor other modifications necessary as the code switches to this method when medial knee\nmarkers are detected. Although this method requires additional markers, the overall marker\nset remains the same. Without additional markers, the hip joint center estimation can be\nimproved with the Harrington method [41]. This method has been implemented through 9\nlines of code in the hip axis calculation, 5 lines of code in the static calibration, and 1 line of\ncode in the execution file which acts as the argument to switch between hip joint center meth-\nods. Likewise, [42] shows an improved knee joint center through the adjustment of the thigh\noffset. Given the open-source nature of pyCGM, interested users could implement this change\nin the future.\n4.6 Future directions\nThe numerous studies for validating the results during gait, the wide usage, and the deep\nunderstanding of the model [43] remain important standards for the CGM. In a large field in\nwhich multiple methods for calculating joint kinematics are possible, the use of standards for\nvalidated models is of great importance.\nSince the creation of the original CGM, new methods for computing joint kinematics have\nbeen introduced, with the most relevant works modifying the CGM to be used with kinematic\nfitting and optimizations. C-motion Visual 3D offers a version of the CGM that uses optimiza-\ntion methods through inverse kinematics [44]. Likewise, methods such as the optimized lower-\nlimb gait analysis (OLGA) use inverse kinematics by global optimization [3]. However, these\nmethods often have implications for computational complexity, as in the case of OLGA, in\nwhich more than 50 frames of data are required to be considered for good convergence [4],\nmaking parallelization a more complex task and the overall computation time much larger.\nFurthermore, the use of inverse kinematics over direct kinematics is not a guarantee for more\naccurate results, as research has found that the anatomical model used in the study has a greater\neffect on kinematics than the different computational methods [5]. Similarly, 6 DOF models\nsuch as CAST have also been introduced [6]. However, there is not a strong argument for the\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 19 / 24\nuse of this model, as similar issues with the CGM exist in CAST [7]. Likewise, the CGM is not\nwithout critics and drawbacks, however; as models aim to improve the accuracy of joint angle\ncalculations over the CGM, the effect of subject measurements in errors must be understood.\nBeyond the work presented here, there is a need for new computational models to take into\naccount spatial and time complexity, as these are directly related to the impact and implemen-\ntation possibilities throughout the biomedical industry and other fields. Real-time algorithms\nfor single subject analysis have been developed, which creates implications for clinician-patient\ninteraction [45]. When considering least squares optimization and regression-based methods\nin the dynamic trial calculation, it is not possible to implement real-time calculations, some-\nthing that may be useful in a clinical setting for doctor-patient interaction. At the same time,\nthese methods may benefit from HPC when parallelization or distribution is possible. Addi-\ntionally, the number of markers being recorded has a significant impact on the storage\nrequired for these large datasets, hindering data sharing and distribution. However, further\nresearch into the actual computational time increase required by optimization methods would\nhelp define these limitations.\nApplications for computation of large databases of motion capture data extend from bio-\nmechanics and robotics to other, less obviously related fields, such as architecture. In architec-\nture, understanding human movement and movement abilities is important for design and\nnecessary in order to move from prescriptive to performative design criteria [46]. In general,\nany field relying on interactions with humans and movement will at some point need to\naddress the computational efficiency of large scale calculations for analysis.\nFinally, further work involving subject measurements in the CGM can shed light on how\nsignificant other measurements beyond leg length, knee width, and ankle width are. This may\nalso lead to the ability for subject measurements to be derived directly from marker locations\nduring the static calibration, which would remove the need for storing patient specific data\nwhile maintaining a reasonable margin of error.\nSupporting information\nS1 Fig. Joint center calculation of the knee. For the knee joint center, the calculation is from\nthe thigh marker (a), hip joint center (b), and knee marker (c). The intent is to find the plane\nin which all markers lay, with half the knee width (kw) being used in the calculation.\n(TIF)\nS2 Fig. Sample code of pyCGM. The python code provides comparison between the mathe-\nmatics and code that is easy to read and understand. The function receives three marker posi-\ntions and half of the knee width measurement. The return value is the cartesian location of the\ncalculated joint center. Ease of understanding the code is an important aspect of pyCGM, and\nas such, the steps are divided clearly so that users can both understand and modify the code to\nsuit their needs.\n(TIF)\nS3 Fig. Flexion beyond 90 degrees using arcsin and arctan. Motion capture data of a sitting\nmotion in which the Knee bends to 90 degrees. While this function was intended for use in\ngaits that would not commonly have a 90 degree flexion, the widespread use of the CGM\nincludes researchers using it for purposes beyond typical gait.\n(TIF)\nS1 Equation. Equation of the knee joint calculation using Rodrigues rotation formula.\n(PDF)\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 20 / 24\nS1 Table. Results of single dynamic trial scaled on HPC. The Sum column is the sum of the\ntimes required for each step in the calculation process. The Total column is the recorded start\nto finish time, with the difference shown in the last column. This difference includes commu-\nnication time between cores and nodes, as can be seen from the increased difference when the\ncalculation moved from 1 node to 2 nodes.\n(PDF)\nS2 Table. Computational performance of kinematic calculations for multiple variations of\na dynamic trial on the HPC. The average, maximum, and minimum times for each core to\ncomplete the calculations are shown. Additionally, the longest time for any core to complete\nall calculations is shown. Loading data was all done on the initial core. Saving the results,\ndynamic trial calculation, and static trial calculation times are from every core. The sum of\nthese calculations and the total time recorded from the first node differ mostly due to data\ntransfer between nodes.\n(PDF)\nS1 File. Output from the HPC.\n(ZIP)\nS2 File. Breakdown of subject measurement errors.\n(XLSX)\nAcknowledgmen ts\nThe author would like to thank Dr. Robert G. Van Wesep for his assistance in technical issues\nwith the implementation on the high performance computer, Seungeun Yeon for her active\ndevelopment in pyCGM and assistance with early versions of the research, and the many\ninterns that have provided contributions to the code throughout its development. Addition-\nally, the authors thank the University of Michigan Digital Media Commons for their resources\nand assistance in developing figures.\nThis material is based upon work performed using computational resources supported by\nthe University of Tennessee and Oak Ridge National Laboratory’s Joint Institute for Computa-\ntional Sciences (http://www.jics.utk.edu). Any opinions, findings, and conclusions or recom-\nmendations expressed in this material are those of the author(s) and do not necessarily reflect\nthe views of the University of Tennessee, Oak Ridge National Laboratory, or the Joint Institute\nfor Computational Sciences.\nAuthor Contributions\nConceptualization: Mathew Schwartz.\nInvestigation: Mathew Schwartz.\nMethodology: Mathew Schwartz.\nSoftware: Mathew Schwartz, Philippe C. Dixon.\nValidation: Philippe C. Dixon.\nWriting – original draft: Mathew Schwartz.\nWriting – review & editing: Mathew Schwartz, Philippe C. Dixon.\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 21 / 24\nReferences\n1. Baker R. The history of gait analysis before the advent of modern computers. Gait Posture . 2007; 26\n(3):331–24 2. https://do i.org/10.1016 /j.gaitpo st.2006.10.0 14\n2. Lewis JL, Lew WD. A note on the description of articula ting joint motion. Journal of Biomecha nics. 1977;\n10(10):675 –678. https:// doi.org/10.10 16/0021 -9290(77)90067 -7\n3. Roren L, Tate P. A new lower body model using global optimisat ion techniques . Gait Posture. 2002; 16\n(Suppl 1):S14–5.\n4. Charlton IW, Tate P, Smyth P, Roren L. Repeatabi lity of an optimised lower body model. Gait and Pos-\nture. 2004; 20(2):213– 221. https://doi.or g/10.101 6/j.gaitpost .2003.09.004\n5. Kainz H, Modenese L, Lloyd D, Maine S, Walsh J, Carty C. Joint kinematic calculation based on clinical\ndirect kinematic versus inverse kinematic gait models (Ms. Ref. No.: BM-D-15 -00779 Rev. 1). Journal\nof Biomecha nics. 2016; p. 1–12.\n6. Cappozz o a, Catani F, Della Croce U, Leardini a. Position and orietnat ion in space of bones during\nmovemen t. Clin Biomech. 1995; 10(4):171 –178.\n7. Collins TD, Ghoussa yni SN, Ewins DJ, Kent JA. A six degrees -of-freedom marker set for gait analysis:\nrepeatability and comparison with a modified Helen Hayes set. Gait & posture. 2009; 30(2):173– 80.\nhttps://doi.or g/10.101 6/j.gaitpos t.2009.04. 004\n8. Kadaba M, Ramakrishnan H, Wootten M, Gainey J, Gorton G, Cochran G. Repeatabi lity of kinematic ,\nkinetic, and electromyog raphic data in normal adult gait. Journal of Orthopaed ic Researc h. 1989; 7\n(6):849–86 0. https://do i.org/10.1002 /jor.1100070 611\n9. Plug-in Gait manual v1; Accessed, Aug 22nd 2014. Available from: http://www.irc- web.co .jp.\n10. Nexus; 2014. Available from: https://www .vicon.com /download s/core-softwar e/nexus/ nexus-185-\ninstaller.\n11. Sutherland DH. The evolution of clinical gait analysis. Part II Kinema tics. Gait Posture. 2002; 16\n(2):159–79 .\n12. Kadaba MP, Ramakrishnan HK, Wootten ME. Measurem ent of lower extremity kinematics during level\nwalking. Journal of orthop aedic research : official publicati on of the Orthopaed ic Researc h Society.\n1990; 8(3):383–9 2. https://doi.or g/10.1002/jor .110008 0310\n13. Grood ES, Suntay WJ. A joint coordinate system for the clinical descriptio n of three-dimens ional\nmotions: applicati on to the knee. Journal of biomechan ical engine ering. 1983; 105(2):136 –44. https://\ndoi.org/10.11 15/1.3138397\n14. Groen BE, Geurts M, Nienhuis B, Duysen s J. Sensitivity of the OLGA and VCM models to erroneous\nmarker placement: Effects on 3D-gait kinematics. Gait and Posture . 2012; 35(3):517– 521. https:/ /doi.\norg/10.1016/ j.gaitpost.2 011.11.019\n15. Gorton GE, Hebert DA, Gannotti ME. Assessme nt of the kinematic variabi lity among 12 motion analysis\nlaboratorie s. Gait and Posture . 2009; 29(3):398– 402. https:/ /doi.org/10.10 16/j.gai tpost.2008.1 0.060\n16. France L, Nester C. Effect of errors in the identifica tion of anatomical landmar ks on the accuracy of Q\nangle values. Clinical biomechan ics (Bristol, Avon). 2001; 16(8):710– 3. https:// doi.org/10.10 16/S0268-\n0033(01)0 0045-6\n17. Lu TW, O’Connor JJ. Bone position estimat ion from skin marker co-ordinat es using global optimisat ion\nwith joint constraints. Journal of Biomechan ics. 1999; 32(2):129– 134. https://doi.or g/10.101 6/S0021-\n9290(98)0 0158-4\n18. Holden JP, Orsini JA, Siegel KL, Kepple TM, Gerber LH, Stanho pe SJ. Surface movement errors in\nshank kinematics and knee kinetics during gait. Gait and Posture . 1997; 5(3):217–2 27. https:/ /doi.org/\n10.1016/ S0966-636 2(96)0108 8-0\n19. Leardini A, Chiari A, Della Croce U, Cappozz o A. Human moveme nt analysis using stereoph otogram-\nmetry Part 3. Soft tissue artifact assessmen t and compensation ; 2005.\n20. Davis RB, Ounpuu S, Tyburski D, Gage JR. A gait analysis data collection and reduction technique .\nHuman Movem ent Science. 1991; 10(5):575– 587. https://do i.org/10.1016 /0167-9457( 91)90046- Z\n21. Harrington ZABLS EYZTT M E. Prediction of the hip joint centre in adults, childre n, and patients with\ncerebral palsy based on magnetic resonan ce imaging . Journal of Biomecha nics. 2007; 40(3):595– 602.\nhttps://doi.or g/10.101 6/j.jbiome ch.2006.02. 003\n22. Stief F, Bo ¨ hm H, Michel K, Schwirtz A, Do ¨ derlein L. Reliabili ty and accuracy in three-dimensio nal gait\nanalysis: a comparison of two lower body protocol s. Journal of applie d biomechan ics. 2013; 29(1):105–\n111. https://do i.org/10.1123 /jab.29.1 .105\n23. Benedetti MG, Merlo A, Leardini A. Inter-labor atory consist ency of gait analysis measuremen ts. Gait\nand Posture. 2013; 38(4):934– 939. https://doi. org/10.1016/j .gaitpost.20 13.04.02 2\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 22 / 24\n24. Bell G. Supercomp uters: The Amazing Race; 2015. MSR-TR-2015 -2. Availab le from: http://resea rch.\nmicrosoft.c om/apps/pub s/default.as px?id=2381 07.\n25. Park S, Park J. Effect of Heel Height and Speed on Gait, and the Relationshi p Among the Factors and\nGait Variables. J Ergon Soc Korea. 2016; 35(1):39–5 2.\n26. Bruijn SM, van Diee ¨ n JH, Meijer OG, Beek PJ. Statistical precision and sensitivity of measures of\ndynamic gait stability. Journal of neuroscie nce methods. 2009; 178(2):327 –333. https://doi.or g/10.\n1016/j.jneum eth.2008 .12.015\n27. Kurihara K, Hoshino S, Yamane K, Nakamu ra Y. Optical motion capture system with pan-tilt camera\ntracking and real time data processing . In: Proceedings 2002 IEEE International Conferen ce on Robot-\nics and Automatio n (Cat. No.02C H37292). vol. 2. IEEE; 2002. p. 1241–1248. Available from: http://\nieeexplore.ie ee.org /lpdocs/epic0 3/wrappe r.htm?arnu mber=1014 713.\n28. Delp SL, Anderson FC, Arnold AS, Loan P, Habib A, John CT, et al. OpenSim: Open-sour ce software to\ncreate and analyze dynamic simulation s of moveme nt. IEEE Transaction s on Biomed ical Engineeri ng.\n2007; 54(11):194 0–1950 . https://doi.or g/10.110 9/TBME.20 07.901024\n29. Barre A, Armand S. Biomecha nical ToolKit: Open-sour ce framework to visualize and process bio-\nmechanical data. Computer methods and programs in biomedicin e. 2014; 114(1):80– 7. https://doi. org/\n10.1016/ j.cmpb.2014 .01.012\n30. Barre A, Turcot K, Bonnef oy-Mazure A, Armand S, Ferrari A, et Al, et al. Comparison of biomechan ical\ngait models with the open-sourc e biomechan ical toolkit (BTK): Preliminar y results. Gait & Posture .\n2014; 39:S73 –S74.\n31. Nakaoka S, Nakazawa A, Kanehiro F, Kaneko K, Morisaw a M, Ikeuchi K. Task model of lower body\nmotion for a biped humanoid robot to imitate human dances. In: 2005 IEEE/RS J Interna tional Confer-\nence on Intelligent Robots and System s. IEEE; 2005. p. 3157–3162. Available from: http://ieee xplore.\nieee.org/lpd ocs/epic 03/wrapper.ht m?arnumb er=1545395.\n32. Pollard NS, Hodgins JK, Riley MJ, Atkeson CG. Adapting human motion for the control of a humanoi d\nrobot. In: Procee dings 2002 IEEE Internat ional Conference on Robotics and Automatio n (Cat.\nNo.02CH37 292). vol. 2. IEEE; 2002. p. 1390–1 397. Available from: http://ieee xplore.ieee.or g/lpdocs/\nepic03/wra pper.htm? arnumber= 1014737.\n33. Yamane K, Hodgins J. Simultan eous tracking and balancing of humanoid robots for imitating human\nmotion capture data. In: 2009 IEEE/RS J International Conferen ce on Intellig ent Robots and System s.\nIEEE; 2009. p. 2510–2 517. Available from: http://ieee xplore.ieee.or g/lpdocs/ep ic03/w rapper.htm?\narnumbe r=5354750.\n34. Wojtusch J, von Stryk O. HuMoD—A versatile and open database for the investigatio n, modelin g and\nsimulation of human motion dynamic s on actuation level. In: 2015 IEEE-RAS 15th Internat ional Confer-\nence on Humanoid Robots (Humanoid s). IEEE; 2015. p. 74–79. Available from: http://ieee xplore.ieee.\norg/lpdocs /epic03/wra pper.htm? arnumber= 7363534.\n35. Jackson KR, Ramakr ishnan L, Muriki K, Canon S, Cholia S, Shalf J, et al. Performanc e Analysis of High\nPerformanc e Computing Applica tions on the Amazon Web Services Cloud. In: 2010 IEEE Second Inter-\nnational Conferen ce on Cloud Computing Technolo gy and Science. IEEE; 2010. p. 159–168. Availab le\nfrom: http://ieeexp lore.ieee.or g/lpdocs/ep ic03/wrapp er.htm?ar number=57 08447.\n36. Schwartz M. pyCGM; 2016. Available from: https:// github.com/cad op/pyC GM.\n37. Cheng H, Gupta KC. An historical note on finite rotations . Journal of Applied Mechanic s. 1989; 56\n(1):139–14 5. https://do i.org/10.1115 /1.31760 34\n38. Langtangen HP. Python scripting for computat ional science. vol. 3. Springer; 2006.\n39. Osis ST, Hettinga BA, Macdonald S, Ferber R, GG 3rd, Hebert D, et al. Effects of Simulated Marker\nPlacemen t Deviations on Running Kinema tics and Evaluation of a Morpho metric-Bas ed Placemen t\nFeedback Method. PLOS ONE. 2016; 11(1):e01 47111. https://doi.or g/10.137 1/journal.po ne.0147111\n40. McGinley JL, Baker R, Wolfe R, Morris ME. The reliability of three-dimens ional kinematic gait measure-\nments: A systematic review. Gait and Posture . 2009; 29(3):360– 369. https:// doi.org/10.10 16/j.gait post.\n2008.09. 003\n41. Parker K, Stebbins J, Bates J. Comparing the Harringt on and Davis method of hip joint centre localisa-\ntion for unimpai red and pathological subjects. Gait & Posture . 2014; 39:S114– S115. https://doi.or g/10.\n1016/j.gait post.2014.0 4.158\n42. Baker R, Finney L, Orr J. A new approach to determine the hip rotatio n profile from clinical gait analysis\ndata. Huma n Movement Science. 1999; 18(5):655– 667. https://doi.or g/10.1016/ S0167-945 7(99)\n00027-5\n43. Baker R. Measurin g walking: a handbook of clinical gait analysis. Hart Hilary M, editor. Mac Keith\nPress; 2013.\n44. C-Motion. Visual 3D;. Availab le from: https://ww w.c-motion.c om/v3dwik i/index.php ?title=T.\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 23 / 24\n45. Van den Bogert AJ, Geijtenbe ek T, Even-Zo har O, Steenbrink F, Hardin EC. A real-time system for bio-\nmechanical analysis of human movement and muscle function. Medical & biological engineerin g & com-\nputing. 2013; 51(10):106 9–1077. https://doi.o rg/10.1007/s11 517-013-10 76-z\n46. Schwartz M. Collaborat ive and Human Based Perform ance Analysis. In: eCAADe: Models of Computa-\ntion—Human Factors. vol. 2. Delft: Faculty of Archite cture, Delft University of Technology ; 2013. p.\n365–374.\nHigh performanc e computing of the convention al gait model\nPLOS ONE | https://doi.or g/10.137 1/journal.po ne.01899 84 January 2, 2018 24 / 24"
}