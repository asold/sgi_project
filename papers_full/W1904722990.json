{
  "title": "Engineering Modelling Languages: A Precise Meta-Modelling Approach",
  "url": "https://openalex.org/W1904722990",
  "year": 2010,
  "authors": [
    {
      "id": "https://openalex.org/A2106049995",
      "name": "Tony Clark",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2096223093",
      "name": "Andy Evans",
      "affiliations": [
        "University of York"
      ]
    },
    {
      "id": "https://openalex.org/A2016158793",
      "name": "Stuart Kent",
      "affiliations": [
        "University of Kent"
      ]
    },
    {
      "id": "https://openalex.org/A2096223093",
      "name": "Andy Evans",
      "affiliations": [
        "University of York"
      ]
    },
    {
      "id": "https://openalex.org/A2016158793",
      "name": "Stuart Kent",
      "affiliations": []
    }
  ],
  "references": [
    "https://openalex.org/W2118255887",
    "https://openalex.org/W4233650756",
    "https://openalex.org/W4213290781",
    "https://openalex.org/W1980139253",
    "https://openalex.org/W4248425340",
    "https://openalex.org/W1998889043",
    "https://openalex.org/W4230342182",
    "https://openalex.org/W4229884746",
    "https://openalex.org/W91776631",
    "https://openalex.org/W1600288868",
    "https://openalex.org/W1495459135",
    "https://openalex.org/W1498369023",
    "https://openalex.org/W2139453480",
    "https://openalex.org/W1877477396",
    "https://openalex.org/W1518695183",
    "https://openalex.org/W569018205",
    "https://openalex.org/W1573083166",
    "https://openalex.org/W1574057703",
    "https://openalex.org/W1572116564",
    "https://openalex.org/W2513470175",
    "https://openalex.org/W2137684292"
  ],
  "abstract": null,
  "full_text": "R.-D. Kutsche and H. Weber (Eds.): FASE 2002, LNCS 2306, pp. 159-173, 2002.\n© Springer-Verlag Berlin Heidelberg 2002\n  Engineering Modelling  Languages:      \nA Precise Meta-Modelling Approach\nTony Clark11), Andy Evans 2) , and Stuart Kent 3)\n1) Department of Computer Science, King’s College London, UK                                   \nanclark@dcs.kcl.ac.uk\n2) Department of Computer Science, University of York, UK                                          \nandye@cs.york.ac.uk\n3) Computing Laboratory, University of Kent at Canterbury, UK              \ns.j.h.kent@ukc.ac.uk\nAbstract. MMF uses meta-modelling techniques to precisely define mod-\nelling languages. The approach employs novel technology based on pack-\nage specialisation and templates. MMF is being applied to the UML 2.0\nrevision initiative and is supported by a tool.\n1 Introduction\nThis paper describes a Meta-Modelling Framework (MMF) that addresses many of\nthe deficiencies in the current definition of The Unified Modeling Language (UML)\n[18]. The facility comprises a language (MML) for defining modelling notations, a\ntool (MMT) that checks and executes those definitions, and a method (MMM) con-\nsisting of a model based approach to language definition and a set of patterns\nembodying good practice in language definition. The development of MMF by the\npUML group ([14]) is ongoing and has been supported by IBM and Rational Inc.\nThe work reported in this paper is a simplified version of the work described in out\ninitial submission to the UML 2.0 revision initiative [13] [4] which is expected to be\ncompleted in 2002. This paper describes the components of MMF and uses them to\ndevelop a simple modelling language. \n1.1 A Method for Meta-Modelling (MMM)\nThe UML is a collection of notations, some visual some textual. These notations\ncurrently have a loose mapping to an abstract syntax (which is imprecisely defined),\nwhich in turn is given an informal semantics written in natural language. The UML\nneeds to become a precisely defined family of modelling languages, where a model-\nling language comprises a notation (concrete syntax), abstract syntax and semantics.\nSoftware Engineers define languages as a collection of models with mappings\nbetween them. Typically a language consists of models for concrete syntax, abstract\nsyntax and for the semantic domain. The MMF approach applies OO modelling to\nthe definition of OO modelling languages. Each language component is defined as a\npackage containing a class diagram. Package specialization is employed to support\n160 Tony Clark et al.\nreusable, modular, incremental language design. OCL [20] [15] is used to define\nwell-formedness constraints on the language components. Mappings between lan-\nguage components are defined in terms of OCL constraints on associations between\nmodel elements.\nThe MMF approach uses two key features of OO modelling technology:  package\nspecialization and templates. Package specialization permits (possible partial) defini-\ntions of model elements in a super-package to be consistently specialized in a sub-\npackage. Templates are parametric model elements; supplying model elements as\nparameter values stamps out the template to produce a fresh model element. Tem-\nplates provide a means of representing reusable modelling patterns; the MMF\napproach uses templates to capture patterns that occur repeatedly in OO modelling\nlanguages thereby providing a framework for defining language families.\nThis technology is not specific to MMF, UML has package specialization and para-\nmetric model elements and in particular the Catalysis approach [7] advocates the use\nof these features as part of an OO method. Algebraic specification languages such as\nClear and OBJ and abstract programming languages such as ML and Haskell provide\na means of constructing libraries of parametric components and organising systems\nby combining these components in different ways. However, MMF has provided the\nmost precise definition of these concepts within the scope of OO modelling to date.\n1.2 A Language for Meta-Modelling (MML)\nMML is a static OO modelling language that aims to be small, meta-circular and as\nconsistent as possible with UML 1.3. MML achieves parsimony by providing a small\nnumber of highly expressive orthogonal modelling features. The complete definition\nof MML is beyond the scope of this paper; the reader is directed to [2], [3] and [9] for\nan overview of the MMF approach, to [3] for the meta-circular definition of MML\nand to [5] and [6] for its formal definition. The rest of this section gives an overview\nof the main features of MML which are an OCL-like expression language; class def-\ninitions; package definitions and templates.\n1.2.1 A Basic Expression Language\nMML consists of a basic expression language which is based on OCL. The language\nprovides a basic collection of data types including integers, booleans and strings\ntogether with standard operations over values of these types.  MML supports sets and\nsequences together with a small number of standard OCL iteration constructs; the\nfollowing denotes 5 (the full list of iteration constructs is defined in [6]):\nSet{1,2,3}->select(x | x > 1)->iterate(y n = 0 | n + y)\n\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 161\n1.2.2 Class Definitions\nMML classes define the structure, behaviour and invariants of their instances. The \nfollowing defines a class of people.\nclass Person\nname : String; age : Integer; married : Boolean;\nchildren : Set(Person); parents : Set(Person);\ninit(s:Seq(Instance)):Person\n  self.name := s->at(0) []\n  self.age := s->at(1) []\n  self;\naverageChildAge():Integer\n  self.children->iterate(c a=0 | a+c.age)/self.children->size;\ninv\n  IfMarriedThenOver15 self.married implies self.age >= 16;\n  OnlyTwoParents self.parents->size = 2\nend\nThe definition of the class Person shows a number of MML features. In general, an\nMML definition consists of a name and an expression. A class definition introduces\na new name whose scope is the class definition and relative to the package in which\nthe class is defined using the ‘::’ operator, for example SomePackage::Person.\nA class has a number of attributes each of which is a definition consisting of a name\nand a type. A class definition has a number of method definitions each of which\nhave typed parameters, a return type and a body. The body of a method is an expres-\nsion which provides the return value when the method is called by sending an\ninstance of the class a message. The init method of a class is automatically invoked\nwhen a new instance of the class is created. A class definition has a number of\ninvariant constraint definitions following the keyword inv. Each constraint consists\nof a name and a boolean expression. The constraints express well formedness prop-\nerties of the instances of the class. For example, in order to be married a person must\nbe aged 16 or over.\n1.2.3 Association Definitions\nClasses may be associated to show logical dependency between instances of the\nclasses. Currently MML supports only binary associations. A binary association\nconsists of the two classes being associated, the name of the association and two\nassociation ends (one for each class). An association end is a definition consisting of\na name and a multiplicity. The multiplicity constraint the number of instances of the\nattached class that can be associated with an instance of the class attached to the\nother end. For example, suppose that the children and parents attributes of the Per-\nson class were defined via an association (at most 2 parents, but any number of chil-\ndren):\n162 Tony Clark et al.\nassociation Family\n  parents : Person mult: 2\n  children : Person mult: *\nend\n1.2.4 Package Definitions\nPackages are used in MML to group definitions of model elements. MML provides a\npowerful package specialization mechanism that allows packages to inherit from par-\nent packages and to consistently specialize all of the inherited contents. For example:\npackage People\n  class Person\n     // as given above\n  end;\n  association Family \n    // as given above\n  end\nend\nNote that the association Family refers to the class Person as defined in the package\nPeople. Now, suppose that we want to extend the notion of being a person with an\nemployer:\npackage Employment extends People\n  class Person yearsInService : Integer end;\n  class Company name : String end;\n  association Works\n    company : Company mult: 1\n    employees : Person mult: *\n  end\nend\nThe package Employment extends the package People and therefore includes all of\nthe definitions from People. A package is a name space and we may refer to two dif-\nferent classes called Person: People::Person and Employment::Person. Employ-\nment::Person contains all the definitions from People::Person extended with a new\nattribute named yearsInService. A package may only contain one definition with any\ngiven name. Therefore the association named Family in the package Employment\nmust refer to the extended definition of Person. All definitions given by People have\nbeen consistently extended  in Employment. The notion of consistent extension for\nmodel elements defined in a package is similar to the idea of virtual methods in C++.\nPackage specialization supports multiple inheritance. Packages may be nested in\nwhich case the for package specialization outlined above hold for the nested pack-\nages.\n1.2.5 Templates\nA template is a parametric model element. When parameters are supplied to the tem-\nplate the result is a new model element. The supplied parameter values are model ele-\nments that are used by the template to construct, or  stamp out , the new model\nelement. Templates are used to capture patterns of recurring structure, behaviour and\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 163\nconstraints that occur in models. Templates differ from specialization, which also\ncaptures patterns, in that there is no dependency between the template and the result\nof stamping it out. Specialization captures patterns in terms of (abstract) model ele-\nments that are specialized rather than stamped out. The process of specialization can\nlead to dependencies both between a super-model element and its sub-model ele-\nments and can also lead to sibling dependencies between different sub-model ele-\nments. Templates are not a replacement for specialization; they offer a new tool to\nthe modeller that should be used where appropriate.\nSuppose that we wish to capture the notion of containment. This involves two\nclasses: a container and a contained element. Suppose also that all containers pro-\nvide access to their contained elements via a method with the same name as the con-\ntained element class. Finally, suppose that we know all contained elements are\nnamed and that the container cannot contain two different elements with the same\nname. This can be expressed as a template in MML:\npackage Contains(Container,n1,m1,Contained,n2,m2)\n  class <<Container>>\n    <<n2>>():Set(<<Contained>>) self.<<n2>>\n    inv\n      <<“Every” + Contained + “HasADifferentName”>>\n        self.<<n2>>->forAll(c1 c2 | c1.name = c2.name implies c1 = c2)\n  end;\n  association <<Container + Contains>>\n    <<n1>> : <<Container>> mult: <<m1>>\n    <<n2>> : <<Contained>> mult: <<m2>>\n  end\nend\nThe package template Contains is defined to have six parameters. Container is the\nname of the container class, Contained is the name of the contained element class,\nn1 is the name used by an instance of the contained class to refer to its container and\nn2 is the name used by an instance of the container class to refer to its contents. The\nparameters m1 and m2 are the appropriate multiplicities for the containment.\nThroughout the body of the template definition literal names may be turned into\nexpressions that are evaluated by enclosing them in << and >>. The names are sup-\nplied as strings and therefore the string concatenation operator + is used to construct\nnew names. Suppose that we wish to express the containment relationship between\na person and their children:\npackage People\n extends Container(“Person”,”children”,*,”Person”,”parents”,2)\n class Person ...atribute and method definitions... end\nend\nStamping out the container template produces a new package that can be used as the\nparent package of People. Defining the parents and children attributes this way has\nnot saved much effort, however the template can be reused when defining the\nEmployment package:\n164 Tony Clark et al.\npackage Employment\n extends Companies, People, \n  Container(“Company”,”employees”,*,”Person”,”employer”,1)\nend\n1.3 A Tool for Meta-Modelling (MMT)\nMMT is a prototype tool written in Java that supports the MMF approach. MMT con-\nsists of a virtual machine that runs the MML calculus which is a simple object-based\ncalculus that supports higher order functions. All the MML examples contained in\nthis paper are derived from MML code running on MMT (some slight simplifications\nhave been applied). MMT defines MML by loading a collection of meta-circular\nboot files written in MML.  The definitions in this paper have been loaded and\nchecked in MMT which provides a flexible environment for inspecting and flattening\ndefinitions of packages and classes. A full description of MMT is outside the scope\nof this paper.\n2 The Definition of a Simple Modelling Language\nSML is a static modelling language that consists of packages and classes with\nattributes. Packages can contain both packages and classes. Classes contain\nattributes. An attribute has a name and a type. SML supports inheritance: packages\nmay have super-packages, classes may have super-classes and attributes may have\nsuper-attributes. The meaning of SML package models is given by snapshots that\ncontain objects. Each object is a container of slots which are named values. A pack-\nage is a classifier for snapshots that contain sub-snapshots and objects corresponding\nto the packages and classes in the package. The structure of the syntax, semantic\ndomain and semantic mapping for SML follows standard patterns that occur in mod-\nelling languages. The following sections show how these patterns can be captured as\ntemplates and then how SML can be defined by stamping out the templates. \n2.1 Templates for SML Definition\n2.1.1 Named Model Elements\nMost modelling elements in SML are named. Like Java, MMT makes use of a\ntoString method when displaying objects:\npackage Named(Model)\n   class <<Model>>\n     name : String;\n     toString():String\n       \"<\" + self.of.name + self.name + \">\"\n   end\nend\n2.1.2 Cloning Model Elements\nPackages may have parents. A child package is defined to contain all the model ele-\nments defined by the parent package. A given model element is defined in a single\nname space; a package provides the name space for all of its elements. Therefore,\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 165\nwhen a model element is inherited from a parent package, the element must be cop-\nied and the containing name space must be updated to be the child package. The\nprocess of inheriting a copy of a model element and updating its containing name\nspace is referred to as cloning. The cloning pattern occurs in two distinct stages: (1)\na model element is shallow copied (no copying of slots) and the containing name\nspace is updated; (2) the slots are copied. \npackage Clonable(Container,Contained)\n   class <<Contained>>\n     clone(nameSpace:<<Container>>):<<Container>>\n       let o = self.copy()\n           ms = self.of.allMethods()\n           cs = ms->select(m | m.name = \"cloneAux\")\n       in o.<<Container>> := nameSpace []\n          cs->collect(m | (m.body)(o,nameSpace)) [] o\n       end\n   end\nend\nThe Clonable template is defined above and is used to declare a clonable model ele-\nment. The definition uses knowledge about the MML meta-level in order to copy an\ninstance of the container class. Every object has a method named ‘copy’ that pro-\nduces a shallow copy of the receiver. The template updates the value of the con-\ntainer to be the name space supplied to ‘clone’ and then invokes all of the methods\ndefined by the container class named ‘cloneAux’. Each method will deal with copy-\ning the slots of the new object ‘o’.\n2.1.3 Name Spaces\nclass <<Container>>\n  <<\"locallyDefines\"+Contained>>(name:String):Boolean\n    self.<<Contained+\"s\">>()->exists(m | m.name = name);\n  <<\"localLookup\"+Contained>>(name:String):Set(<<Contained>>)\n    self.<<Contained+\"s\">>()->select(m | m.name = name);\n  <<\"defines\"+Contained>>(name:String):Boolean\n    self.<<\"all\"+Contained+\"s\">>()->exists(m | m.name = name);\n  <<\"lookup\"+Contained>>(name:String):<<Contained>>\n    if self.<<\"locallyDefines\"+Contained>>(name)\n    then self.<<\"localLookup\"+Contained>>(name).selectElement()\n    else if self.<<\"defines\"+Contained>>(name)\n         then self.<<\"all\"+Contained+\"s\">>()->select(m | \n           m.name = name).selectElement()\n         else state.error(\"NameSpace::lookup\")\n         endif\n    endif\nend\nA name space is a container of named model elements that provides a protocol for\naccessing the elements by name. The template defined above is a simple notion of\nname space in which contained elements are assumed to own their own names. The\ntemplate defines a name space lookup protocol involving local lookup and inherited\nlookup. The template therefore represents a mixin that requires the container to\n166 Tony Clark et al.\ndefine a pair of methods for the contained elements that returns the local contains and\nthe inherited contents.\n2.1.4 Containers\npackage Contains(Container,Contained)\n   class <<Container>> \n     <<Contained + \"s\">>():Set(<<Contained>>)\n       self.<<Contained + \"s\">>\n     cloneAux(me:<<Container>>,nameSpace:<<Container>>)\n       me.<<Contained + \"s\">> := \n         (me.<<Contained + \"s\">>()->collect(x | \n           x.clone(nameSpace.<<\"lookup\" + Container>>(me.name))))\n       end;\n   association <<Container + Contained>>\n     <<Container>> : Contains::<<Container>> mult: 1\n     <<Contained + \"s\">> : Contains::<<Contained>> mult: *\n   end\nend\nMany model elements in SML contain other model elements. The contains template\ndefines a method for accessing the contained elements; providing method access\nallows the contained elements to be encapsulated. A variation of Contains is Self-\nContains which has a single parameter. SelfContains is used to express model ele-\nments that can contain other model elements of the same type. A root self container\ncontains itself; the method providing access to the contained elements of a self con-\ntainer removes the ‘self’ from the elements it returns (thereby satisfying the round\ntrip constraint and also preventing cycles occurring when processing the contained\nelements).\nThe template defines a method for cloning the contained elements when a container\ninstance is cloned. The cloneAux method is supplied with the model element to clone\n(me) and the current name space (nameSpace) containing the model element. Each\ncontained element is passed its name space by looking up the appropriate model ele-\nment in nameSpace. In the absence of package specialization, the nameSpaces\npassed to model elements when they are cloned will be the appropriate copy of the\noriginal nameSpace container for the element. However, if a package is specialized,\nnameSpaces may be extended in which case the cloning mechanism will guarantee\nthat the most specific definition is supplied to clone as the containing name space.\n2.1.5 Specialization\npackage Specializable(Model)\n   class <<Model>>\n     parents : Set(<<Model>>);\n     allLocalParents() : Set(<<Model>>)\n       self.parents->iterate(parent P = self.parents |\n         P->union(parent.allLocalParents()))\n   end\n end\nIn SML packages may be extended to contain new definitions; classes can be\nextended to contain new attributes, methods and constraints. Specialization may\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 167\noccur explicitly when the modeller defines a package to extend a super-package or\ndefines a class to extend a super-class. Specialization may occur implicitly when the\ncontainer of a model element m specializes another container that defines a model\nelement m’ such that m and m’ have the same name.  Every specializable model ele-\nment must have a set of parents of the same type. The method allLocalParents is the\ntransitive closure of the parents relation.\nThe contents of a container are defined by its parents: the local parents, as defined\nabove, and any parents which are inherited from its own container:\nPackage P defines classes A and B and a binary association between them. The\nbinary association has ends named a and b causing two attributes to be added to the\nclasses at opposite ends of the association. Package Q defines two classes A and B\nwith an attribute and an operation respectively. Package P is the parent of package\nQ. In order to compute the attributes of Q::A we must first compute its parents. A\nhas no parents in Q but since the container of Q::A has parents we must inspect P in\norder to check whether it defines a class named A. We find it does and that P::A has\nan attributes named b. Therefore Q::A defines an attribute named b. The type of\nQ::A::b is a class called B which must be referenced with respect to the container of\nQ::A, namely Q. We find that Q defines Q::B and therefore the type of Q::A::b is\nQ::B. If we repeat this process for Q::B we find that Q::B defines Q::B::a whose\ntype is Q::A. If we flatten the package inheritance the result is as follows:\n\n168 Tony Clark et al.\nA specializable container requires both the container and the contained model ele-\nments to be specializable. The complete set of parents for the contained model ele-\nments are defined by computing both the local parents (the transitive closure of the\nparents relation) and the inherited parents via the container. The contents of a con-\ntainer are computed with respect to all parents of the container. The template for spe-\ncializable containers is:\npackage SpecializableContainer(Container,Contained)\n   extends Specializable(Container),Specializable(Contained)\n   class <<Container>>\n     <<\"all\" + Contained + \"s\">>() : Set(<<Contained>>)\n     self.allParents()->iterate(parent S = self.<<Contained+\"s\">>() |\n       S->union(parent.<<\"all\"+Contained+\"s\">>()->reject(c |\n         self.<<“locallyDefines + Contained>>(c.name))->collect(c |\n           c.clone(self))))\n     inv\n       <<Contained + “sHaveDifferentNames”>>\n       self.<<“all” + Contained + “s”>>()->forAll(c1 c2 | \n         c1.name = c2.name implies c1 = c2)\n   end;\n   class <<Contained>>\n     allParents() : Set(<<Contained>>)\n       self.allLocalParents()->union(self.allInheritedParents());\n     allInheritedParents() : Set(<<Contained>>)\n       if self.<<Container>> = self\n       then Set{}\n       else self.<<Container>>.allParents()->iterate(parent S = Set{} |\n         S->union(parent.<<\"all\"+Contained+\"s\">>()->select(m | \n           m.name = self.name)))\n       endif\n   end\n end\nAll the contained elements of a specializable container are constructed as follows.\nFirstly all the parents of the container are constructed (recall that the parents of a\nmodel element will include both the locally defined parents and the parents inherited\nfrom the container’s container). The locally defined contents are merged with the\ncontents of all the parents after removing any parent contents that are shadowed\nlocally. Finally, all inherited contents must be cloned in order that they are correctly\ncontained.\n2.1.6 Relations\npackage Relation(Name,Domain,Range)\n   class <<Name>>\n     left : <<Domain>>;\n     right : <<Range>>     \n   end\nend\nA relation has a name and holds between a class of domain elements and a class of\nrange elements. A relation is essentially an association class that defines a constraint\non pairs of domain and range instances.\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 169\n2.1.7 Instantiation\nA key feature of the MMF approach is the definition of modelling languages in\nterms of their abstract syntax and semantic domain. The abstract syntax is a model\nof the legal sentences of the language. The semantic domain is a model of the legal\nmeanings that sentences can take. A language definition is completed by a model of\nthe mapping between the abstract syntax and the semantic domain.\nThe relation between abstract syntax and semantic domain is referred to as instanti-\nation. In general the instantiation relation between a model element and its instances\nmay be aribitrary (expressions denote values, classes denote objects, state machines\ndenote filmstrips, etc). However, if we know the structure of the abstract syntax and\nsemantic domain then this places structure on the instantiation relationship. This\nstructure can be expressed as templates. \nConsider the following diagram:\nThe diagram shows a typical instantiation relationship between two containers\ncalled ContainsInstances1. The instantiable model elements are shown on the left of\nthe diagram and the instances are shown on the right. Elements of type A contain\nelements of type B and elements of type X contain elements of type Y. Elements of\ntype A have instances of  type X and elements of type B  have  instances of type Y.\nWe wish to express the instantiation constraint that in order for an X to be classified\nas an instance of an A (R1) every Y that the X contains must be an instance of some\nB that the A contains (R2).\nThis form of instantiation relationship occurs between packages and snapshots\nwhere every object in the snapshot must be an instance of some class in the package,\nhowever not all classes need to be instantiated in the snapshot. This relationship is\ndefined as a template:\npackage ContainsInstances1(\n    R1,ModelContainer,ModelContained,\n    R2,InstanceContainer,InstanceContained)\n  extends \n    Relation(R1,ModelContainer,InstanceContainer),\n    Relation(R2,ModelContained,InstanceContained)\n  class <<R1>>\n\n170 Tony Clark et al.\n   left : <<ModelContainer>>;\n   right : <<InstanceContainer>>\n   inv\n     <<\"InstancesOf\"+ModelContainer+\n             \"ContainsInstancesOf\"+ModelContained>>\n     self.right.<<InstanceContained + \"s\">>()->forAll(i | \n       self.left.<<\"all\" + ModelContained + \"s\">>()->exists(m |\n         <<R2>>.new(Seq{m,i}).check() = Set{}))\n  end\nend\nOther instantiation relationships are possible. For example, if we view slots as the\ninstances of attributes and objects as the instances of classes then classes contain\nattributes and objects contain slots. An object is a well formed instance of a class\nwhen all the attributes have instances. This relationship can be defined as a template\nwhich we will call ContainsInstances2. Finally, there is an instantiation relationship\nwhich is defined as follows:\npackage ContainsInstances(R1,A,B,R2,X,Y)\n  extends\n    ContainsInstances1(R1,A,B,R2,X,Y),\n    ContainsInstances2(R1,A,B,R2,X,Y)\nend\n2.1.8 Relationships between Attributes\npackage RelateAtt(R,Domain,Range,DomainAtt,RangeAtt,Pred)\n   extends Relation(R,Domain,Range)  \n   class <<R>>\n    inv\n      <<\"Relate\"+Domain+\"::\"+DomainAtt+\"To\"+Range+\"::\"+RangeAtt>>\n      Pred(self.left.<<DomainAtt>>,self.right.<<RangeAtt>>)\n   end\nend;\npackage SameName(R,Domain,Range)\n   extends RelateAtt(R,Domain,Range,\"name\",\"name\",=)\nend;\npackage TypeCorrect(R,Domain,Range)\n  extends RelateAtt(R,Domain,Range,\"type\",\"value\",check)\nend\nAn attribute relation involves a domain class and a range class. The relation specifies\nthe domain and range attributes that are to be associated and also specified the predi-\ncate that will be used to check the values of the attributes. The invariant constraint in\nRelateAtt simply applies the predicate to the values of the slots in domain and range\nobjects. SameName associates a domain and range object by requiring that they have\nthe same values for the slot ‘name’. In SML this constraint is required when associat-\ning the attributes of a class with the slots of an instance of the class. TypeCorrect\nassociates a domain class with an attribute named ‘type’ and a range class with an\nattribute named ‘value’. The predicate is satisfied when all the invariant constraints\nof the type return true for the value.\nEngineering Modelling Languages: A Precise Meta-Modelling Approach 171\n2.2 Definition of SML\nWe have described the MMF approach to language definition which is to model all\ncomponents of the languages and to employ object-oriented techniques to achieve\nmodularity and reuse. The previous section has used the novel technology of pack-\nage specialization and templates to define a library of modelling language patterns.\nThis section shows how the patterns can be used to construct a simple modelling\nlanguage called SML.\n2.2.1 Abstract Syntax\npackage AbstractSyntax\n  extends\n   SelfContains(\"Package\"), SpecializableContainer(\"Package\",\"Pack-\nage\"),\n   SpecializableContainer(\"Package\",\"Class\"),\n   SpecializableContainer(\"Class\",\"Attribute\"),\n   Specializable(\"Attribute\"),\n   Contains(\"Package\",\"Class\"), Contains(\"Class\",\"Attribute\"),\n   Clonable(\"Package\",\"Class\"), Clonable(\"Package\",\"Package\"),\n    Clonable(\"Class\",\"Attribute\"),\n   Named(\"Package\"), Named(\"Class\"), Named(\"Attribute\"),\n   NameSpace(\"Package\",\"Package\"), NameSpace(\"Package\",\"Class\"),\n   NameSpace(\"Class\",\"Attribute\")\n  class Attribute\n   type : Class\n   cloneAux(me:Attribute_,nameSpace:Class)\n     me.type := (nameSpace.Package.lookupClass(me.type.name))\n  end\nend\nThe definition of the abstract syntax model for SML is given above. It is interesting\nto note that the MMF approach achieves a declarative specification of the model in\nterms of its properties explicitly listed in the ‘extends’ clause for the package. For\nexample, we know that a package has the properties of a specializable container,\nthat a package contains both packages and classes, and so on. If we were to define\nthe abstract syntax as the result of flattening this definition, many of these properties\nwould be implicit and therefore difficult to extract.\n2.2.2 Semantic Domain\npackage SemanticDomain\n  extends\n    SelfContains(\"Snapshot\"), \n    Contains(\"Snapshot\",\"Object\"),Contains(\"Object\",\"Slot\"),\n    Named(\"Snapshot\"), Named(\"Slot\")\n  class Slot value : Object end\nend\nThe domain is much simpler than the abstract syntax model. In our work using tem-\nplates to define a UML 2.0 infrastructure we have a much richer semantic domain\n(for example, snapshots, objects and slots have parents). One of the benefits of the\n172 Tony Clark et al.\nMMF approach is that we can easily refactor the structure of a model in terms of its\nproperties by adding new templates to the ‘extends’ clause of the package.\n2.2.3 Semantic Mapping\npackage SemanticMapping\n  extends\n    AbstractSyntax, SemanticDomain,\n    ContainsInstances1(\n      \"PackXSnap\",\"Package\",\"Class\",\n      \"ClassXObj\",\"Snapshot\",\"Object\"),\n    ContainsInstances(\n      \"ClassXObj\",\"Class\",\"Attribute\",\n      \"AttXSlot\",\"Object\",\"Slot\"),\n    SameName(\"AttXSlot\",\"Attribute\",\"Slot\")\n    TypeCorrect(\"AttXSlot\",\"Attribute\",\"Slot\")\n end\nThe semantic mapping includes all of the elements from the abstract syntax and\nsemantic domain and then constructs relations between them. For example, the rela-\ntion PackXSnap is defined to check that every object contained in a snapshot is an\ninstance of some class in the corresponding package.\n3 Conclusion and Future Work\nThis paper has described the MMF approach to engineering Modelling Languages.\nThe approach separates the issues of how to model syntax and semantics domains\nand allows languages to be developed from modular units. The approach also sup-\nports reusable patterns for language engineering. The paper has illustrated the\napproach with a small modelling language. MMF aims to provide coherent methods,\ntechnology and tools for engineering modelling languages. The core technology is\nnot new, the methods for defining languages are well developed, the technology has\nits roots in Catalysis [7] and has been developed further in [5] and [8]. The novelty in\nMMF arises from bringing these otherwise disparate technologies together within a\nsingle consistent object-oriented framework. The MMF approach does not use a for-\nmal mathematical language to express the semantics of the languages; however, it is\nsufficiently expressive to support the infrastructure of these approaches and therefore\ncan benefit from many of the results such as [1]  and [17]. The MMT tool  is still\nunder development.  Other tools exist, such as Argo and USE [16] [11] that can be\nused to model languages; however, unlike MMT, these tools tend to have a fixed\nmeta-model.\nWe are applying the approach to the definition of rich and expressive visual model-\nling languages, such as [12] and [10]. In particular, the syntax employed in these dia-\ngrams is more sophisticated than that typically employed in UML. We are engaged in\nthe UML 2.0 revision process [4] [19], and using MML ideas to help redefine aspects\nof UML with one of the main submission teams. The interested reader is directed to\n[4] which contains many examples of templates in a diagram format. But perhaps our\nmost ambitious plans are in applying the MMF approach to realise the OMG MOdel\nDriven Architecture (MDA) initiative. \nEngineering Modelling Languages: A Precise Meta-Modelling Approach 173\nReferences\n[1] Bottoni P., Koch M., Parisi-Presicce F., Taentzer G. (2000) Consistency Checking and \nVisualization of OCL Constraints. In Evans A., Kent S., Selic B. (eds) UML 2000 pro-\nceedings volume 1939 LNCS, 278 -- 293 , Springer-Verlag.\n[2] Clark A., Evans A., Kent S. (2000) Profiles for Language Definition. Presented at the \nECOOP pUML Workshop, Nice.\n[3] Clark A., Evans A., Kent S, Cook S., Brodsky S.,  (2000) A feasibility Study in Rear-\nchitecting UML as a Family of Languages Using a Precise OO Meta-Modeling Ap-\nproach. Available at http://www.puml.org/mmt.zip.\n[4] Clark A., Evans A., Kent S. (2001) Initial submission to the UML 2.0 Infrastructure \nRFP. Available at http://www.cs.york.ac.uk/puml/papers/\numl2submission.pdf\n[5] Clark A., Evans A., Kent S. (2001) The Specification of a Reference Implementation \nfor UML. Special Issue of L'Objet on Object Modelling, 2001.\n[6] Clark A., Evans A., Kent S. (2001) The Meta-Modeling Language Calculus: Founda-\ntion Semantics for UML. ETAPS FASE Conference 2001, Genoa.\n[7] D'Souza D., Wills A. C. (1998) Object Components and Frameworks with UML -- The \nCatalysis Approach. Addison-Wesley.\n[8] D'Souza D., Sane A., Birchenough A. (1999) First-Class Extensibility for UML - Pack-\naging of Profiles, Stereotypes, Patterns. In France R. & Rumpe B. (eds) UML '99 pro-\nceedings volume 1723 LNCS, 265 -- 277, Springer-Verlag.\n[9] Evans A., Kent S. (1999) Core meta-modelling semantics of UML -- The pUML ap-\nproach. In France R. & Rumpe B. (eds) UML '99 proceedings volume 1723 LNCS, 140 \n-- 155, Springer-Verlag.\n[10] Howse J., Molina F., Kent S., Taylor J. (1999) Reasoning with Spider Diagrams. Pro-\nceedings of the IEEE Symposium on Visual Languages '99, 138 -- 145. IEEE CS Press.\n[11] Hussmann H., Demuth B., Finger F. (2000) Modular Architecture for a Toolset Sup-\nporting OCL In Evans A., Kent S., Selic B. (eds) UML 2000 proceedings volume 1939 \nLNCS, 278 -- 293 , Springer-Verlag.\n[12] Kent S. (1997) Constraint Diagrams: Visualizing Invariants in Object-Oriented Models. \nIn Proceedings of OOPSLA '97, 327 -- 341.\n[13] UML 2.0 Infrastructure Request for Proposals, available from http://www.omg.org/uml\n[14] The pUML Home Page http://www.puml.org.\n[15] Richters M., Gogolla M. (1999) A metamodel for OCL. In France R. & Rumpe B. (eds) \nUML '99 proceedings volume 1723 LNCS, 156 -- 171, Springer-Verlag.\n[16] Richters M., Gogolla M. (2000) Validating UML Models and OCL Constraints. In \nEvans A., Kent S., Selic B. (eds) UML 2000 proceedings volume 1939 LNCS, 265 -- \n277, Springer-Verlag.\n[17] Richters M., Gogolla M. (2000) A Semantics for OCL pre and post conditions. Present-\ned at the OCL Workshop, UML 2000.\n[18] Object Management Group (1999) OMG Unified Modeling Language Specification, \nversion 1.3. Available at http://www.omg.org/uml.\n[19] The UML 2.0 Working Group Home Page http://www.celigent.com/omg/\nadptf/wgs/uml2wg.html.\n[20] Warmer J., Kleppe A. (1999) The Object Constraint Language: Precise Modeling with \nUML. Addison-Wesley.",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.8586718440055847
    },
    {
      "name": "Unified Modeling Language",
      "score": 0.7123081684112549
    },
    {
      "name": "Metamodeling",
      "score": 0.6381762027740479
    },
    {
      "name": "Programming language",
      "score": 0.5631217956542969
    },
    {
      "name": "Software engineering",
      "score": 0.5457271337509155
    },
    {
      "name": "Model-driven architecture",
      "score": 0.4788132309913635
    },
    {
      "name": "Template",
      "score": 0.4436933994293213
    },
    {
      "name": "Software",
      "score": 0.10075628757476807
    }
  ]
}