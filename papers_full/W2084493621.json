{
  "title": "RosettaScripts: A Scripting Language Interface to the Rosetta Macromolecular Modeling Suite",
  "url": "https://openalex.org/W2084493621",
  "year": 2011,
  "authors": [
    {
      "id": "https://openalex.org/A1996243058",
      "name": "Sarel J Fleishman",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A4211814245",
      "name": "Andrew Leaver‐Fay",
      "affiliations": [
        "University of North Carolina at Chapel Hill"
      ]
    },
    {
      "id": "https://openalex.org/A2017416472",
      "name": "Jacob E. Corn",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A4221308438",
      "name": "Eva-Maria Strauch",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2907911006",
      "name": "Sagar D. Khare",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2760948913",
      "name": "Nobuyasu Koga",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2196479153",
      "name": "Justin Ashworth",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2100219645",
      "name": "Paul Murphy",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2106604781",
      "name": "Florian Richter",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2058218332",
      "name": "Gordon Lemmon",
      "affiliations": [
        "Vanderbilt University"
      ]
    },
    {
      "id": "https://openalex.org/A2068190860",
      "name": "Jens Meiler",
      "affiliations": [
        "Vanderbilt University"
      ]
    },
    {
      "id": "https://openalex.org/A1961781263",
      "name": "David Baker",
      "affiliations": [
        "University of Washington",
        "Howard Hughes Medical Institute"
      ]
    },
    {
      "id": "https://openalex.org/A1996243058",
      "name": "Sarel J Fleishman",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A4211814245",
      "name": "Andrew Leaver‐Fay",
      "affiliations": [
        "University of North Carolina at Chapel Hill"
      ]
    },
    {
      "id": "https://openalex.org/A2017416472",
      "name": "Jacob E. Corn",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A4221308438",
      "name": "Eva-Maria Strauch",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2907911006",
      "name": "Sagar D. Khare",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2760948913",
      "name": "Nobuyasu Koga",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2196479153",
      "name": "Justin Ashworth",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2100219645",
      "name": "Paul Murphy",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2106604781",
      "name": "Florian Richter",
      "affiliations": [
        "University of Washington"
      ]
    },
    {
      "id": "https://openalex.org/A2058218332",
      "name": "Gordon Lemmon",
      "affiliations": [
        "Vanderbilt University"
      ]
    },
    {
      "id": "https://openalex.org/A2068190860",
      "name": "Jens Meiler",
      "affiliations": [
        "Vanderbilt University"
      ]
    },
    {
      "id": "https://openalex.org/A1961781263",
      "name": "David Baker",
      "affiliations": [
        "University of Washington",
        "Howard Hughes Medical Institute"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2135815512",
    "https://openalex.org/W1969644422",
    "https://openalex.org/W1996320633",
    "https://openalex.org/W1987696643",
    "https://openalex.org/W2082260955",
    "https://openalex.org/W2049275721",
    "https://openalex.org/W2159247900",
    "https://openalex.org/W2103622571",
    "https://openalex.org/W4300802462",
    "https://openalex.org/W6786359421",
    "https://openalex.org/W2151581834",
    "https://openalex.org/W2004360551",
    "https://openalex.org/W2081670113",
    "https://openalex.org/W2151693654",
    "https://openalex.org/W1999648327",
    "https://openalex.org/W2123781753",
    "https://openalex.org/W2014693209",
    "https://openalex.org/W2110270259",
    "https://openalex.org/W2001842251",
    "https://openalex.org/W2164958220",
    "https://openalex.org/W2146134187",
    "https://openalex.org/W2067484689",
    "https://openalex.org/W2007804411",
    "https://openalex.org/W1996142946",
    "https://openalex.org/W2103994532",
    "https://openalex.org/W2103591844",
    "https://openalex.org/W2110281506",
    "https://openalex.org/W1965802194",
    "https://openalex.org/W1982555694",
    "https://openalex.org/W2063830325",
    "https://openalex.org/W3105735405",
    "https://openalex.org/W2201713963"
  ],
  "abstract": "Macromolecular modeling and design are increasingly useful in basic research, biotechnology, and teaching. However, the absence of a user-friendly modeling framework that provides access to a wide range of modeling capabilities is hampering the wider adoption of computational methods by non-experts. RosettaScripts is an XML-like language for specifying modeling tasks in the Rosetta framework. RosettaScripts provides access to protocol-level functionalities, such as rigid-body docking and sequence redesign, and allows fast testing and deployment of complex protocols without need for modifying or recompiling the underlying C++ code. We illustrate these capabilities with RosettaScripts protocols for the stabilization of proteins, the generation of computationally constrained libraries for experimental selection of higher-affinity binding proteins, loop remodeling, small-molecule ligand docking, design of ligand-binding proteins, and specificity redesign in DNA-binding proteins.",
  "full_text": "RosettaScripts: A Scripting Language Interface to the\nRosetta Macromolecular Modeling Suite\nSarel J. Fleishman1*, Andrew Leaver-Fay2, Jacob E. Corn1¤a, Eva-Maria Strauch1, Sagar D. Khare1,\nNobuyasu Koga1, Justin Ashworth1¤b, Paul Murphy1, Florian Richter1, Gordon Lemmon3, Jens Meiler3,\nDavid Baker1,4\n1 Department of Biochemistry, University of Washington, Seattle, Washington, United States of America,2 Department of Biochemistry, University of North Carolina,\nChapel Hill, North Carolina, United States of America,3 Center for Structural Biology, Vanderbilt University, Nashville, Tennessee, United States of America,4 Howard\nHughes Medical Institute, University of Washington, Seattle, Washington, United States of America\nAbstract\nMacromolecular modeling and design are increasingly useful in basic research, biotechnology, and teaching. However, the\nabsence of a user-friendly modeling framework that provides access to a wide range of modeling capabilities is hampering\nthe wider adoption of computational methods by non-experts. RosettaScripts is an XML-like language for specifying\nmodeling tasks in the Rosetta framework. RosettaScripts provides access to protocol-level functionalities, such as rigid-body\ndocking and sequence redesign, and allows fast testing and deployment of complex protocols without need for modifying\nor recompiling the underlying C++ code. We illustrate these capabilities with RosettaScripts protocols for the stabilization of\nproteins, the generation of computationally constrained libraries for experimental selection of higher-affinity binding\nproteins, loop remodeling, small-molecule ligand docking, design of ligand-binding proteins, and specificity redesign in\nDNA-binding proteins.\nCitation: Fleishman SJ, Leaver-Fay A, Corn JE, Strauch E-M, Khare SD, et al. (2011) RosettaScripts: A Scripting Language Interface to the Rosetta Macromolecular\nModeling Suite. PLoS ONE 6(6): e20161. doi:10.1371/journal.pone.0020161\nEditor: Vladimir N. Uversky, University of South Florida College of Medicine, United States of America\nReceived February 16, 2011;Accepted April 12, 2011;Published June 24, 2011\nCopyright: /C2232011 Fleishman et al. This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits\nunrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\nFunding: Funding was provided by the Howard Hughes Medical Institute, Defense Advanced Research Agency, and Defense Threat Reduction Agency. SJF was\nsupported by a long-term fellowship from the Human Frontier Science Program. The funders had no role in study design, data collection and analysis, decision to\npublish, or preparation of the manuscript.\nCompeting Interests: JEC is currently employed by Genentech, but was not during any stage of the work reported here. This does not alter the authors’\nadherence to all the PLoS ONE policies on sharing data and materials.\n* E-mail: sarelf@uw.edu\n¤a Current address: Genentech, South San Francisco, California, United States of America\n¤b Current address: Institute for Systems Biology, Seattle, Washington, United States of America\nIntroduction\nThe Rosetta software suite for macromolecular modeling has\nuseful applications in many areas of interest to molecular\nbiologists. It allows the redesign of protein structure[1] and has\nbeen used to generate new protein folds[2], stabilize enzymes[3],\ngenerate novel enzymes[4,5], protein-protein interactions and\ninhibitors[6], and redesign specificities in protein-protein[7] and\nprotein-DNA interactions[8]. The design of new or improved\nprotein function often requires detailed treatment of available\ndegrees of freedom, typically on a case-by-case basis. Such case-\nspecific properties favor a user interface that is flexible enough to\nallow control of individual degrees of freedom and the course of\nthe modeling trajectory. Additionally making the modeling\napproaches developed in Rosetta available to the wide community\nof molecular biologists, with varying proficiencies in programming,\ndemands a framework that does not suffer from the rigidities of\ntraditional programming languages.\nWith these goals in mind, we developed RosettaScripts, an XML-\nlike language for specifying modeling protocols in the Rosetta\nframework (specification of the XML format can be found at http://\nwww.w3.org/TR/2000/REC-xml-20001006). RosettaScripts pro-\nvides protocol-level access to modeling functionalities, such as loop\nmodeling, rigid-body docking, and sequence design. Protocols can be\ndovetailed to generate complex trajectories comprising, for instance,\na phase of low-resolution rigid-body docking, followed by filtering\naccording to residue-specific contacts, sequence redesign of parts of\nan interface, and finally all-atom docking and minimization. The\nprotocols can be written quickly, do not require recompilation of the\nRosetta C++ source code, and can be ported and executed on all\ncomputing platforms that support Rosetta, thus opening the door to\nfast development and testing for non-experts.\nIn this paper we describe how to use RosettaScripts, providing\nconcrete, working examples for a variety of modeling tasks.\nDetailed usage instructions of each of the RosettaScripts\nfunctionalities are available at the RosettaCommons website\n(http://www.rosettacommons.org) and are updated with each\npublic release of the source code. The programming section below\nexplains how the RosettaScripts framework was implemented\nwithin Rosetta as well as the logic for extending RosettaScripts\nwith new functionalities.\nResults\nRosettaScripts relies on the object-oriented architecture of\nRosetta 3.0. A detailed description of the Rosetta 3.0 program-\nming framework is available in ref. [9]. At the most general level, a\nscript consists of a declaration phase and an ordering phase – it\nPLoS ONE | www.plosone.org 1 June 2011 | Volume 6 | Issue 6 | e20161\nreads like a recipe starting with an ingredient list and finishing with\na sequence of steps (Figure 1). In the declaration phase, the user\ndeclares a set of\nMovers (objects to modify a structure), Filters\n(objects to evaluate a structure), ScoreFunctions (objects to\nevaluate the energy of a structure), and TaskOperations (objects\nto control how Rosetta’s side-chain placement routines, ‘‘the\npacker,’’ should operate). In the ordering phase, the user lays out\nthe steps of the protocol by stating the order in which the\nMovers\nand Filters should be applied. Step 1 is always the same and is\nhandled by the JobDistributor (described later): a structure is\nread in from disk (or elsewhere); steps 2 through n describe how\nRosetta should modify that structure. If a filter is applied at step i,\nand the structure fails the filter, then execution returns to step 1 for\nanother attempt. Finally, if a structure passes all filters, it is\nreturned to the\nJobDistributor for output to disk.\nMover objects modify a structure (henceforth, a Pose) in some\nway. The vast majority of Rosetta routines for modifying the\nstructure of a protein are wrapped within\nMovers, from the\nsimplest steps, such as minimizing, to more complicated protocols\nsuch as rigid-body docking. Complex protocols are often\nimplemented as\nMovers built from a series of simpler Movers.\nFilter objects evaluate a Pose in their ‘‘apply’’ function and\nreturn a boolean describing whether or not the structure passed\nthe filter.\nFilters are useful in aborting trajectories that are\nheaded towards uninteresting regions of conformation and\nsequence space. Both\nMovers and Filters often require a\nsubstantial amount of data to control their behavior precisely. In\nRosetta2, developers were only able to tune their protocols with\ncommand-line flags. In an object-oriented framework, where a\nprogrammer can have multiple instances of the same\nMover, the\ncommand line is overly limited, preventing the user from\nexpressing nuance because a single flag cannot carry two\nmeanings: e.g., ‘‘use a cutoff of 10 in step 3, use a cutoff of 20\nin step 8.’’ RosettaScripts remedies this problem by letting the user\nspecify data for controlling\nMovers and Filters in XML-like\nblocks, where each block can carry different pieces of data.\nParsing a RosettaScript\nA RosettaScript is parsed as a series of XML-like entries called\nTags.A Tag is a recursive data structure, each instance of which\ncontains two mappings: from strings to strings (i.e., options), and\nfrom strings to\nTags (subtags); the use of Tags is described in\ngreater detail below. At the highest level, a RosettaScript consists\nof five tags, each of which contains subtags: MOVERS, FILTERS,\nSCOREFXNS, TASKOPERATIONS, and PROTOCOLS\n(Fig. 1A). The only tags that must be specified are MOVERS\nand PROTOCOLS. Information specified within each of the first\nfour high-level Tags is explained above; the PROTOCOLS\nsection defines the order of\nMovers and Filters to be executed\nfor each trajectory. The following provides a skeleton script:\n,ROSETTASCRIPTS.\n,SCOREFXNS.\n,/SCOREFXNS.\n,TASKOPERATIONS.\n,/TASKOPERATIONS.\n,FILTERS.\nFigure 1. A schematic of RosettaScript operations.(A) When parsing an XML protocol, a series of objects are instantiated. TheDataMap is used\nto store some of these elements as they are parsed, and to store any additional objects that the elements define (e.g., constraints from text files).\nMovers and Filters can access and modify the elements stored in theDataMap. After parsing completes, theDataMap is deallocated, though\nthe objects it once held may persist in memory. (B) Starting from a structure read in from disk, protocol execution consists of a series ofMover and\nFilter applications. A structure can either pass or fail aFilter: failure causes execution to return to the beginning, whereas success causes\nexecution to proceed. At the end of execution a protein model and its score are written to file. Though theDataMap does not persist beyond the\nparsing of the XML file, any of its former elements that are pointed to byMovers and Filters remain in memory, thus allowing communication\nbetween Movers and Filters during execution.\ndoi:10.1371/journal.pone.0020161.g001\nRosettaScripts\nPLoS ONE | www.plosone.org 2 June 2011 | Volume 6 | Issue 6 | e20161\n,/FILTERS.\n,MOVERS.\n,/MOVERS.\n,PROTOCOLS.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nwhere the high-level tags would be populated with concrete\nobjects prior to execution. Strings outside of the ,. brackets\nare treated as comments and ignored by the RosettaScripts\nmachinery.\nTaskOperations\nMany of the discrete conformational sampling capabilities of\nRosetta are implemented using a rapid Metropolis-Monte Carlo\nsimulated annealing engine referred to as the packer[9]. The\npacker searches for low-energy combinations of side-chain\nconformations.\nTaskOperations define the residue conforma-\ntions and identities used in the search and can be used to focus\ndesign or prediction to the relevant spaces (e.g., to design only\ninterfacial residues and repack the remainder).\nFrom a technical standpoint,\nTaskOperations are used to\nconstrain a PackerTask class. PackerTasks are one-time-use\nobjects and are constructed immediately before use. They are\nconstructed by the\nTaskFactory class, and modified by TaskO-\nperations before being handed to the packer. The PackerTask\nis peculiar in that all of its operations are commutative – the final\nstate of the PackerTask is independent of the order in which\nTaskOperations are applied to it. The analogy of refining the\nPackerTask is to sculpting a block of marble: the task starts out\nwith the command ‘‘redesign all residues allowing all amino acids’’\nand successive operations are allowed to restrict the focus of the\ntask to fewer residues or fewer amino acids at particular residues.\nHowever, once rock is chipped off, it cannot be put back; once a\nresidue is disabled or an amino acid is marked as unavailable, it\ncannot be re-enabled.\nTaskOperations restrict the degrees of\nfreedom of PackerTasks. The advantages of this system (that the\nstate of the PackerTask is independent of the order of operations,\nremoving all possible ambiguity about its state and avoiding any\nissues of operation precedence) are somewhat offset by the\ndisadvantage that\nTaskOperations sometimes step on each\nother’s toes: one TaskOperation will often disable a residue that\nanother TaskOperation would say should be designable.\nThere are three general types of TaskOperations: 1) those\nwithout options: a general, uniform behavior is applied over the\nwhole\nPose; 2) those with options: parameter-dependent behav-\nior(s) are applied to the whole Pose; and 3) residue-level\nTaskOperations: behavior is applied to a subset of Pose residues\nthat belong to a certain category. The following is an excerpt from\na script providing examples for all three usages:\n…\n,TASKOPERATIONS.\n,InitializeFromCommandline name = ifcm/. to make\nthe Packer aware of command-line options\n,RestrictToRepacking name = no_mutations/. only\nrepack; do not design\n,ReadResfile name = rrf filename = myresfile/. re-\nsfiles are external files that describe which residues\nare allowed to pack\n,OperateOnCertainResidues name = fix20to24.\n,PreventRepackingRLT/. do not change residues\n,ResidueIndexIs indices = 20,21,22,23,24/.\n,/OperateOnCertainResidues.\n,OperateOnCertainResidues name = keepNonpolars.\n,RestrictToRepackingRLT/. only repack; do not\ndesign\n,ResidueLacksProperty property = POLAR/. op-\nerate on polar residues\n,/OperateOnCertainResidues.\n,/TASKOPERATIONS.\n…\n,MOVERS.\n,PackRotamersMover name = packer scorefxn = score12\ntask_operations = ifcm,no_mutations/. score12 is the\ndefault all-atom Rosetta energy function; PackRotamers-\nMover invokes the Packer to design or repack sidechains\n,PackRotamersMover name = resfilepacker scor-\nefxn = score12 task_operations = ifcm,rrf/.\n,PackRotamersMover name = anotherpacker scor-\nefxn = score12 task_operations = ifcm,fix20to24,keep-\nNonpolars/.\n,/MOVERS.\n…\nIn this excerpt, three PackRotamersMovers will be instanti-\nated with different functionalities, since each one relies on a\ndifferent set of TaskOperations.\nTests that ensure source-code integrity\nThe Rosetta source code includes several software tests that\ndemonstrate and ensure the proper functioning of the Rosetta-\nScripts platform. The ‘‘integration’’ tests (e.g., test/integration/\ntests/dna_interface_design) are fully featured demonstrations of\nestablished protocols. Additional tests of RosettaScripts functionality\ninclude hotspot_graft, place_simultaneously, rosetta_scripts_setup,\nligand_dock_script, rotamer_recovery, and score12_docking. In\naddition, the ‘‘scientific’’ tests (test/scientific/) carry out full\nbenchmark analyses of common modeling procedures. This includes\nan additional dna_interface_design test to compute the mutational\nrecovery rates for native amino acids and nucleotides across a diverse\nset of 72 sequence-specific protein-DNA interfaces, as well as a\nligand_docking benchmark based on 20 crystal structures. Current\nand past results of these tests are available on the RosettaTests Server\n(http://rosettatests.graylab.jhu.edu/tests).\nProgramming Details\nTag class. The Tag class implements a recursive-descent\nparser that translates a text document to an object-oriented,\ntemplate-based data structure representing the contents of that\ndocument. The production rules for the language in Extended\nBackus–Naur Form (EBNF) are:\nTag: = , Name Option* . Tag* ,/Name . | ,Name\nOption*/.\nOption: = Name = Value\nName: = (string without whitespace)\nValue: = (string without whitespace) | ‘‘ (string with whitespace) ’’\nThese production rules are intended to bear resemblance to the\nHTML (http://www.w3.org/TR/REC-html32) or XML (http://\nwww.w3.org/XML/) languages, which are simple to learn and\nfamiliar to many users of Rosetta. Full-fledged XML parsers were\nnot used since no text was to be annotated, other than the\nstructure of the\nTags themselves. Also, since verification of the\nsemantic structure of the tags is left entirely to the user for the sake\nof simplicity, the formal document verification abilities of XML\nwere not required. The parser is implemented with the Boost\nSpirit library (http://boost-spirit.com/home/).\nThe Tag class itself allows recursive access to its subtags via the\ngetTag and getTags functions. It also allows access to values of the\noptions through the templated getOption ,. function, which, for\nRosettaScripts\nPLoS ONE | www.plosone.org 3 June 2011 | Volume 6 | Issue 6 | e20161\nconvenience, returns its data as any type for which operator ..\n(string,T) is defined. Implementation of this function allows users\nto further define the behavior of the Tag class without changes to\nthe underlying parser.\nParsing Tags. The parsing of individual Tags is handled\nsimilarly throughout the various sections of a RosettaScript. For\neach section, a factory is relied upon that indirectly maps a set of\nunique hardcoded names (e.g., ‘‘PackRotamersMover’’) to a set of\nobjects (e.g., the\nPackRotamersMover). When a Tag is read, the\nrelevant factory queries its creators for one that will build an object\nwith the same name as the Tag’s name (factories and creators are\ndescribed in greater detail below). If the factory finds such a\ncreator, it then requests an instance of the corresponding object\nand calls that object’s parse_my_tag routine with the options\nspecified within the Tag. The parse_my_tag routine interprets the\ninformation provided by the user and saves that information in\ninternal variables within the object, e.g., cutoffs that would control\nthe object’s behavior. The instantiated object is saved in a map for\nsubsequent use in the ordering phase: Mover objects are saved in a\nMovers map; Filter objects are saved in a Filters map.\nMost top-level Tag types require an option called ‘‘name’’\n(Movers, Filters, TaskOperations, but not ScoreFunc-\ntions). This name identifies different instances of the same class\nso that they can be referred to separately in the ordering section.\nFor example, in the MOVERS section, the following Tag,\n,PackRotamersMover name = design task_operations = de-\nsign_shell/. would provoke the MoverFactory to create a\nnew instance of the PackRotamersMover, and call this instance’s\nparse_my_tag() routine with the option task_operations = de-\nsign_shell. This Mover would be saved in the Movers map\nunder the name ‘‘design’’ for use in the ordering phase. Note that\nthis mover is handed the name ‘‘design_shell’’ for the TaskO-\nperation it should use; the Mover will look for this TaskOpera-\ntion in a data structure called the DataMap (discussed in greater\ndetail in the next section).\nOnce all of the declarations have been parsed, we arrive at the\nordering section (labeled PROTOCOLS in a RosettaScript).\nHere, a Mover called ParsedProtocol is instantiated and an\norder-dependent array of Movers and Filters is instantiated\nwith it, explicating the sequence of Movers and Filters to be\nexecuted in a trajectory (Fig. 1B). Consider for example, the\nfollowing section:\n…\n,PROTOCOLS.\n,Add mover = design filter = number_of_contacts/.\n,Add mover = dock/.\n,/PROTOCOLS.\n…\nRosettaScripts would query the Movers map for Movers, the\nname option of which was design and dock and the Filters\nmap for the Filter number_of_contacts, all of which would\nbe declared in previous sections. ParsedProtocol’s internal\narray of Movers and Filters will have the sequence design R\nnumber_of_contacts R dock, which will be executed in this\norder at run-time. As demonstrated in several applications below,\nParsedProtocol itself is a Mover that can be declared in the\nMovers section to aggregate a sequence of Movers under one\nname. For example,\n,ParsedProtocol name = aggregate_mover.\n,Add mover = design filter = number_of_contacts/.\n,Add mover = dock/.\n,/ParsedProtocol.\nThe Mover aggregate_mover can then be called in the\nPROTOCOLS section.\nOnce a script has been parsed, the Movers map, the Filters\nmap, and the DataMap all leave scope, and a smart pointer is\nretained in memory to the ParsedProtocol mover from the\nordering phase (Fig. 1B). Any objects held in these maps that are\nnot pointed to from the ParsedProtocol mover (or from an\nobject contained in the ParsedProtocol mover) will be\nautomatically deleted.\nThe DataMap. Global variables are discouraged in large\nsoftware projects[10], so a specialized mechanism for\ncommunicating information between Movers and Filters is\nneeded. To this end, we introduced a DataMap object (Fig. 1). The\nDataMap is a map from strings to maps: for example, the\n‘‘ScoreFunctions’’ string points to a map with keys such as\n‘‘score12’’ and ‘‘score_docking’’, each of which points to smart\npointers of the relevant\nScoreFunctions. (Fig. 1A). This flexible\nprototype allows any object type to be defined within this\nframework, for instance, both\nTaskOperations and Score-\nFunctions are held in this map.\nThe DataMap is passed along with the Movers and Filters\nmaps to the individual objects at parse time (Fig. 1A). It provides a\ntemplated accessor function for data retrieval, which carries out a\ntype-safety check (using C++’s dynamic_cast function) and returns\na pointer to the requested object. For example, the code\ndata_map.get, ScoreFunction * .(‘‘scorefxns’’,\n‘‘high_resolution’’) would request a pointer to Score-\nFunction with the two defining strings ‘‘scorefxns’’ (the name of\nthe map of strings to ScoreFunction pointers) and ‘‘high\n_resolution’’ (the name of a particular ScoreFunction). The\nDataMap can also be used to communicate information between\nMovers and Filters during run-time (Fig. 1B). For instance, one\nMover might instantiate and store a ScoreFunction object in the\nDataMap that is then accessed and modified by other Movers or\nFilters. Since these Movers would all hold pointers to the same\nScoreFunction, the weights on individual score terms for a single\nScoreFunction instance could be modified in the course of a\ntrajectory, and this modification would affect all the Movers using\nthat instance.\nThe Job Distributor. The JobDistributor is a Rosetta 3.0\nframework, the main task of which is central handling of structure\nand scoring input/output operations. RosettaScripts execution is\nembedded within the JobDistributor and can therefore access\nits structure-reading and -writing functionalities. Options for\ncontrolling\nJobDistributor behavior[9] are set through the\ncommand line. For instance, reading of a Protein Databank (PDB)\nfile is accessed through the command line -in:file:s, whereas\nreading of a more compact form of a coordinates file is specified by\n-in:file:silent[9]. Similarly, coordinate files can be written as PDB\nor silent files with the corresponding command line options.\nExtending RosettaScripts to include new Movers and\nFilters\nThe XML-parser in RosettaScripts relies on factory classes to\ninstantiate Movers and Filters by name, without having to\nknow any details about particular Movers or Filters. This\nmeans that minimal effort is required to include new objects into\nthe RosettaScripts API. A new\nMover merely has to register itself\nwith the MoverFactory before the parsing step asks the factory\nfor an instance of that Mover. This means that new Movers can be\nadded a) easily by new Rosetta developers by adding a handful of\nclasses and modifying one existing source file; b) easily by non-\nRosetta programmers who are linking against the Rosetta3\nlibraries; or c) easily in an interactive Python session, or from a\nPython script using the PyRosetta libraries[11]. In this last case,\nRosettaScripts\nPLoS ONE | www.plosone.org 4 June 2011 | Volume 6 | Issue 6 | e20161\nthe new Mover being introduced can be a Python-defined subclass\nof the C ++ Mover base class.\nThe factory scheme is made up of four players: class Widget,\nclass WidgetFactory, class WidgetCreator, and class Widge-\ntRegistrator (Fig. 2). Class WidgetFactory is a singleton[10]\nthat holds a map from strings to WidgetCreators. Each\nWidgetCreator is responsible for instantiating a particular class\nderived from class Widget and for reporting a unique name for\ninstances of this derived Widget class. WidgetCreators must be\nregistered with the WidgetFactory, at which time the Widget-\nFactory adds the WidgetCreator to its map of strings Widget-\nCreators. The WidgetFactory defines a function: Widget *\ncreate_widget(std::string const & name) wherein it\nsearches for a WidgetCreator with the given name and then\nasks that WidgetCreator for a new Widget. The WidgetRe-\ngistrator objects, at construction, create a particular Widget-\nCreator and register it with a particular WidgetFactory. The\nregistrators are placed in the library init.cc files (e.g., src/\nprotocols/init.cc) which also house an init() function that all\nRosetta executables must call at the very beginning of main(). This\nensures that registration happens before the factories are used.\nNew\nWidgets and WidgetCreators can be defined anywhere,\nincluding in external libraries, and can be included in the\nRosettaScripts without modifying any of the code in the Rosetta3\nlibraries. This flexibility would not be possible without separating\nthe role that WidgetCreators play (instantiating particular\nWidgets) from the role the WidgetFactory plays (centralizing\nthe instantiation).\nApplications\nIn the following, all scripts can be run using the RosettaScripts\napplication that is part of the Rosetta release with the following\ncommandline:\nrosetta_scripts –s ,PDB file name. -parser:proto-\ncol ,XML file name. -database ,location of the Rosetta\ndatabase..\nFor convenience, we provide input and output files for each\nprotocol as Supplemental Information S1.\nFlexible backbone design for monomers. Protein cores\nare usually very well packed with mostly hydrophobic amino acids,\nto the extent that the packing density corresponds to a close-\npacked crystal[12]. Cavity-forming mutations or strain in the core\nof natural proteins compromise their stability[13]. Therefore,\ngenerating stable monomeric proteins demands a tightly packed\nand strain-free core[3]. In addition, numerous studies have\npointed out that native proteins evolved by optimizing their\nbackbone conformations in the process tightening core\npacking(e.g., [1]). This idea directly led to the development of a\ndesign protocol for sequence and backbone optimization and the\ngeneration of the first computationally designed novel protein\nfold[2]. Accordingly, the flexible-backbone design protocol\nimplemented here provides the simultaneous design of sequence\nand backbone (\nFlxbbDesign), followed by the filtering of the\ndesigned structures by RosetttaHoles (PackStat) [14], which\nquantitatively assesses protein packing:\n,ROSETTASCRIPTS.\n,SCOREFXNS.\n,SFXN1 weights = score12_w_corrections.\n,Reweight scoretype = atom_pair_\nconstraint weight = 1.0/.\n,/SFXN1.\n,/SCOREFXNS.\n,TASKOPERATIONS.\n,LayerDesign name = layer layer = core_\nboundary_surface/.\n,/TASKOPERATIONS.\n,FILTERS.\n,PackStat name = pstat threshold = 0.60/.\n,/FILTERS.\n,MOVERS.\n,FlxbbDesign name = flxbb ncycles = 3\nconstraints_sheet = 100.0 sfxn_design = SFXN1 sfxn_re-\nlax = SFXN1 clear_all_residues = 1 task_operations =\nlayer/.\n,/MOVERS.\n,PROTOCOLS.\n,Add mover = flxbb/.\n,Add filter = pstat/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nIn this example, FlxbbDesign performs 3 cycles of sequence\ndesign and backbone optimization[15]. Internally, initial sequence\ninformation is cleared by turning all residues to alanine\n(clear_all_residues = 1). Then, sequence design is conducted\nwith the TaskOperation of LayerDesign, which specifies the\nallowed amino acid types depending on the extent of burial of each\nposition (e.g., buried positions are allowed to be hydrophobic,\nFigure 2. Unified-Modeling Language (UML) class diagram of\nRosetta’s factory scheme.The creation of Movers, Filters, and\nTaskOperations is controlled by similar factory setups. Pictured here\nare the classes responsible for the instantiation of generic ‘‘Widget’’\nclasses. The singletonWidgetFactory maintains a map from strings\nto WidgetCreators. Each WidgetCreator is responsible for\ninstantiating a particular Widget; e.g., the derivedWidgetCreator\nclass, DerivedWidgetCreator, is responsible for instantiating the\nderived Widget, DerivedWidget. The factory registration system\nallows new Movers, Filters, and TaskOperations (and their\ncorresponding MoverCreators, FilterCreators, and TaskO-\nperationCreators) to be defined outside of the Rosetta3 libraries\nand yet to be included in the RosettaScripts framework without\nrequiring the addition of any new dependencies to the Rosetta3\nlibraries.\ndoi:10.1371/journal.pone.0020161.g002\nRosettaScripts\nPLoS ONE | www.plosone.org 5 June 2011 | Volume 6 | Issue 6 | e20161\nwhereas exposed positions are polar). Next, backbone optimization\nis performed with sheet constraints to prevent drastic changes to\nthe tertiary structure. Finally, the extent to which the core of the\nstructure is well-packed is evaluated and filtered by Rosetta-\nHoles[14] using the\nPackStat filter.\nProtein-protein interface redesign and conformational\nsampling. Recent advances in protein engineering have\nallowed screening and selection of large-scale combinatorial\nprotein libraries leading to novel therapeutics and\nbiotechnological reagents[16]. Despite these advances the\nsequence space that can be sampled even by the most\nsophisticated experimental methods (10\n11 combinations) would\nallow the full randomization of a mere 8 independent amino acid\npositions. By contrast a typical protein-protein interface consists of\nmore than 20 amino acid residues within the first shell of\ninteractions, well beyond the reach of screening capabilities.\nEfficient computational protocols can readily sample\nconformational spaces of this size[17]. Computational design can\ntherefore be useful in restricting sequence space to energetically\nreasonable identities and experimentally manageable sizes[18].\nHere, we describe an approach to identify diverse sequence\nmutations in a protein interface that are compatible with a given\nbinding mode. The protocol makes use of rigid-body docking,\nbackbone and side-chain minimization and packing, sequence\ndesign, and a combination of score functions that encourages\ngreater sequence diversity. Often, certain structural and energetic\nproperties should be retained throughout a trajectory, e.g., the\ncomputed binding energy (ddG), the presence of particular\nhydrogen bonds or the root-mean-square deviation from the\nstarting structure. The versatility of RosettaScripts allows the user\nto combine a set of movers and filters to ensure that these\nproperties are maintained. The example protocol below starts with\nhigh resolution docking with soft-repulsive penalties. It uses\niterations over a series of design movers combined with subtle\nbackbone sampling defined through the\nBackrub mover[19,20].\n,ROSETTASCRIPTS.\n,FILTERS.\n,Ddg name = ddG scorefxn = score12 threshold = -15\nrepeats = 2/. binding energy calculation; an average of\ntwo repeats is computed for better numerical accuracy\n,Sasa name = sasa threshold = 800/. Buried surface\narea upon complex formation\n,Rmsd name = rmsd confidence = 0/. confidence = 0\nmeans that the filter will be evaluated but not used as\nan acceptance criterion\n,CompoundStatement name = ddg_sasa. combine fil-\nters into a single logical statement\n,AND filter_name = ddG/.\n,AND filter_name = sasa/.\n,/CompoundStatement.\n,/FILTERS.\n,MOVERS.\n,Docking name = docking score_high = soft_rep\nfullatom = 1 local_refine = 1/. Invokes RosettaDock local-\nrefinement (in full-atom) with a soft potential\n,Backrub name = backrub partner1 = 0 partner2 = 1\ninterface_distance_cutoff = 8.0 moves = 1000 sc_move_\nprobability = 0.25 scorefxn = score12\nsmall_move_probability = 0.15 bbg_move_probability =\n0.25/. perturb the backbone of chain2\n,RepackMinimize name = des1 scorefxn_repack = soft_rep\nscorefxn_minimize = soft_rep minimize_bb = 0 minimize_\nr b=1 /.\n,RepackMinimize name = des2 scorefxn_repack =\nscore12 scorefxn_minimize = score12 minimize_bb = 0\nminimize_rb = 1/. Design & minimizatio\nn at the interface\n,RepackMinimize name = des3 minimize_bb = 1/.\n,ParsedProtocol name = design.\n,Add mover_name = des1/.\n,Add mover_name = des2/.\n,Add mover_name = des3/.\n,Add mover_name = backrub/.\n,Add mover_name = des3 filter_name = ddg_sasa/.\n,/ParsedProtocol.\n,GenericMonteCarlo name = iterate scorefxn_name =\nscore12 mover_name = design trials = 10/.\n,/MOVERS.\n,PROTOCOLS.\n,Add mover = docking/.\n,Add mover = iterate/.\n,Add filter = ddG/.\n,Add filter = sasa/.\n,Add filter = rmsd/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nIn each trajectory, this protocol would carry out one docking\nstep and then iterate 10 times (through use of the GenericMon-\nteCarlo mover) over a set of design and backbone sampling\n(Backrub) steps. The output will include the modified protein\nstructure, the computed binding energy ( ddG), the buried surface\narea upon complex formation ( sasa), and the RMSD from the\nstarting structure ( rmsd). Typically, several thousand models\nshould be executed with this script and the mutations at the\ninterfaces combined to constrain sequence space for experimental\nlibraries.\nLoop modeling. Polypeptide stretches lacking secondary\nstructure are often found at protein interfaces. A well-known\nexample is that of antibodies, which use a combination of loops to\nachieve high shape complementarity and interaction density to\nantigens with a wide variety of surface features. The variety of\nconformational solutions that loops provide suggests that\nincorporating loop modeling in the design of interfaces could\nsubstantially increase the potential utility of protein design. The\nexample below provides a procedure for sampling conformational\nplasticity at the interface for use in increasing the affinity of a\ntarget-scaffold pair of proteins.\nAlternative rigid-body orientations of a scaffold-target pair\npotentially present different loops to the target surface. We\ndeveloped a customizable framework for the automatic detection\nof loops at the interface to be used for conformational remodeling\nand sequence design. These methods are optimized for use with\ninterfacial loops, but can also be extended to incorporate\nbackbone moves in the context of a monomer. First, the user\nspecifies a\nLoopFinder Mover, with options available to define\nminimum and maximum loop lengths. The user may also specify\nwhether loops should be restricted to the interface, and on which\npartners they should be detected. A subsequently invoked\nLoopRemodel Mover carries out the actual conformational\nremodeling and sequence design in the loops identified by the\nLoopFinder. Alternatively, if the loop spans to be remodeled are\nknown ahead of time, the user may specify them within\nLoopRemodel itself. The LoopRemodel mover can perform both\nextensive loop building, in which backbone degrees of freedom\nare randomized prior to building, or refinement of an existing\nloop structure. Building operates in low-resolution mode, and so\nexclusively operates on backbone torsion angles. A refinement\nRosettaScripts\nPLoS ONE | www.plosone.org 6 June 2011 | Volume 6 | Issue 6 | e20161\nstep operates in all-atom mode and intersperses backbone moves\nwith side-chain repacking and/or design. A single LoopRemodel\nMover can sequentially incorporate both building and refine-\nment. Two loop-remodeling strategies are currently supported:\nfragment insertion[21] followed by cyclic coordinate descent[22],\nand kinematic loop closure[23], which vary in how torsion-angle\nsampling is conducted.\nIn many protein-protein interactions, the structure of each\ncomplexed partner differs somewhat from its apo structure. The\naforementioned small backbone moves and loop remodeling can\nbe linked together within RosettaScripts to approximate such\ninterfacial conformation changes during the design process. This\nprotocol uses a special wrapping mover called\nLoopOver, which\nallows a user to repeat combined sub-movers. The contained sub-\nmover is repeated until one of two exit conditions is fulfilled: either\na certain number of repeats has occurred, or a user-defined\nFilter has passed. The script assumes a reasonable starting rigid-\nbody orientation between two partners, with chain 1 being the\ntarget and chain 2 being the design scaffold. The script begins with\nlarge scale interfacial loop building of chain 2 in low-resolution\nmode, then proceeds to refine these new loop conformations with\na soft-repulsive score function. Once the loop conformations have\nbeen refined with a fixed sequence, they are refined again with\nsimultaneous sequence design and a more physically realistic score\nfunction (with higher repulsive weights). Repeated\nBackrub moves\nthen subtly sample backbone conformations, and a set of three\nRepackMinimize moves is used for interface design. Target-\nspecific filters may be added to this script to ensure that\nconformational and sequence space is constrained by known\nfunctional or energetic thresholds.\n,ROSETTASCRIPTS.\n,MOVERS.\n,LoopFinder name = find ch1 = 0 ch2 = 1\ninterface = 1 min_length = 3 max_length = 10 mingap = 2/.\nFind loops on chain 2 with length 2.x.11, with at least\n3 residue separation.\n,LoopRemodel name = build auto_\nloops = 1 design = 0 protocol = kinematic perturb = 1 re-\nfine = 0/. Aggressively build found loops, no design\n,LoopRemodel name = refine1 auto_\nloops = 1 design = 0 protocol = kinematic perturb = 0 re-\nfine = 1 refine_score = soft_rep/. Refine found loops,\nsoft repulsive, no design\n,LoopRemodel name = refine2 auto_\nloops = 1 design = 1 protocol = kinematic perturb = 0 re-\nfine = 1 refine_score = score12/. Refine found loops,\nscore12, design\n,Backrub name = backrub partner1 = 0\npartner2 = 1/. Subtle backbone moves over whole inter-\nface of chain 2\n,LoopOver name = repeat_backrub mover_\nname = backrub iterations = 10/. Bundles Backrub into re-\npeats (no filter used)\n,RepackMinimize name = des1 scorefxn_\nrepack = score_docking scorefxn_minimize = soft_rep minimize_\nbb = 0 minimize_rb = 0/.\nAggressive design scorefunction, sidechain only\nmoves\n,RepackMinimize name = des2 scor-\nefxn_repack = soft_rep scorefxn_minimize = score12\nminimize_bb = 0 minimize_rb = 1/. More\nconstrained design scorefunction, sidechain and\nrigid body moves\n,RepackMinimize name = des3 de-\nsign_partner1 = 1 design_partner2 = 1 minimize_bb = 1/.\nStrict design scorefunction, sidec\nhain, rigid body, and backbone moves\n,ParsedProtocol name = design.\n,Add mover_name = des1/.\n,Add mover_name = des2/.\n,Add mover_name = des3/.\n,/ParsedProtocol.\n,/MOVERS.\n,PROTOCOLS.\n,Add mover = find/.\n,Add mover = build/.\n,Add mover = refine1/.\n,Add mover = refine2/.\n,Add mover = repeat_backrub/.\n,\nAdd mover = design/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nEnzyme and ligand-binder design. RosettaScripts can be\nused for the modeling and design of protein-ligand interfaces as\nperformed in the de novo computational design of enzymes[4,5]. In\nthe Rosetta enzyme-design methodology, the active-site geometry\nis specified by a set of pairwise geometric constraints – called\nmatch constraints[24] – each defined between the transition-state\n(TS) model and a functional group from the protein (catalytic\nresidue). Starting from a given orientation of a ligand or a TS\nmodel with respect to a protein structure, match constraints\nbetween specified sidechains or backbones of catalytic residues and\nthe TS can be applied and modulated during the simulation. The\nconformations and identities of the interface side chains, the rigid-\nbody orientation of the TS with respect to the protein, and the\nconformation of an internally flexible TS model can be\nsimultaneously optimized using a combination of Monte Carlo\noptimization and gradient-based minimization, with or without\nmatch constraints.\nThe AddOrRemoveMatchCsts Mover handles the application\nor removal of match constraints that are used to specify the\nrelative orientation of the TS and a given functional group.\nConstraints can also be defined between two functional groups\nwithin the protein (e.g., a His-Asp dyad). Each instance of the\nMover can take a different set of constraints, specified via a user-\ndefined input file, thereby allowing the user to change the\nmagnitude and/or the number of constraints used during the\nsimulation trajectory. In cases where the TS model contains a\ncovalently bound intermediate (e.g., acylenzyme intermediates), it\nis possible to specify retaining the covalent constraint even while\nremoving other non-covalent ones.\nThe EnzRepackMinimize Mover performs Monte Carlo\noptimization of the identities and conformations of a protein-\nligand interface followed by gradient-based minimization of the\nenergy of the resulting interface. The interface is identified using\nthe DetectProteinLigandInterface TaskOperation (see\nbelow). The user can toggle the minimization of various degrees\nof freedom – side chain, backbone, ligand rigid-body orientation,\nand the ligand internal torsion angles – individually during each\ninstantiation of the mover, thus allowing fine-grained control over\nthe degrees of freedom minimized at a particular stage of the\nprotocol. If the option cst_opt is selected, all protein residues on\nthe interface except catalytic residues are temporarily converted to\nalanines, and the energy including constraint energy – defined as a\nharmonic penalty from the ideal values – is minimized.\nThe DetectProteinLigandInterface TaskOperation de-\ntermines the residue positions on a protein-ligand interface for\nRosettaScripts\nPLoS ONE | www.plosone.org 7 June 2011 | Volume 6 | Issue 6 | e20161\nsubsequent protein design. This TaskOperation identifies\nligand-proximal positions on th e protein (or a user-specified\nset of residues) and marks them as designable; positions distal\nfrom the ligand are marked as immutable; and intermediate\npositions are marked repackable. During the course of an\nenzyme-design calculation, des ignable positions are allowed to\nchange both their identity and conformation; repackable\npositions are allowed to change only their conformation;\nwhereas immutable positions are c onstrained to their starting\nconformation. The following is a typical script for conducting an\nenzyme-design c alculation.\n,ROSETTASCRIPTS.\n,SCOREFXNS.\n,myscore weights = enzdes.wts/. Read\nthe enzdes.wts score function from the Rosetta database\n,/SCOREFXNS.\n,FILTERS.\n,EnzScore name = \"allcst\" score_ty-\npe = cstE scorefxn = myscore whole_pose = 1 energy_cut-\noff = 5/. filter on the constraint scores\n,LigInterfaceEnergy name = \"interfE\"\nscorefxn = myscore energy_cutoff = -9.0/. filter on the\nenergy across the interface\n,CompoundStatement name = \"myfilter\".\n,AND filter_name = \"allcst\"/.\n,AND filter_name = \"interfE\"/.\n,/CompoundStatement.\n,/FILTERS.\n,MOVERS.\n,AddOrRemoveMatchCsts name = cstadd\ncst_instruction = add_new/. add catalytic constraints\n,EnzRepackMinimize name = cstopt cst_opt = 1\nminimize_rb = 1 minimize_sc = 1 minimize_bb = 1/. optimize\nconstraints energy in polyAla background\n,EnzRepackMinimize name = desmin de-\nsign = 1 repack_only = 0 scorefxn_minimize = myscore\nscorefxn_repack = myscore minimize_rb = 1 minimi-\nze_sc = 1 minimize_bb = 1 cycles = 1/.\n,EnzRepackMinimize name = fin_min re-\npack_only = 0 design = 0 scorefxn_minimize = myscore\nscorefxn_repack = myscore minimize_rb = 1 minimi-\nze_sc = 1 minimize_bb = 1 cycles = 1/.\n,EnzRepackMinimize name = fin_rpkmin re-\npack_only = 1 design = 0 scorefxn_minimize = myscore\nscorefxn_repack = myscore minimize_rb = 1 minimi-\nze_sc = 1 minimize_bb = 1 cycles = 1/.\n,AddOrRemoveMatchCsts name = cstrem\ncst_instruction = remove keep_covalent = 1/. remove\nconstraints\n,AddOrRemoveMatchCsts name = cstfinadd\ncst_instruction = add_pregenerated/. add the last set\nof constraints added just prior to removing them (used\nfor scoring typically at the end of the trajectory)\n,/MOVERS.\n,PROTOCOLS.\n,Add mover_name = cstadd/.\n,Add mover_name = cstopt/.\n,Add mover_name = desmin/.\n,Add mover_name = cstrem/.\n,Add mover_name = fin_min/.\n,Add mover_name = fin_rpkmin/.\n,Add mover_name = cstfinadd/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nLigand docking and design. RosettaLigand allows the\nsimultaneous sampling of protein, ligand, and rigid-body degrees\nof freedom[25,26] and has been refactored for use with\nRosettaScripts. Separating the protocol into a collection of\nscriptable movers allows users to customize the docking study in\nfine detail. This opens the door to novel ligand-docking\napproaches while preserving the benchmark results seen\npreviously. Multiple ligands, cofactors, ions, and key water\nmolecules can now be docked simultaneously. Interface-residue\nidentities can now be redesigned during docking. By separating\nlow- and high-resolution docking, a study can be optimized for\nhigh-throughput virtual screening. The following script is designed\nto replicate the protocol described by Davis and Baker[26]:\n,ROSETTASCRIPTS.\n,SCOREFXNS.\n,ligand_soft_rep weights = ligand_soft_rep.\nuse a soft potential from the Rosetta database\n,Reweight scoretype = hack_elec weight\n= 0.42/. change the Coloumb electrostatic weight to 0.42\n,/ligand_soft_rep.\n,hard_rep weights = ligand.\n,Reweight scoretype = hack_elec weight = 0.42/.\n,/hard_rep.\n,/SCOREFXNS.\n,LIGAND_AREAS.\n,docking_sidechain chain = X cutoff = 6.0 add_\nnbr_radius = true all_atom_mode = true minimize_li-\ngand = 10/.\n,final_sidechain chain = X cutoff = 6.0 add_\nnbr_radius = true all_atom_mode = true/.\n,final_backbone chain = X cutoff = 7.0 add_\nnbr_radius = false all_atom_mode = true Calpha_res-\ntraints = 0.3/.\n,/LIGAND_AREAS.\n,INTERFACE_BUILDERS.\n,side_chain_for_docking ligand_areas = docking_\nsidechain/.\n,side_chain_for_final ligand_areas = final_\nsidechain/.\n,backbone ligand_areas = final_backbone ex-\ntension_window = 3/.\n,/INTERFACE_BUILDERS.\n,MOVEMAP_BUILDERS.\n,docking sc_interface = side_chain_for_\ndocking minimize_water = true/.\n,final sc_interface = side_chain_for_final\nbb_interface = backbone minimize_water = true/.\n,/MOVEMAP_BUILDERS.\n,MOVERS.\nsingle movers\n,StartFrom name = start_from chain = X.\n,Coordinates x = -1.731 y = 32.589 z =\n-5.039/.\n,/StartFrom.\n,Translate name = translate chain = X distri-\nbution = uniform angstroms = 0.01 cycles = 50/.\n,Rotate name = rotate chain = X distribution =\nuniform degrees = 360 cycles = 1000/.\n,SlideTogether name = slide_together chain = X/.\n,HighResDocker name = high_res_docker chains\n= X cycles = 6 repack_every_Nth = 3 scorefxn = ligand_\nsoft_rep movemap_builder = docking/.\n,FinalMinimizer name = final scorefxn = hard_\nrep movemap_builder = final/.\nRosettaScripts\nPLoS ONE | www.plosone.org 8 June 2011 | Volume 6 | Issue 6 | e20161\n,InterfaceScoreCalculator name = add_scores\nchains = X scorefxn = hard_rep native = \"inputs/7cpa_\n7cpa_native.pdb\"/.\ncompound movers\n,ParsedProtocol name = low_res_dock.\n,Add mover_name = start_from/.\n,Add mover_name = translate/.\n,Add mover_name = rotate/.\n,Add mover_name = slide_together/.\n,/ParsedProtocol.\n,ParsedProtocol name = high_res_dock.\n,Add mover_name = high_res_docker/.\n,Add mover_name = final/.\n,/ParsedProtocol.\n,/MOVERS.\n,PROTOCOLS.\n,Add mover_name = low_res_dock/.\n,Add mover_name = high_res_dock/.\n,Add mover_name = add_scores/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nThe StartFrom Mover moves a small molecule to a specified\nXYZ-coordinate and is used to position the ligand in proximity to\na putative binding site. Translate randomly moves a specified\ndistance in any direction. This is repeated a specified number of\ntimes until the ligand does not sterically clash with the protein.\nRotate randomly reorients the ligand a specified number of\ntimes, looking for a rotation that leads to van der Waals attractive\nand repulsive scores that pass a threshold. After initial placement\nof the ligand, SlideTogether moves the ligand toward the\nprotein until the two collide and then backs up the ligand slightly,\nto ensure that contact between the partners is maintained. The\nHighResDocker performs cycles of rotamer trials or repacking,\ncoupled with small perturbations of the ligand. FinalMinimizer\nperforms gradient-based minimization of the final docked pose.\nFinally the\nInterfaceScoreCalculator records the value of\neach score term with the docked ligand and after removing the\ndocked ligand. The differences between paired terms represents\nthe interface score. It also calculates the distance the ligand\ntraveled and the ligand radius of gyration. If the structure is\nknown (in case of benchmark studies), root-mean-square distances\ncan be calculated.\nSeveral other ligand-docking specific XML elements are used\nby the Movers above. LIGAND_AREAS describe parameters\nspecific to each ligand in a multi-ligand docking study. A cutoff\ndistance specified in A ˚ngstroms determines how far away an\namino acid residue can be from the ligand and still be considered\npart of an interface. The neighbor_radius parameter is\nspecified in the ligand-params file and can be added to the\nspecified cutoff distance. All-atom mode checks the distance\nbetween each residue and every ligand atom. Otherwise the\ndistance is checked only from the ligand centroid. During high-\nresolution docking, modest sampling of ligand translation and\nrotation are coupled to cycles of rotamer trials or repacking. These\nvalues can be controlled by the high_res_angstrom and\nhigh_res_degrees values, respectively. LIGAND_AREAS specify\nthe degree of ligand flexibility and backbone flexibility around\neach ligand. Ligand minimization can be turned on by specifying a\nminimize_ligand value greater than 0. This value represents the\nsize of one standard deviation of ligand torsion-angle rotation (in\ndegrees). By setting Calpha_restraints greater than 0,\nbackbone flexibility is enabled. This value represents the size of\none standard deviation of Calpha movement in A ˚ngstroms.\nINTERFACE_BUILDERS describe how to choose residues that will\nbe part of a protein-ligand interface. The user provides a list of\nligand_area names in comma separated form. MOVEMAP_-\nBUILDERS construct descriptions of the degrees of freedom\nallowed in minimization.\nDesign of DNA-binding proteins. RosettaScripts can be\nused to perform modeling and design of protein-DNA interfaces.\nProtein-DNA complexes were first modeled using Rosetta by\nHavranek et al. [27]. Predictions are made using atom properties\nand energy forcefield parameters that are based on the default\nRosetta energy function[28]. This has subsequently been applied\nto research into the design of novel specificity for DNA-binding\nproteins, including the design of individual changes in the\nnucleotide specificity of homing endonucleases[29], as well as\nmethods to theoretically maximize specificity[28], introduce small\nprotein backbone shifts[30], and optimize clusters of amino acids\nfor changes in multiple adjacent base pairs[28]. The\nRosettaScripts components can be used to make similar kinds of\npredictions, as well as to efficiently build, extend, and test new\nmodeling and design protocols. The following protocol redesigns a\nprotein around a DNA molecule, using the multistate-design\nframework to take into account binding specificity and backbone\nremodeling.\n,ROSETTASCRIPTS.\n,TASKOPERATIONS.\n,InitializeFromCommandline name = IFC/.\n,IncludeCurrent name = IC/.\n,RestrictDesignToProteinDNAInterface\nname = DnaInt base_only = 1 z_cutoff = 3.0 dna_defs = C.\n-10.GUA/.\n,OperateOnCertainResidues name = AUTOprot.\n,AddBehaviorRLT behavior = AUTO/.\n,ResidueHasProperty property = PROTEIN/.\n,/OperateOnCertainResidues.\n,OperateOnCertainResidues name = ProtNoDes.\n,RestrictToRepackingRLT/.\n,ResidueHasProperty property = PROTEIN/.\n,/OperateOnCertainResidues.\n,OperateOnCertainResidues name = DnaNoPack.\n,PreventRepackingRLT/.\n,ResidueHasProperty property = DNA/.\n,/OperateOnCertainResidues.\n,/TASKOPERATIONS.\n,SCOREFXNS.\n,DNA weights = dna/.\n,/SCOREFXNS.\n,FILTERS.\n,FalseFilter name = falsefilter/.\n,/FILTERS.\n,MOVERS.\n,DnaInterfaceMultiStateDesign name = msd\nscorefxn = DNA task_operations = IFC,IC,AUTOprot,D-\nnaInt pop_size = 20 num_packs = 1 numresults = 0 boltz_\ntemp = 2 anchor_offset = 15 mutate_rate = 0.8 genera-\ntions = 5/.\n,DesignProteinBackboneAroundDNA name = bb\nscorefxn = DNA task_operations = IFC,IC,AUTOprot,D-\nnaInt type = ccd gapspan = 4 spread = 3 cycles_outer = 3\ncycles_inner = 1 temp_initial = 2 temp_final = 0.6/.\n,DnaInterfacePacker name = DnaPack scor-\nefxn = DNA task_operations = IFC,IC,AUTOprot,ProtNo-\nDes,DnaInt binding = 1 probe_specificity = 1/.\n,ParsedProtocol name = bb_msd.\n,Add mover_name = msd/.\n,Add mover_name = bb/.\nRosettaScripts\nPLoS ONE | www.plosone.org 9 June 2011 | Volume 6 | Issue 6 | e20161\n,Add mover_name = msd/.\n,/ParsedProtocol.\n,LoopOver name = iterbb mover_name = bb_msd\nfilter_name = falsefilter iterations = 1/.\n,/MOVERS.\n,PROTOCOLS.\n,Add mover_name = iterbb/.\n,Add mover_name = DnaPack/.\n,/PROTOCOLS.\n,/ROSETTASCRIPTS.\nThe DnaInterfacePacker Mover performs side-chain opti-\nmization and design of protein-DNA interactions, as well as\nspecificity prediction. DnaInterfaceMultiStateDesign em-\nploys a Packer-based genetic algorithm to optimize amino acid\nsequences to maximize the energy discrimination between the\ntarget and alternative DNA sequences, and DesignProtein-\nBackboneAroundDNA introduces small local changes in protein\nbackbone conformation in the vicinity of DNA. The TaskOpera-\ntion RestrictDesignToProteinDNAInterface automatically\nlimits the freedom of amino acid torsions and mutations to the\nrelevant vicinity of the protein-DNA interface.\nSupporting Information\nSupplemental Information S1 Protocols, input, and\noutput files for all examples given in the paper.\n(BZ2)\nAcknowledgments\nRosettaScripts is a collaborative project with contributions from the entire\nRosetta community. We thank the many people who have contributed\nprotocols, insights, and usage reports.\nAuthor Contributions\nConceived and designed the experiments: SJF ALF JEC EMS SDK NK JA\nPM FR GL DB JM. Performed the experiments: SJF ALF JEC EMS SDK\nNK JA PM FR GL. Analyzed the data: SJF ALF JEC EMS SDK NK JA\nPM FR GL DB. Contributed reagents/materials/analysis tools: SJF ALF\nJEC EMS SDK NK JA PM FR GL. Wrote the paper: SJF ALF JEC EMS\nSDK NK JA PM FR GL DB.\nReferences\n1. Kuhlman B, Baker D (2000) Native protein sequences are close to optimal for\ntheir structures. Proc Natl Acad Sci USA 97: 10383–10388.\n2. Kuhlman B, Dantas G, Ireton GC, Varani G, Stoddard BL, et al. (2003) Design\nof a novel globular protein fold with atomic-level accuracy. Science 302:\n1364–1368.\n3. Korkegian A, Black ME, Baker D, Stoddard BL (2005) Computational\nthermostabilization of an enzyme. Science 308: 857–860.\n4. Rothlisberger D, Khersonsky O, Wollacott AM, Jiang L, DeChancie J, et al.\n(2008) Kemp elimination catalysts by computational enzyme design. Nature 453:\n190–195.\n5. Jiang L, Althoff EA, Clemente FR, Doyle L, Rothlisberger D, et al. (2008) De\nnovo computational design of retro-aldol enzymes. Science 319: 1387–1391.\n6. Fleishman SJ, Whitehead TA, Ekiert DC, Dreyfus C, Corn JE, et al. (2011)\nComputational design of proteins targeting the conserved stem region of\ninfluenza hemagglutinin. Science 332: 816–821.\n7. Kortemme T, Joachimiak LA, Bullock AN, Schuler AD, Stoddard BL, et al.\n(2004) Computational redesign of protein-protein interaction specificity. Nat\nStruct Mol Biol 11: 371–379.\n8. Ashworth J, Havranek JJ, Duarte CM, Sussman D, Monnat RJ, Jr., et al. (2006)\nComputational redesign of endonuclease DNA binding and cleavage specificity.\nNature 441: 656–659.\n9. Leaver-Fay A, Tyka M, Lewis SM, Lange OF, Thompson J, et al. (2010)\nRosetta3 an object-oriented software suite for the simulation and design of\nmacromolecules. Methods Enzymol 487: 545–574.\n10. Meyers S (2005) Effective C ++. Boston: Addison-Wesley.\n11. Chaudhury S, Lyskov S, Gray JJ (2010) PyRosetta: a script-based interface for\nimplementing molecular modeling algorithms using Rosetta. Bioinformatics 26:\n689–691.\n12. Lee B, Richards FM (1971) The interpretation of protein structures: estimation\nof static accessibility. J Mol Biol 55: 379–400.\n13. Sandberg WS, Terwilliger TC (1989) Influence of interior packing and\nhydrophobicity on the stability of a protein. Science 245: 54–57.\n14. Sheffler W, Baker D (2009) RosettaHoles: rapid assessment of protein core\npacking for structure prediction, refinement, design, and validation. Protein Sci\n18: 229–239.\n15. Tyka MD, Keedy DA, Andre I, Dimaio F, Song Y, et al. (2010) Alternate States\nof proteins revealed by detailed energy landscape mapping. J Mol Biol 405:\n607–618.\n16. Lerner RA (2006) Manufacturing immunity to disease in a test tube: the magic\nbullet realized. Angew Chem Int Ed Engl 45: 8106–8125.\n17. Leaver-Fay A, Kuhlman B, Snoeyink J (2005) An adaptive dynamic\nprogramming algorithm for the side chain placement problem. Pac Symp\nBiocomput. pp 16–27.\n18. Guntas G, Purbeck C, Kuhlman B (2010) Engineering a protein-protein\ninterface using a computationally designed library. Proc Natl Acad Sci U S A\n107: 19296–19301.\n19. Smith CA, Kortemme T (2008) Backrub-like backbone simulation recapitulates\nnatural protein conformational variability and improves mutant side-chain\nprediction. Joˆ Mol Biol 380: 742–756.\n20. Davis IW, Arendall WB, 3rd, Richardson DC, Richardson JS (2006) The\nbackrub motion: how protein backbone shrugs when a sidechain dances.\nStructure 14: 265–274.\n21. Das R, Baker D (2008) Macromolecular modeling with rosetta. Annu Rev\nBiochem 77: 363–382.\n22. Canutescu AA, Dunbrack RL, Jr. (2003) Cyclic coordinate descent: A robotics\nalgorithm for protein loop closure. Prot Sci 12: 963–972.\n23. Mandell DJ, Coutsias EA, Kortemme T (2009) Sub-angstrom accuracy in\nprotein loop reconstruction by robotics-inspired conformational sampling. Nat\nMethods 6: 551–552.\n24. Zanghellini A, Jiang L, Wollacott AM, Cheng G, Meiler J, et al. (2006) New\nalgorithms and an in silico benchmark for computational enzyme design. Protein\nSci 15: 2785–2794.\n25. Meiler J, Baker D (2006) ROSETTALIGAND: protein-small molecule docking\nwith full side-chain flexibility. Proteins 65: 538–548.\n26. Davis IW, Baker D (2009) RosettaLigand docking with full ligand and receptor\nflexibility. Joˆ Mol Biol 385: 381–392.\n27. Havranek JJ, Duarte CM, Baker D (2004) A simple physical model for the\nprediction and design of protein-DNA interactions. Jo ˆ Mol Biol 344: 59–70.\n28. Ashworth J, Taylor GK, Havranek JJ, Quadri SA, Stoddard BL, et al. (2010)\nComputational reprogramming of homing endonuclease specificity at multiple\nadjacent base pairs. Nucleic Acids Res 38: 5601–5608.\n29. Thyme SB, Jarjour J, Takeuchi R, Havranek JJ, Ashworth J, et al. (2009)\nExploitation of binding energy for catalysis and design. Nature 461: 1300–1304.\n30. Havranek JJ, Baker D (2009) Motif-directed flexible backbone design of\nfunctional interactions. Protein Sci 18: 1293–1305.\nRosettaScripts\nPLoS ONE | www.plosone.org 10 June 2011 | Volume 6 | Issue 6 | e20161",
  "topic": "Scripting language",
  "concepts": [
    {
      "name": "Scripting language",
      "score": 0.7326624393463135
    },
    {
      "name": "Computer science",
      "score": 0.7120450735092163
    },
    {
      "name": "Modeling language",
      "score": 0.5609033703804016
    },
    {
      "name": "XML",
      "score": 0.5398125052452087
    },
    {
      "name": "Docking (animal)",
      "score": 0.4971218407154083
    },
    {
      "name": "Interface (matter)",
      "score": 0.4748390316963196
    },
    {
      "name": "Software engineering",
      "score": 0.45772939920425415
    },
    {
      "name": "Computational biology",
      "score": 0.4564502239227295
    },
    {
      "name": "Software deployment",
      "score": 0.45417970418930054
    },
    {
      "name": "Programming language",
      "score": 0.4449955224990845
    },
    {
      "name": "User interface",
      "score": 0.4422619640827179
    },
    {
      "name": "Distributed computing",
      "score": 0.3621039390563965
    },
    {
      "name": "Software",
      "score": 0.2459082007408142
    },
    {
      "name": "Biology",
      "score": 0.15158143639564514
    },
    {
      "name": "World Wide Web",
      "score": 0.1419215202331543
    },
    {
      "name": "Operating system",
      "score": 0.11481815576553345
    },
    {
      "name": "Maximum bubble pressure method",
      "score": 0.0
    },
    {
      "name": "Medicine",
      "score": 0.0
    },
    {
      "name": "Nursing",
      "score": 0.0
    },
    {
      "name": "Bubble",
      "score": 0.0
    }
  ]
}