{
  "title": "Enhancing the Locality and Breaking the Memory Bottleneck of Transformer on Time Series Forecasting",
  "url": "https://openalex.org/W2954731415",
  "year": 2022,
  "authors": [
    {
      "id": "https://openalex.org/A2067908703",
      "name": "Li Shiyang",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2377546246",
      "name": "Jin Xiao-yong",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2111059734",
      "name": "Xuan Yao",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A4282092677",
      "name": "Zhou, Xiyou",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2347345197",
      "name": "Chen Wen-hu",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2330230905",
      "name": "Wang, Yu-Xiang",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2574579922",
      "name": "Yan, Xifeng",
      "affiliations": []
    }
  ],
  "references": [
    "https://openalex.org/W3125096521",
    "https://openalex.org/W2550848904",
    "https://openalex.org/W2765932895",
    "https://openalex.org/W2891815651",
    "https://openalex.org/W2787214294",
    "https://openalex.org/W2130942839",
    "https://openalex.org/W2797846142",
    "https://openalex.org/W1815076433",
    "https://openalex.org/W1586335931",
    "https://openalex.org/W1810943226",
    "https://openalex.org/W2172140247",
    "https://openalex.org/W2604847698",
    "https://openalex.org/W2607045400",
    "https://openalex.org/W2101926813",
    "https://openalex.org/W2064675550",
    "https://openalex.org/W2963403868",
    "https://openalex.org/W1522301498",
    "https://openalex.org/W2969855422",
    "https://openalex.org/W2519091744",
    "https://openalex.org/W2326533993",
    "https://openalex.org/W2413794162",
    "https://openalex.org/W2798058877",
    "https://openalex.org/W2940744433",
    "https://openalex.org/W2889928394",
    "https://openalex.org/W2963341956",
    "https://openalex.org/W2513671774",
    "https://openalex.org/W2902854273",
    "https://openalex.org/W2624190409",
    "https://openalex.org/W2952202224",
    "https://openalex.org/W2802023636",
    "https://openalex.org/W2773625660",
    "https://openalex.org/W2603648311",
    "https://openalex.org/W2808800115",
    "https://openalex.org/W2798702047",
    "https://openalex.org/W2769802733"
  ],
  "abstract": "Time series forecasting is an important problem across many domains, including predictions of solar plant energy output, electricity consumption, and traffic jam situation. In this paper, we propose to tackle such forecasting problem with Transformer [1]. Although impressed by its performance in our preliminary study, we found its two major weaknesses: (1) locality-agnostics: the point-wise dot-product self-attention in canonical Transformer architecture is insensitive to local context, which can make the model prone to anomalies in time series; (2) memory bottleneck: space complexity of canonical Transformer grows quadratically with sequence length $L$, making directly modeling long time series infeasible. In order to solve these two issues, we first propose convolutional self-attention by producing queries and keys with causal convolution so that local context can be better incorporated into attention mechanism. Then, we propose LogSparse Transformer with only $O(L(\\log L)^{2})$ memory cost, improving forecasting accuracy for time series with fine granularity and strong long-term dependencies under constrained memory budget. Our experiments on both synthetic data and real-world datasets show that it compares favorably to the state-of-the-art.",
  "full_text": "Enhancing the Locality and Breaking the Memory\nBottleneck of Transformer on Time Series Forecasting\nShiyang Li\nshiyangli@ucsb.edu\nXiaoyong Jin\nx_jin@ucsb.edu\nYao Xuan\nyxuan@ucsb.edu\nXiyou Zhou\nxiyou@ucsb.edu\nWenhu Chen\nwenhuchen@ucsb.edu\nYu-Xiang Wang\nyuxiangw@cs.ucsb.edu\nXifeng Yan\nxyan@cs.ucsb.edu\nUniversity of California, Santa Barbara\nAbstract\nTime series forecasting is an important problem across many domains, including\npredictions of solar plant energy output, electricity consumption, and trafﬁc jam\nsituation. In this paper, we propose to tackle such forecasting problem with\nTransformer [1]. Although impressed by its performance in our preliminary study,\nwe found its two major weaknesses: (1) locality-agnostics: the point-wise dot-\nproduct self-attention in canonical Transformer architecture is insensitive to local\ncontext, which can make the model prone to anomalies in time series; (2) memory\nbottleneck: space complexity of canonical Transformer grows quadratically with\nsequence length L, making directly modeling long time series infeasible. In\norder to solve these two issues, we ﬁrst propose convolutional self-attention by\nproducing queries and keys with causal convolution so that local context can\nbe better incorporated into attention mechanism. Then, we propose LogSparse\nTransformer with onlyO(L(log L)2) memory cost, improving forecasting accuracy\nfor time series with ﬁne granularity and strong long-term dependencies under\nconstrained memory budget. Our experiments on both synthetic data and real-\nworld datasets show that it compares favorably to the state-of-the-art.\n1 Introduction\nTime series forecasting plays an important role in daily life to help people manage resources and make\ndecisions. For example, in retail industry, probabilistic forecasting of product demand and supply\nbased on historical data can help people do inventory planning to maximize the proﬁt. Although\nstill widely used, traditional time series forecasting models, such as State Space Models (SSMs) [2]\nand Autoregressive (AR) models, are designed to ﬁt each time series independently. Besides, they\nalso require practitioners’ expertise in manually selecting trend, seasonality and other components.\nTo sum up, these two major weaknesses have greatly hindered their applications in the modern\nlarge-scale time series forecasting tasks.\nTo tackle the aforementioned challenges, deep neural networks [ 3–6] have been proposed as an\nalternative solution, where Recurrent Neural Network (RNN) [7–9] has been employed to model time\nseries in an autoregressive fashion. However, RNNs are notoriously difﬁcult to train [10] because\nof gradient vanishing and exploding problem. Despite the emergence of various variants, including\nLSTM [11] and GRU [ 12], the issues still remain unresolved. As an example, [ 13] shows that\nlanguage models using LSTM have an effective context size of about 200 tokens on average but are\nonly able to sharply distinguish 50 tokens nearby, indicating that even LSTM struggles to capture\n33rd Conference on Neural Information Processing Systems (NeurIPS 2019), Vancouver, Canada.\narXiv:1907.00235v3  [cs.LG]  3 Jan 2020\nlong-term dependencies. On the other hand, real-world forecasting applications often have both\nlong- and short-term repeating patterns [7]. For example, the hourly occupancy rate of a freeway in\ntrafﬁc data has both daily and hourly patterns. In such cases, how to model long-term dependencies\nbecomes the critical step in achieving promising performances.\nRecently, Transformer [1, 14] has been proposed as a brand new architecture which leverages attention\nmechanism to process a sequence of data. Unlike the RNN-based methods, Transformer allows the\nmodel to access any part of the history regardless of distance, making it potentially more suitable\nfor grasping the recurring patterns with long-term dependencies. However, canonical dot-product\nself-attention matches queries against keys insensitive to local context, which may make the model\nprone to anomalies and bring underlying optimization issues. More importantly, space complexity of\ncanonical Transformer grows quadratically with the input length L, which causes memory bottleneck\non directly modeling long time series with ﬁne granularity. We speciﬁcally delve into these two\nissues and investigate the applications of Transformer to time series forecasting. Our contributions\nare three fold:\n•We successfully apply Transformer architecture to time series forecasting and perform extensive\nexperiments on both synthetic and real datasets to validate Transformer’s potential value in better\nhandling long-term dependencies than RNN-based models.\n•We propose convolutional self-attention by employing causal convolutions to produce queries and\nkeys in the self-attention layer. Query-key matching aware of local context, e.g. shapes, can help\nthe model achieve lower training loss and further improve its forecasting accuracy.\n•We propose LogSparse Transformer, with only O(L(log L)2) space complexity to break the\nmemory bottleneck, not only making ﬁne-grained long time series modeling feasible but also\nproducing comparable or even better results with much less memory usage, compared to canonical\nTransformer.\n2 Related Work\nDue to the wide applications of forecasting, various methods have been proposed to solve the problem.\nOne of the most prominent models is ARIMA [15]. Its statistical properties as well as the well-\nknown Box-Jenkins methodology [16] in the model selection procedure make it the ﬁrst attempt for\npractitioners. However, its linear assumption and limited scalability make it unsuitable for large-scale\nforecasting tasks. Further, information across similar time series cannot be shared since each time\nseries is ﬁtted individually. In contrast, [17] models related time series data as a matrix and deal with\nforecasting as a matrix factorization problem. [18] proposes hierarchical Bayesian methods to learn\nacross multiple related count time series from the perspective of graph model.\nDeep neural networks have been proposed to capture shared information across related time series\nfor accurate forecasting. [ 3] fuses traditional AR models with RNNs by modeling a probabilistic\ndistribution in an encoder-decoder fashion. Instead, [19] uses an RNN as an encoder and Multi-layer\nPerceptrons (MLPs) as a decoder to solve the so-called error accumulation issue and conduct multi-\nahead forecasting in parallel. [ 6] uses a global RNN to directly output the parameters of a linear\nSSM at each step for each time series, aiming to approximate nonlinear dynamics with locally linear\nsegments. In contrast, [9] deals with noise using a local Gaussian process for each time series while\nusing a global RNN to model the shared patterns. [20] tries to combine the advantages of AR models\nand SSMs, and maintain a complex latent process to conduct multi-step forecasting in parallel.\nThe well-known self-attention based Transformer [ 1] has recently been proposed for sequence\nmodeling and has achieved great success. Several recent works apply it to translation, speech,\nmusic and image generation [1, 21–23]. However, scaling attention to extremely long sequences is\ncomputationally prohibitive since the space complexity of self-attention grows quadratically with\nsequence length [21]. This becomes a serious issue in forecasting time series with ﬁne granularity\nand strong long-term dependencies.\n2\n3 Background\nProblem deﬁnition Suppose we have a collection of N related univariate time series {zi,1:t0 }N\ni=1,\nwhere zi,1:t0 ≜ [zi,1,zi,2,··· ,zi,t0 ] and zi,t ∈R denotes the value of time series iat time t1. We\nare going to predict the next τ time steps for all time series, i.e. {zi,t0+1:t0+τ}N\ni=1. Besides, let\n{xi,1:t0+τ}N\ni=1 be a set of associated time-based covariate vectors with dimension dthat are assumed\nto be known over the entire time period, e.g. day-of-the-week and hour-of-the-day. We aim to model\nthe following conditional distribution\np(zi,t0+1:t0+τ|zi,1:t0 ,xi,1:t0+τ; Φ) =\nt0+τ∏\nt=t0+1\np(zi,t|zi,1:t−1,xi,1:t; Φ).\nWe reduce the problem to learning a one-step-ahead prediction model p(zt|z1:t−1,x1:t; Φ) 2, where\nΦ denotes the learnable parameters shared by all time series in the collection. To fully utilize both\nthe observations and covariates, we concatenate them to obtain an augmented matrix as follows:\nyt ≜ [zt−1 ◦xt] ∈Rd+1, Yt = [y1,··· ,yt]T ∈Rt×(d+1),\nwhere [·◦·] represents concatenation. An appropriate model zt ∼f(Yt) is then explored to predict\nthe distribution of zt given Yt.\nTransformer We instantiate f with Transformer 3 by taking advantage of the multi-head self-\nattention mechanism, since self-attention enables Transformer to capture both long- and short-term\ndependencies, and different attention heads learn to focus on different aspects of temporal patterns.\nThese advantages make Transformer a good candidate for time series forecasting. We brieﬂy introduce\nits architecture here and refer readers to [1] for more details.\nIn the self-attention layer, a multi-head self-attention sublayer simultaneously transforms Y 4 into H\ndistinct query matrices Qh = YWQ\nh, key matrices Kh = YWK\nh , and value matrices Vh = YWV\nh\nrespectively, withh= 1,··· ,H. Here WQ\nh,WK\nh ∈R(d+1)×dk and WV\nh ∈R(d+1)×dv are learnable\nparameters. After these linear projections, the scaled dot-product attention computes a sequence of\nvector outputs:\nOh = Attention(Qh,Kh,Vh) =softmax\n(QhKT\nh√dk\n·M\n)\nVh.\nNote that a mask matrix M is applied to ﬁlter out rightward attention by setting all upper triangular\nelements to −∞, in order to avoid future information leakage. Afterwards, O1,O2,··· ,OH are\nconcatenated and linearly projected again. Upon the attention output, a position-wise feedforward\nsublayer with two layers of fully-connected network and a ReLU activation in the middle is stacked.\n4 Methodology\n4.1 Enhancing the locality of Transformer\nPatterns in time series may evolve with time signiﬁcantly due to various events, e.g. holidays and\nextreme weather, so whether an observed point is an anomaly, change point or part of the patterns\nis highly dependent on its surrounding context. However, in the self-attention layers of canonical\nTransformer, the similarities between queries and keys are computed based on their point-wise values\nwithout fully leveraging local context like shape, as shown in Figure 1(a) and (b). Query-key matching\nagnostic of local context may confuse the self-attention module in terms of whether the observed\nvalue is an anomaly, change point or part of patterns, and bring underlying optimization issues.\nWe propose convolutional self-attention to ease the issue. The architectural view of proposed\nconvolutional self-attention is illustrated in Figure 1(c) and (d). Rather than using convolution of\n1Here time index tis relative, i.e. the same tin different time series may represent different actual time point.\n2Since the model is applicable to all time series, we omit the subscript ifor simplicity and clarity.\n3By referring to Transformer, we only consider the autoregressive Transformer-decoder in the following.\n4At each time step the same model is applied, so we simplify the formulation with some abuse of notation.\n3\n    Masked Multi-Head Attention     Masked Multi-Head Attention\nQ V K\nConv, 1 Conv, 1 Conv, 1 Conv, k Conv, 1 Conv, k\nQ V K\n(a) (b) (c) (d)\nFigure 1: The comparison between canonical and our convolutional self-attention layers. “Conv,\n1” and “Conv, k” mean convolution of kernel size {1, k} with stride 1, respectively. Canonical\nself-attention as used in Transformer is shown in (b), may wrongly match point-wise inputs as shown\nin (a). Convolutional self-attention is shown in (d), which uses convolutional layers of kernel size k\nwith stride 1 to transform inputs (with proper paddings) into queries/keys. Such locality awareness\ncan correctly match the most relevant features based on shape matching in (c).\nMon Tue Wed Thu Fri Sat Sun Mon\n0.00\n0.05\n0.10\n0.15\n0.20 occupancy rate\nattn score in layer 2\nattn score in layer 6\nattn score in layer 10\nFigure 2: Learned attention patterns from a 10-layer canonical Transformer trained on traffic-f\ndataset with full attention. The green dashed line indicates the start time of forecasting and the\ngray dashed line on its left side is the conditional history. Blue, cyan and red lines correspond to\nattention patterns in layer 2, 6 and 10, respectively, for a head when predicting the value at the time\ncorresponding to the green dashed line. a) Layer 2 tends to learn shared patterns in every day. b)\nLayer 6 focuses more on weekend patterns. c) Layer 10 further squeezes most of its attention on only\nseveral cells in weekends, causing most of the others to receive little attention.\nkernel size 1 with stride 1 (matrix multiplication), we employ causal convolutionof kernel size k\nwith stride 1 to transform inputs (with proper paddings) into queries and keys. Note that causal\nconvolutions ensure that the current position never has access to future information. By employing\ncausal convolution, generated queries and keys can be more aware of local context and hence, compute\ntheir similarities by their local context information, e.g. local shapes, instead of point-wise values,\nwhich can be helpful for accurate forecasting. Note that when k= 1, the convolutional self-attention\nwill degrade to canonical self-attention, thus it can be seen as a generalization.\n4.2 Breaking the memory bottleneck of Transformer\nTo motivate our approach, we ﬁrst perform a qualitative assessment of the learned attention patterns\nwith a canonical Transformer on traffic-f dataset. The traffic-f dataset contains occupancy\nrates of 963 car lanes of San Francisco bay area recorded every 20 minutes [6]. We trained a 10-layer\ncanonical Transformer on traffic-f dataset with full attention and visualized the learned attention\npatterns. One example is shown in Figure 2. Layer 2 clearly exhibited global patterns, however, layer\n6 and 10, only exhibited pattern-dependent sparsity, suggesting that some form of sparsity could be\nintroduced without signiﬁcantly affecting performance. More importantly, for a sequence with length\nL, computing attention scores between every pair of cells will cause O(L2) memory usage, making\nmodeling long time series with ﬁne granularity and strong long-term dependencies prohibitive.\nWe propose LogSparse Transformer, which only needs to calculate O(log L) dot products for each\ncell in each layer. Further, we only need to stack up to O(log L) layers and the model will be able to\naccess every cell’s information. Hence, the total cost of memory usage is only O(L(log L)2). We\ndeﬁne Ik\nl as the set of indices of the cells that cell lcan attend to during the computation from kth\n4\n(a). Full Self Attention (b). LogSparse Self Attention\n(d). Restart Attention + LogSparse Self Attention(c). Local Attention + LogSparse Self Attention\nLogSparse Attention Range LogSparse Attention Range LogSparse Attention RangeLocal Attention Range\nSelf LogSparse Attention Range Self\nSelfSelf\nFigure 3: Illustration of different attention mechanism between adjacent layers in Transformer.\nlayer to (k+ 1)th layer. In the standard self-attention of Transformer, Ik\nl = {j : j ≤l}, allowing\nevery cell to attend to all its past cells and itself as shown in Figure 3(a). However, such an algorithm\nsuffers from the quadratic space complexity growth along with the input length. To alleviate such an\nissue, we propose to select a subset of the indices Ik\nl ⊂{j : j ≤l}so that |Ik\nl |does not grow too\nfast along with l. An effective way of choosing indices is |Ik\nl |∝ log L.\nNotice that cell lis a weighted combination of cells indexed by Ik\nl in kth self-attention layer and can\npass the information of cells indexed by Ik\nl to its followings in the next layer. Let Sk\nl be the set which\ncontains indices of all the cells whose information has passed to cell lup to kth layer. To ensure that\nevery cell receives the information from all its previous cells and itself, the number of stacked layers\n˜kl should satisfy that S\n˜kl\nl = {j : j ≤l}for l= 1,··· ,L. That is, ∀land j ≤l, there is a directed\npath Pjl = (j,p1,p2,··· ,l) with ˜kl edges, where j ∈I1\np1 , p1 ∈I2\np2 , ··· , p˜kl−1 ∈I\n˜kl\nl .\nWe propose LogSparse self-attention by allowing each cell only to attend to its previous cells\nwith an exponential step size and itself. That is, ∀kand l, Ik\nl = {l−2⌊log2 l⌋,l −2⌊log2 l⌋−1,l −\n2⌊log2 l⌋−2,...,l −20,l}, where ⌊·⌋denotes the ﬂoor operation, as shown in Figure 3(b).5\nTheorem 1. ∀land j ≤l, there is at least one path from celljto celllif we stack⌊log2 l⌋+ 1layers.\nMoreover, forj <l, the number of feasible unique paths from celljto celllincreases at a rate of\nO(⌊log2(l−j)⌋!).\nThe proof, deferred to Appendix A.1, uses a constructive argument.\nTheorem 1 implies that despite an exponential decrease in the memory usage (from O(L2) to\nO(Llog2 L)) in each layer, the information could still ﬂow from any cell to any other cell provided\nthat we go slightly “deeper” — take the number of layers to be ⌊log2 L⌋+ 1. Note that this implies\nan overall memory usage of O(L(log2 L)2) and addresses the notorious scalability bottleneck of\nTransformer under GPU memory constraint [1]. Moreover, as two cells become further apart, the\nnumber of paths increases at a rate of super-exponential in log2(l −j), which indicates a rich\ninformation ﬂow for modeling delicate long-term dependencies.\nLocal Attention We can allow each cell to densely attend to cells in its left window of size\nO(log2 L) so that more local information, e.g. trend, can be leveraged for current step forecasting.\nBeyond the neighbor cells, we can resume our LogSparse attention strategy as shown in Figure 3(c).\nRestart Attention Further, one can divide the whole input with length Linto subsequences and set\neach subsequence length Lsub ∝L. For each of them, we apply the LogSparse attention strategy.\nOne example is shown in Figure 3(d).\nEmploying local attentionand restart attentionwon’t change the complexity of our sparse attention\nstrategy but will create more paths and decrease the required number of edges in the path. Note that\none can combine local attention and restart attention together.\n5Applying other bases is trivial so we don’t discuss other bases here for simplicity and clarity.\n5\n5 Experiments\n5.1 Synthetic datasets\nTo demonstrate Transformer’s capability to capture long-term dependencies, we conduct experiments\non synthetic data. Speciﬁcally, we generate a piece-wise sinusoidal signals\nf(x) =\n\n\n\nA1 sin(πx/6) + 72 +Nx x∈[0,12),\nA2 sin(πx/6) + 72 +Nx x∈[12,24),\nA3 sin(πx/6) + 72 +Nx x∈[24,t0),\nA4 sin(πx/12) + 72 +Nx x∈[t0,t0 + 24),\nwhere xis an integer, A1,A2,A3 are randomly generated by uniform distribution on [0,60], A4 =\nmax(A1,A2) and Nx ∼N(0,1). Following the forecasting setting in Section 3, we aim to predict\nthe last 24 steps given the previous t0 data points. Intuitively, larger t0 makes forecasting more\ndifﬁcult since the model is required to understand and remember the relation between A1 and A2\nto make correct predictions after t0 −24 steps of irrelevant signals. Hence, we create 8 different\ndatasets by varying the value of t0 within {24,48,72,96,120,144,168,192}. For each dataset, we\ngenerate 4.5K, 0.5K and 1K time series instances for training, validation and test set, respectively.\nAn example time series with t0 = 96is shown in Figure 4(a).\nIn this experiment, we use a 3-layer canonical Transformer with standard self-attention. For com-\nparison, we employ DeepAR [3], an autoregressive model based on a 3-layer LSTM, as our baseline.\nBesides, to examine if larger capacity could improve performance of DeepAR, we also gradually\nincrease its hidden size has {20,40,80,140,200}. Following [3, 6], we evaluate both methods using\nρ-quantile loss Rρ with ρ∈(0,1),\nRρ(x,ˆx) =\n2 ∑\ni,tDρ(x(i)\nt ,ˆx(i)\nt )\n∑\ni,t|x(i)\nt |\n, D ρ(x,ˆx) = (ρ−I{x≤ˆx})(x−ˆx),\nwhere ˆxis the empirical ρ-quantile of the predictive distribution and I{x≤ˆx}is an indicator function.\nFigure 4: (a) An example time series with t0 = 96.\nBlack line is the conditional history while red\ndashed line is the target. (b) Performance compar-\nison between DeepAR and canonical Transformer\nalong with the growth of t0.The larger t0 is, the\nlonger dependencies the models need to capture\nfor accurate forecasting.\nFigure 4(b) presents the performance of DeepAR\nand Transformer on the synthetic datasets.\nWhen t0 = 24, both of them perform very well.\nBut, as t0 increases, especially when t0 ≥96,\nthe performance of DeepAR drops signiﬁcantly\nwhile Transformer keeps its accuracy, suggest-\ning that Transformer can capture fairly long-\nterm dependencies when LSTM fails to do so.\n5.2 Real-world datasets\nWe further evaluate our model on several real-\nworld datasets. The electricity-f (fine)\ndataset consists of electricity consumption of\n370 customers recorded every 15 minutes and\nthe electricity-c (coarse) dataset is the\naggregated electricity-f by every 4 points,\nproducing hourly electricity consumption. Sim-\nilarly, the traffic-f (fine) dataset contains\noccupancy rates of 963 freeway in San Francisco\nrecorded every 20 minutes and the traffic-c\n(coarse) contains hourly occupancy rates by\naveraging every 3 points in traffic-f. The\nsolar dataset6 contains the solar power pro-\nduction records from January to August in 2006,\nwhich is sampled every hour from 137 PV plants\nin Alabama. The wind7 dataset contains daily\n6https://www.nrel.gov/grid/solar-power-data.html\n7https://www.kaggle.com/sohier/30-years-of-european-wind-generation\n6\nTable 1: Results summary (R0.5/R0.9-loss) of all methods. e-c and t-c represent electricity-c\nand traffic-c, respectively. In the 1st and 3rd row, we perform rolling-day prediction of 7 days\nwhile in the 2nd and 4th row, we directly forecast 7 days ahead. TRMF outputs points predictions, so\nwe only report R0.5. ⋄denotes results from [6].\nARIMA ETS TRMF DeepAR DeepState Ours\ne-c1d 0.154/0.102 0.101/0.077 0.084/- 0.075 ⋄/0.040⋄ 0.083⋄/0.056⋄ 0.059/0.034\ne-c7d 0.283⋄/0.109⋄ 0.121⋄/0.101⋄ 0.087/- 0.082/0.053 0.085 ⋄/0.052⋄ 0.070/0.044\nt-c1d 0.223/0.137 0.236/0.148 0.186/- 0.161 ⋄/0.099⋄ 0.167⋄/0.113⋄ 0.122/0.081\nt-c7d 0.492⋄/0.280⋄ 0.509⋄/0.529⋄ 0.202/- 0.179/0.105 0.168 ⋄/0.114⋄ 0.139/0.094\n0 2 4 6 8 10 12 14\niter. (1e4)\n3.8\n3.6\n3.4\n3.2\n3.0\n2.8\n2.6\n2.4\ntraining loss (NLL)\nk=1\nk=3\nk=9\n0 2 4 6 8 10 12 14\niter. (1e4)\n7.0\n7.2\n7.4\n7.6\n7.8training loss (NLL)\nk=1\nk=3\nk=9\nFigure 5: Training curve comparison (with proper smoothing) among kernel size k ∈{1,3,9}in\ntraffic-c (left) and electricity-c (right) dataset. Being aware of larger local context size, the\nmodel can achieve lower training error and converge faster.\nestimates of 28 countries’ energy potential from 1986 to 2015 as a percentage of a power plant’s\nmaximum output. The M4-Hourly contains 414 hourly time series from M4 competition [24].\nLong-term and short-term forecasting We ﬁrst show the effectiveness of canonical Trans-\nformer equipped with convolutional self-attention in long-term and short-term forecasting in\nelectricity-c and traffic-c dataset. These two datasets exhibit both hourly and daily sea-\nsonal patterns. However, traffic-c demonstrates much greater difference between the patterns of\nweekdays and weekends compared to electricity-c. Hence, accurate forecasting in traffic-c\ndataset requires the model to capture both long- and short-term dependencies very well. As baselines,\nwe use classical forecasting methods auto.arima, ets implemented in R’sforecast package and\nthe recent matrix factorization method TRMF [17], a RNN-based autoregressive model DeepAR and a\nRNN-based state space model DeepState [6]. For short-term forecasting, we evaluate rolling-day\nforecasts for seven days ( i.e., prediction horizon is one day and forecasts start time is shifted by one\nday after evaluating the prediction for the current day [6]). For long-term forecasting, we directly\nforecast 7 days ahead. As shown in Table 1, our models with convolutional self-attention get betters\nresults in both long-term and short-term forecasting, especially in traffic-c dataset compared to\nstrong baselines, partly due to the long-term dependency modeling ability of Transformer as shown\nin our synthetic data.\nConvolutional self-attention In this experiment, we conduct ablation study of our proposed convo-\nlutional self-attention. We explore different kernel size k∈{1,2,3,6,9}on the full attention model\nand ﬁx all other settings. We still use rolling-day prediction for seven days on electricity-c and\ntraffic-c datasets. The results of different kernel sizes on both datasets are shown in Table 2. On\nelectricity-c dataset, models with kernel size k ∈{2,3,6,9}obtain slightly better results in\nterm of R0.5 than canonical Transformer but overall these results are comparable and all of them\nperform very well. We argue it is because electricity-c dataset is less challenging and covariate\nvectors have already provided models with rich information for accurate forecasting. Hence, being\naware of larger local context may not help a lot in such cases. However, on much more challenging\ntraffic-c dataset, the model with larger kernel size kcan make more accurate forecasting than\nmodels with smaller ones with as large as 9% relative improvement. These consistent gains can be\nthe results of more accurate query-key matching by being aware of more local context. Further, to\nverify if incorporating more local context into query-key matching can ease the training, we plot the\n7\nTable 2: Average R0.5/R0.9-loss of different kernel sizes for rolling-day prediction of 7 days.\nk= 1 k= 2 k= 3 k= 6 k= 9\nelectricity-c1d 0.060/0.030 0.058/0.030 0.057 /0.031 0.057/0.031 0.059/0.034\ntraffic-c1d 0.134/0.089 0.124/0.085 0.123/0.083 0.123/0.083 0.122/0.081\ntraining loss of kernel size k∈{1,3,9}in electricity-c and traffic-c datasets. We found that\nTransformer with convolutional self-attention also converged faster and to lower training errors, as\nshown in Figure 5, proving that being aware of local context can ease the training process.\nSparse attention Further, we compare our proposed LogSparse Transformer to the full attention\ncounterpart on ﬁne-grained datasets, electricity-f and traffic-f. Note that time series in\nthese two datasets have much longer periods and are noisier comparing to electricity-c and\ntraffic-c. We ﬁrst compare them under the same memory budget. For electricity-f dataset,\nwe choose Le1 = 768with subsequence length Le1 /8 and local attention length log2(Le1 /8) in each\nsubsequence for our sparse attention model and Le2 = 293in the full attention counterpart. For\ntraffic-f dataset, we select Lt1 = 576with subsequence length Lt1 /8 and local attention length\nlog2(Lt1 /8) in each subsequence for our sparse attention model, and Lt2 = 254in the full attention\ncounterpart. The calculation of memory usage and other details can be found in Appendix A.4. We\nconduct experiments on aforementioned sparse and full attention models with/without convolutional\nself-attention on both datasets. By following such settings, we summarize our results in Table 3\n(Upper part). No matter equipped with convolutional self-attention or not, our sparse attention models\nachieve comparable results on electricity-f but much better results on traffic-f compared\nto its full attention counterparts. Such performance gain on traffic-f could be the result of the\ndateset’s stronger long-term dependencies and our sparse model’s better capability of capturing these\ndependencies, which, under the same memory budget, the full attention model cannot match. In\naddition, both sparse and full attention models beneﬁt from convolutional self-attention on challenging\ntraffic-f, proving its effectiveness.\nTo explore how well our sparse attention model performs compared to full attention model with\nthe same input length, we set Le2 = Le1 = 768and Lt2 = Lt1 = 576on electricity-f and\ntraffic-f, respectively. The results of their comparisons are summarized in Table 3 (Lower part).\nAs one expects, full attention Transformers can outperform our sparse attention counterparts no matter\nthey are equipped with convolutional self-attention or not in most cases. However, ontraffic-f\ndataset with strong long-term dependencies, our sparse Transformer with convolutional self-attention\ncan get better results than the canonical one and, more interestingly, even slightly outperform its full\nattention counterpart in term of R0.5, meaning that our sparse model with convolutional self-attention\ncan capture long-term dependencies fairly well. In addition, full attention models under length\nconstraint consistently obtain gains from convolutional self-attention on both electricity-f and\ntraffic-f datasets, showing its effectiveness again.\nTable 3: Average R0.5/R0.9-loss comparisons between sparse attention and full attention models\nwith/without convolutional self-attention by rolling-day prediction of 7 days. “Full” means models\nare trained with full attention while “Sparse” means they are trained with our sparse attention strategy.\n“+ Conv” means models are equipped with convolutional self-attention with kernel sizek= 6.\nConstraint Dataset Full Sparse Full + Conv Sparse + Conv\nMemory electricity-f1d 0.083/0.051 0.084/ 0.047 0.078 /0.048 0.079/0.049\ntraffic-f1d 0.161/0.109 0.150/0.098 0.149/0.102 0.138/0.092\nLength electricity-f1d 0.082/0.047 0.084/0.047 0.074/0.042 0.079/0.049\ntraffic-f1d 0.147/0.096 0.150/0.098 0.139/ 0.090 0.138 /0.092\nFurther Exploration In our last experiment, we evaluate how our methods perform on datasets\nwith various granularities compared to our baselines. All datasets except M4-Hourly are evaluated\nby rolling window 7 times since the test set of M4-Hourly has been provided. The results are shown\nin Table 4. These results further show that our method achieves the best performance overall.\n8\nTable 4: R0.5/R0.9-loss of datasets with various granularities. The subscript of each dataset presents\nthe forecasting horizon (days). TRMF is not applicable for M4-Hourly2d and we leave it blank. For\nother datasets, TRMF outputs points predictions, so we only report R0.5. ⋄denotes results from [10].\nelectricity-f1d traffic-f1d solar1d M4-Hourly2d wind30d\nTRMF 0.094/- 0.213/- 0.241/- -/- 0.311/-\nDeepAR 0.082/0.063 0.230/0.150 0.222/0.093 0.090 ⋄/0.030⋄ 0.286/0.116\nOurs 0.074/0.042 0.139/0.090 0.210 /0.082 0.067 /0.025 0.284 /0.108\n6 Conclusion\nIn this paper, we propose to apply Transformer in time series forecasting. Our experiments on\nboth synthetic data and real datasets suggest that Transformer can capture long-term dependencies\nwhile LSTM may suffer. We also showed, on real-world datasets, that the proposed convolutional\nself-attention further improves Transformer’ performance and achieves state-of-the-art in different\nsettings in comparison with recent RNN-based methods, a matrix factorization method, as well as\nclassic statistical approaches. In addition, with the same memory budget, our sparse attention models\ncan achieve better results on data with long-term dependencies. Exploring better sparsity strategy in\nself-attention and extending our method to better ﬁt small datasets are our future research directions.\nReferences\n[1] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz\nKaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information processing\nsystems, pages 5998–6008, 2017.\n[2] James Durbin and Siem Jan Koopman. Time series analysis by state space methods. Oxford university\npress, 2012.\n[3] Valentin Flunkert, David Salinas, and Jan Gasthaus. Deepar: Probabilistic forecasting with autoregressive\nrecurrent networks. arXiv preprint arXiv:1704.04110, 2017.\n[4] Alex Graves. Generating sequences with recurrent neural networks. arXiv preprint arXiv:1308.0850, 2013.\n[5] Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In\nAdvances in neural information processing systems, pages 3104–3112, 2014.\n[6] Syama Sundar Rangapuram, Matthias W Seeger, Jan Gasthaus, Lorenzo Stella, Yuyang Wang, and Tim\nJanuschowski. Deep state space models for time series forecasting. In Advances in Neural Information\nProcessing Systems, pages 7785–7794, 2018.\n[7] Guokun Lai, Wei-Cheng Chang, Yiming Yang, and Hanxiao Liu. Modeling long-and short-term temporal\npatterns with deep neural networks. In The 41st International ACM SIGIR Conference on Research &\nDevelopment in Information Retrieval, pages 95–104. ACM, 2018.\n[8] Rose Yu, Stephan Zheng, Anima Anandkumar, and Yisong Yue. Long-term forecasting using tensor-train\nrnns. arXiv preprint arXiv:1711.00073, 2017.\n[9] Danielle C Maddix, Yuyang Wang, and Alex Smola. Deep factors with gaussian processes for forecasting.\narXiv preprint arXiv:1812.00098, 2018.\n[10] Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difﬁculty of training recurrent neural\nnetworks. In International conference on machine learning, pages 1310–1318, 2013.\n[11] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural computation, 9(8):1735–1780,\n1997.\n[12] Kyunghyun Cho, Bart Van Merriënboer, Dzmitry Bahdanau, and Yoshua Bengio. On the properties of\nneural machine translation: Encoder-decoder approaches. arXiv preprint arXiv:1409.1259, 2014.\n[13] Urvashi Khandelwal, He He, Peng Qi, and Dan Jurafsky. Sharp nearby, fuzzy far away: How neural\nlanguage models use context. arXiv preprint arXiv:1805.04623, 2018.\n9\n[14] Ankur P Parikh, Oscar Täckström, Dipanjan Das, and Jakob Uszkoreit. A decomposable attention model\nfor natural language inference. arXiv preprint arXiv:1606.01933, 2016.\n[15] George EP Box and Gwilym M Jenkins. Some recent advances in forecasting and control. Journal of the\nRoyal Statistical Society. Series C (Applied Statistics), 17(2):91–109, 1968.\n[16] George EP Box, Gwilym M Jenkins, Gregory C Reinsel, and Greta M Ljung. Time series analysis:\nforecasting and control. John Wiley & Sons, 2015.\n[17] Hsiang-Fu Yu, Nikhil Rao, and Inderjit S Dhillon. Temporal regularized matrix factorization for high-\ndimensional time series prediction. In Advances in neural information processing systems, pages 847–855,\n2016.\n[18] Nicolas Chapados. Effective bayesian modeling of groups of related count time series. arXiv preprint\narXiv:1405.3738, 2014.\n[19] Ruofeng Wen, Kari Torkkola, Balakrishnan Narayanaswamy, and Dhruv Madeka. A multi-horizon quantile\nrecurrent forecaster. arXiv preprint arXiv:1711.11053, 2017.\n[20] Xiaoyong Jin, Shiyang Li, Yunkai Zhang, and Xifeng Yan. Multi-step deep autoregressive fore-\ncasting with latent states. URL http://roseyu.com/time-series-workshop/submissions/2019/timeseries-\nICML19_paper_19.pdf, 2019.\n[21] Cheng-Zhi Anna Huang, Ashish Vaswani, Jakob Uszkoreit, Noam Shazeer, Curtis Hawthorne, Andrew M\nDai, Matthew D Hoffman, and Douglas Eck. An improved relative self-attention mechanism for transformer\nwith application to music generation. arXiv preprint arXiv:1809.04281, 2018.\n[22] Daniel Povey, Hossein Hadian, Pegah Ghahremani, Ke Li, and Sanjeev Khudanpur. A time-restricted\nself-attention layer for asr. In 2018 IEEE International Conference on Acoustics, Speech and Signal\nProcessing (ICASSP), pages 5874–5878. IEEE, 2018.\n[23] Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, Łukasz Kaiser, Noam Shazeer, Alexander Ku, and Dustin\nTran. Image transformer. arXiv preprint arXiv:1802.05751, 2018.\n[24] Spyros Makridakis, Evangelos Spiliotis, and Vassilios Assimakopoulos. The m4 competition: Results,\nﬁndings, conclusion and way forward. International Journal of Forecasting, 34(4):802–808, 2018.\n[25] Tomaso Poggio, Hrushikesh Mhaskar, Lorenzo Rosasco, Brando Miranda, and Qianli Liao. Why and when\ncan deep-but not shallow-networks avoid the curse of dimensionality: a review. International Journal of\nAutomation and Computing, 14(5):503–519, 2017.\n[26] Kunihiko Fukushima. Neocognitron: A self-organizing neural network model for a mechanism of pattern\nrecognition unaffected by shift in position. Biological cybernetics, 36(4):193–202, 1980.\n[27] Hrushikesh N Mhaskar and Tomaso Poggio. Deep vs. shallow networks: An approximation theory\nperspective. Analysis and Applications, 14(06):829–848, 2016.\n[28] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint\narXiv:1412.6980, 2014.\n[29] Aäron Van Den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal\nKalchbrenner, Andrew W Senior, and Koray Kavukcuoglu. Wavenet: A generative model for raw audio.\nSSW, 125, 2016.\n[30] Anastasia Borovykh, Sander Bohte, and Cornelis W Oosterlee. Conditional time series forecasting with\nconvolutional neural networks. arXiv preprint arXiv:1703.04691, 2017.\n[31] Scott Gray, Alec Radford, and Diederik P. Kingma. Gpu kernels for block-sparse weights. arXiv preprint\narXiv:1711.09224, 2017.\n[32] Tim Cooijmans, Nicolas Ballas, César Laurent, Ça˘glar Gülçehre, and Aaron Courville. Recurrent batch\nnormalization. arXiv preprint arXiv:1603.09025, 2016.\n[33] Rose Yu, Yaguang Li, Cyrus Shahabi, Ugur Demiryurek, and Yan Liu. Deep learning: A generic approach\nfor extreme condition trafﬁc forecasting. In Proceedings of the 2017 SIAM International Conference on\nData Mining, pages 777–785. SIAM, 2017.\n[34] Guoqiang Zhang, B Eddy Patuwo, and Michael Y Hu. Forecasting with artiﬁcial neural networks:: The\nstate of the art. International journal of forecasting, 14(1):35–62, 1998.\n10\n[35] Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse\ntransformers. arXiv preprint arXiv:1904.10509, 2019.\n[36] Peter J Liu, Mohammad Saleh, Etienne Pot, Ben Goodrich, Ryan Sepassi, Lukasz Kaiser, and Noam\nShazeer. Generating wikipedia by summarizing long sequences. arXiv preprint arXiv:1801.10198, 2018.\n[37] Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving language under-\nstanding by generative pre-training. URL https://s3-us-west-2. amazonaws. com/openai-assets/research-\ncovers/languageunsupervised/language understanding paper. pdf, 2018.\n[38] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirec-\ntional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.\n[39] Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse\ntransformers. arXiv preprint arXiv:1904.10509, 2019.\n[40] Nikolay Laptev, Jason Yosinski, Li Erran Li, and Slawek Smyl. Time-series extreme event forecasting with\nneural networks at uber. In International Conference on Machine Learning, number 34, pages 1–5, 2017.\n11\nA Supplementary Materials\nA.1 Proof of Theorem 1\nProof. According to the attention strategy in LogSparse Transformer, in each layer, cell lcould attend to the\ncells with indicies in Ik\nl = {l−2⌊log2 l⌋,l −2⌊log2 l⌋−1,l −2⌊log2 l⌋−2,··· ,l −20,l}. To ensure that every\ncell receives the information from all its previous cells and itself, the number of stacked layers ˜kl should satisfy\nthat S\n˜kl\nl = {j : j ≤l}for l= 1,··· ,L. That is, ∀land j ≤l, there is a directed path Pjl = (j,p1,p2,··· ,l)\nwith ˜kl edges, where j ∈I1\np1 , p1 ∈I2\np2 ,··· ,p˜kl−1 ∈I\n˜kl\nl . We prove the theorem by constructing a path\nfrom cell jto cell l, with length (number of edges) no larger than ⌊log2 l⌋+ 1. Case j = lis trivial, we only\nneed to consider j <lhere. Consider the binary representation of l−j, l−j = ∑⌊log2(l−j)⌋\nm=0 bm2m, where\nbm ∈{0,1}. Suppose {msub}is the subsequence {m|0 ≤m≤⌊log2(l−j)⌋,bm = 1}and mp is the pth\nelement of {msub}. A feasible path from jto lis Pjl = {j,j + 2m0 ,j + 2m0 + 2m1 ,··· ,l}. The length of\nthis path is |{msub}|, which is no larger than ⌊log2(l−j)⌋+ 1. So\nmin {˜kl|S\n˜kl\nl = {j : j ≤l}}≤ max\n{j|j<l}\n⌊log2(l−j)⌋+ 1≤⌊log2 l⌋+ 1.\nFurthermore, by reordering {msub}, we can generate multiple different paths from cell jto cell l. The number\nof feasible paths increases at a rate of O(⌊log2(l−j)⌋!) along with l.\nA.2 Training\nTable 5: Dataset statistics. \"T\", \"M\" and \"S\" represent the length, number and sample rate of the time\nseries, respectively.\nelectricity-c electricity-f traffic-c traffic-f wind solar M4-Hourly\nT 32304 129120 4049 12435 10957 5832 748/1008\nM 370 370 963 963 28 137 414\nS 1 hour 15 mins 1 hour 20 mins 1 day 1 hour 1 hour\nTo learn the model, we are given a time series dataset {zi,1:T}M\ni=1 and its associated covariates {xi,1:T}M\ni=1,\nwhere T is the length of all available observations and M is the number of different time series. The dataset\nstatistics is shown as Table 5. Following [3], we create training instances by selecting windows with ﬁxed history\nlength t0 and forecasting horizon τ but varying the start point of forecasting from each of the original long\ntime series. As a follow-up of [3], we sample training windows through weight sampling strategy in [3]. Note\nthat during selecting training windows, data in the test set can never be accessed. As a result, we get a training\ndataset with N sliding windows {zi,1:t0+τ,xi,1:t0+τ}N\ni=1.\nFor positional encoding in Transformer, we use learnable position embedding. For covariates, following [3], we\nuse all or part of year, month, day-of-the-week, hour-of-the-day, minute-of-the-hour, age and time-series-ID\naccording to the granularities of datasets. age is the distance to the ﬁrst observation in that time series [3]. Each\nof them except time series IDhas only one dimension and is normalized to have zero mean and unit variance (if\napplicable). For time-series-ID, it has the same dimension as position embeddingthrough ID embeddingmatrix\nso that they can be summed up (with broadcasting). The summation is then concatnated with aforementioned\nother covariates as the input of 1st layer in Transformer.\nDeepAR [3] uses an encoder-decoder fashion, where the encoder is the same as the decoder and the ﬁnal hidden\nstate of the encoder is used to initialize the hidden state of the decoder. Such an architecture can be seen as a\ndecoder-only network as the encoder and decoder are the same, where the objective is to predict the distribution\nof next point according to current input and last hidden state. Inspired by this observation, we use Transformer\ndecoder-only mode [36] to model time series. Similar to [37], a fully-connected layer on the top of Transformer\nis stacked, which outputs the parameters of the probability distribution after scaling for the next time point with\nappropriate transformations. For example, for parameters requiring positivity, a softplus activation is applied. We\nuse the same scale handling technique as in [3] to scale our input and output of our models. We refer readers to\n[3] for more details of scale handling. In our experiments, we use Gaussian likelihood since our training datasets\nare real-valued data. Note that one can also use other likelihood models, e.g. negative-binomial likelihood for\npositive count data. In synthetic datasets, we only count log-likelihood from t0 + 1to t0 + τ. On real-world\ndatasets, we not only count log-likelihood from t0 + 1to t0 + τ, but also include the log-likelihood from 1 to t0,\nsimilar to training in [3] and pre-training in [37].\nDuring training, we use vanilla Adam optimizer [28] with early stopping except experiments onelectricity-f\nand traffic-f to maximize the log-likelihood of each training instance. Our preliminary study show that\n12\ntraining on these two datasets are very unstable with Adam. Rather, we found that BERTAdam [38] 8 , a variant\nof Adam with warmup and learning rate annealing, can stabilize the training process on these two datasets.\nFor electricity-c and traffic-c, we take 500K training windows while for electricity-f and\ntraffic-f, we select 125K and 200K training windows, respectively. For wind, M4-Hourly and solar,\nwe choose 10K, 50K and 50K training windows, respectively. The window selection strategy is described above.\nFor our Transformer models, all of them use H = 8heads and the dimension of position embeddingand time\nseries ID embeddingare all 20. All of our models have 3 layers except experiments on electricity-f and\ntraffic-f, where our models use 6 and 10 layers, respectively. The data before the forecast start time is used\nas the training set and split into two partitions. For each experiment on real-world datasets, we train our model\non the ﬁrst partition of the training set containing 90% of the data 5 times with different random seeds and\nwe pick the one that has the minimal negative log-likelihood on the remaining 10%. The results on test set\ncorresponding to minimal negative log-likelihood on the remaining 10% are reported. All models are trained on\nGTX 1080 Ti GPUs.\nA.3 Evaluation\nFollowing the experimental settings in [6], one week data from 9/1/2014 00:00 (included) 9 on electricity-c\nand 6/15/2008 17:00 (included) 10 on traffic-c is left as test sets. For electricity-f and traffic-f\ndatasets, one week data from 8/31/2014 00:15 (included) and 6/15/2008 17:00 (included) 11 is left as test sets,\nrespectively. For solar, we leave the last 7 days in August as test set. For wind, last 210 days in year 2015 are\nleft as test set. For M4-Hourly, its training and test set are already provided. After training on previous settings,\nwe evaluate our models on aforementioned test intervals and report standard quantile loss (R0.5 and R0.9) on\nthe test sets.\nA.4 Implementation of sparse attention and its memory cost\nDuring the implementation of our sparse attention, ∀l≤|Ik\nL|, one can allow such cell lto densely attend all its\npast cells and itself without increasing space usage as query-key matching are parallelly computed in reality and\nmaximum number of cells that a cell can attend is reached by cell L.\nOur current implementation of LogSparse attention is via a mask matrix and its relative memory usage is\ncalculated ideally from the attention matrix, which is the memory bottleneck of Transformer.\nFor electricity-f dataset, we choose Le1 = 768with subsequence length Le1\nsub = Le1 /8 = 96and local\nattention length Le1\nloc = ⌈log2(Le1\nsub)⌉= 7in each subsequence for our sparse attention model, and Le2 = 293\nin its full attention counterpart. We stack the same layers on both sparse attention and full attention models.\nHence, we can make sure that their whole memory usage is comparable if their memory usage is comparable in\nevery layer. In sparse attention equipped with local attention, every cell attends to 2 ∗Le1\nloc = 14cells in each\nsubsequence at most, causing a cell attend to2∗Le1\nloc∗Le1 /Le1\nsub = 14∗8 = 112cells at most in total. Therefore,\nwe get the memory usage of sparse attention in each layer isLe1 ∗2∗Le1\nloc∗Le1 /Le1\nsub = 768∗112 =L2\ne2 ≈293.\nFollowing such setting, the memory usage of the sparse attention model is comparable to that of the full attention\nmodel. For traffic-f dataset, one can follow the same procedure to check the memory usage.\nA.5 Visualization of attention matrix\nHere we show an example of learned attention patterns in the masked attention matrix of a head within canonical\nTransformer’s last layer on traffic-c dataset. Figure 6 (a) is a time series window containing 8 days in\ntraffic-c . The time series obviously demonstrates both hourly and daily patterns. From its corresponding\nmasked attention matrix, as shown in Figure 6 (b), we can see that for points in weekdays, they heavily attend to\nprevious cells (including itself) at the same time in weekdays while points on weekends tend to only attend to\nprevious cells (including itself) at the same time on weekends. Hence, the model automatically learned both\nhourly and daily seasonality, which is the key to accurate forecasting.\n8https://github.com/nlpdata/mrc_bert_baseline/blob/master/bert/optimization.py\n9Value in 00:00 is the aggregation of original value in 00:15, 00:30, 00:45 and 01:00.\n10Value in 17:00 is the mean of original value in 17:00, 17:10, 17:20, 17:30, 17:40 and 17:50.\n11Value in 17:00 is the mean of original value in 17:00 and 17:10.\n13\nSun Mon Tue Wed Thu Fri Sat Sun\n0.00\n0.05\n0.10\n0.15\n0.20\noccupancy rate\n(a)\nSun Mon Tue Wed Thu Fri Sat Sun\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n(b)\nFigure 6: (a): An example time series window in traffic-c dataset. (b): Corresponding learned\nattention patterns in the masked attention matrix of a head within the last layer.\n14",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.7031839489936829
    },
    {
      "name": "Locality",
      "score": 0.6337819695472717
    },
    {
      "name": "Bottleneck",
      "score": 0.6132369637489319
    },
    {
      "name": "Transformer",
      "score": 0.5641732811927795
    },
    {
      "name": "Granularity",
      "score": 0.5039438605308533
    },
    {
      "name": "Time series",
      "score": 0.446557879447937
    },
    {
      "name": "Quadratic growth",
      "score": 0.415168821811676
    },
    {
      "name": "Algorithm",
      "score": 0.305198609828949
    },
    {
      "name": "Machine learning",
      "score": 0.2188912332057953
    },
    {
      "name": "Engineering",
      "score": 0.11879965662956238
    },
    {
      "name": "Voltage",
      "score": 0.09528225660324097
    },
    {
      "name": "Linguistics",
      "score": 0.0
    },
    {
      "name": "Electrical engineering",
      "score": 0.0
    },
    {
      "name": "Operating system",
      "score": 0.0
    },
    {
      "name": "Philosophy",
      "score": 0.0
    },
    {
      "name": "Embedded system",
      "score": 0.0
    }
  ]
}