{
    "title": "Xevtgen: Fortran code transformer generator for high performance scientific codes",
    "url": "https://openalex.org/W4246066726",
    "year": 2016,
    "authors": [
        {
            "id": "https://openalex.org/A2099032509",
            "name": "Reiji Suda",
            "affiliations": [
                "The University of Tokyo"
            ]
        },
        {
            "id": "https://openalex.org/A1994974525",
            "name": "Hiroyuki Takizawa",
            "affiliations": [
                "Tohoku University"
            ]
        },
        {
            "id": "https://openalex.org/A2098447029",
            "name": "Shoichi Hirasawa",
            "affiliations": [
                "Tohoku University"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W1510687364",
        "https://openalex.org/W2052418796",
        "https://openalex.org/W2154968583",
        "https://openalex.org/W44633979",
        "https://openalex.org/W205033325",
        "https://openalex.org/W2321026224",
        "https://openalex.org/W2476432333",
        "https://openalex.org/W1597642815",
        "https://openalex.org/W1600751494",
        "https://openalex.org/W2165741216",
        "https://openalex.org/W2007457421",
        "https://openalex.org/W1557212109",
        "https://openalex.org/W3004018421",
        "https://openalex.org/W2097586154"
    ],
    "abstract": "High performance scientific codes are written to achieve high performance on a modern HPC (High Performance Computing) platform, and are less readable and less manageable because of complex hand optimization which is often platform-dependent. We are developing a toolset to mitigate that maintainability problem by user-defined easy-to-use code transformation: The science code is written in a simpler form, and coding techniques for high performance are introduced by code transformations. In this paper, we present xevtgen, which is a code transformer generator of our toolset. Transformation rules are defined using dummy Fortran codes with some directives, and we expect our design makes our tool easier to learn for Fortran programmers. Some examples of code transformations, as well as an application to a real scientific application, are shown to discuss the practicality of the proposed approach. Xevtgen assumes XSLT as a backend, and generates an XSLT template from the dummy Fortran code. That design of xevtgen exploits the power of XSLT, and inherits some limitations of XSLT. In our plan, those limitations will be mitigated by additional tools in our toolset.",
    "full_text": "International Journal of Networking and Computing – www.ijnc.org\nISSN 2185-2839 (print) ISSN 2185-2847 (online)\nVolume 6, Number 2, pages 263–289, July 2016\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nReiji Suda\nGraduate School of Information Science and Technology, The University of Tokyo\n7-3-1 Hongo, Bunkyo-ku, Tokyo, 113–8656, JAPAN\nHiroyuki Takizawa\nGraduate School of Information Sciences, Tohoku University\n6-6-01 Aramaki-aza-aoba, Aoba-ku, Sendai, 980–8579, JAPAN\nShoichi Hirasawa\nGraduate School of Information Sciences, Tohoku University\n6-6-01 Aramaki-aza-aoba, Aoba-ku, Sendai, 980–8579, JAPAN\nReceived: February 15, 2016\nRevised: May 6, 2016\nAccepted: July 8, 2016\nCommunicated by Kazuhiko Komatsu\nAbstract\nHigh performance scientiﬁc codes are written to achieve high performance on a modern HPC\n(High Performance Computing) platform, and are less readable and less manageable because\nof complex hand optimization which is often platform-dependent. We are developing a toolset\nto mitigate that maintainability problem by user-deﬁned easy-to-use code transformation: The\nscience code is written in a simpler form, and coding techniques for high performance are intro-\nduced by code transformations. In this paper, we present xevtgen, which is a code transformer\ngenerator of our toolset. Transformation rules are deﬁned using dummy Fortran codes with\nsome directives, and we expect our design makes our tool easier to learn for Fortran program-\nmers. Some examples of code transformations, as well as an application to a real scientiﬁc\napplication, are shown to discuss the practicality of the proposed approach. Xevtgen assumes\nXSLT as a backend, and generates an XSLT template from the dummy Fortran code. That\ndesign of xevtgen exploits the power of XSLT, and inherits some limitations of XSLT. In our\nplan, those limitations will be mitigated by additional tools in our toolset.\nKeywords: Fortran, Code transformation, Code generation\n1 Introduction\nAs clusters and supercomputers are widely available nowadays, high performance scientiﬁc codes\ntend to have tens or hundreds thousands of lines of codes. There may be two major reasons of those\nlarge sizes of codes. One reason is that, as the processors’ clock frequency almost no longer increases,\nwe have to exploit advanced features of latest computer architecture: parallelism, memory hierarchy,\netc. That requires more and more complex coding, deeply dependent on the computer architecture\n263\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nof a speciﬁc execution platform. The other reason is that, because higher performance is provided\nby advanced hardware, scientists choose more complex simulation models for their analysis, which\nwere not possible in the past. Those two reasons will continue to exist, perhaps more intensively, in\nthe future.\nIn this work, we are concerned with the former reason of the complexity of high performance\nscientiﬁc codes. The platform-dependent coding makes the codes less readable and less manageable,\nand harder to port to a new platform. Our project aims to mitigate that coding complexity in high\nperformance scientiﬁc codes, by using code transformations. One of challenges we are tackling in\nour project is to design an appropriate interface of such code transformation rules that is easy for\nscience programmers, who are familiar to only one or very few programming languages. Compiler\nexperts could develop a custom compiler or a code transformer for their own code transformations,\nbut it is not so easy for average programmers to develop such a tool by themselves. In this paper,\nwe present xevtgen, which is a tool that generates code transformations. An advantage of xevtgen\nis that the code transformation rules can be described in conventional Fortran plus some special\ndirectives, without much knowledge on theory and practices about compilers. Therefore, Fortran\nprogrammers can learn and use our tools more easily than developing a custom compiler or a code\ntransformer.\nXevtgen is based on XSLT, which is one of the most well-known and well-available XML trans-\nformation framework. This paper also reports how xevtgen generate an XSLT template from a\ndummy Fortran program. By using XSLT as transformation engine, we can exploit the power of\nXSLT in our toolset. But this design also inherits some limitations of XSLT. We explain our plan\nin which those limitations will be mitigated by additional tools.\nThis paper consists of 10 sections. Section 1, this section, is an introduction. In Section 2,\nan overview of our approach and toolset is explained. From Section 3, the main part of this paper\nbegins. Section 3 is a brief introduction of how to describe code transformations in xevtgen. Section\n4 explains simple and straightforward examples of code transformations. Section 5 explains a little\nmore elaborated examples from our development of autotuning software using xevtgen. Section 6\nexplains an application of xevtgen to a real-world application program for performance portability.\nIn Section 7, the implementation of xevtgen, that is, how Fortran dummy codes are translated into\nXSLT templates, is explained. Section 8 describes some limitations of xevtgen by itself, and reveals\nour plan to solve them. Section 9 compares our work to related work. Section 10 gives concluding\nremarks.\n2 Overview\n2.1 Xevolver approach\nIt is frequently said that “coding what to compute” and “coding how to compute” are not separated\nwell in lower-level programming languages, such as Fortran and C. By using higher-level languages\nsuch as MATLAB, or domain speciﬁc languages (DSL) such as stencil programming DSLs[3], pro-\ngrammer can concentrate on “what to do.” However, regrettably, some languages cannot utilize full\npower of the newest computers, and some languages cannot provide enough programmability for\ngeneral purpose computing. Therefore, many HPC scientiﬁc codes are still written in Fortran, C\nand C++.\nAnother reason to use conventional programming languages is that there are many existing codes,\ndeveloped and maintained for decades. Therefore, in our project, we assume such existing legacy\ncodes, and develop a methodology and a toolset to achieve high performance in such codes without\nintroducing major modiﬁcations of the existing codes.\nOur aim is to separate “how to compute” in such codes, especially on high performance comput-\ners, from “what to compute.” We chose to use code transformation for that purpose[16]. That is,\nthe source code is mostly written to describe “what to compute,” and there are separate code trans-\nformation rules that modify the source code toward high-performance, perhaps platform-dependent\ncodes. The high performance computer architecture in an extreme-scale computing era will be\ndiﬀerent from that in the present, but using our toolset, the original code itself does not need to\n264\nInternational Journal of Networking and Computing\nadapt to the new architecture if separate code transformation rules are properly written for the new\narchitecture.\nThe platform-dependent optimizations should be generally done by compilers developed for those\nplatforms. In reality, it is hard to write an optimized code which outperforms very-well-developed\noptimizing compilers. Still, there are many occasions where compiler optimizations are not applied\nas the code developers expect. Compilers are conservative, that is, they do not apply optimization\nunless they are sure that the behavior of the program does not change. Some other reasons are\nthat, for example, the code is too long to analyze, some analyses such as aliasing cannot be fully\nsolved, or compilers cannot prove safety of some optimizations, which is known to be safe by the\ndevelopers. We observe that, there are always gaps between compiler optimizations and developers’\nexpectations.\nBased on that observation, we are developing Xevolver, a code transformation framework, and\nits utility toolset Xevolver tools. We refer to the whole set of software just as “ Xevolver.”\nXevolver is expected to ﬁll the gap between compiler optimizations and developers’ knowledge\nabout possible optimizations. In this paper, we assume that the developers know the gap, and know\nhow to modify their codes for higher performance. Our aim is to provide code transformation tools\nfor code developers. Although we are also planning to support C and C++, this paper presents only\nthe Fortran version which is under active development.\n2.2 Xevolver Tools\nIn this paper, we introduce xevtgen, which is a part of Xevolver tools. Xevolver tools consist\nof four parts. The ﬁrst part is xevparse/xevunparse, which parses a Fortran source code into an\nXML document using Xevolver. The Fortran source code is translated into an XML tree which\nrepresents an Abstract Syntax Tree (AST) of the source code. The XML format is deﬁned by\nXevolver. The second part is xevtgen, which is the main topic of this paper. The input of xevtgen\nis a Fortran-like code which describes a set of code transformation rules, and its output is a template\nﬁle of XSLT. XSLT is one of the standard speciﬁcations to describe XML data conversion rules.\nThus, by using xevtgen and an XSLT engine, we can transform an XML document representing\nthe original Fortran code so that the transformed XML document accordingly represents another\nFortran code. Xevunparse can back-translate the transformed XML document to its corresponding\nFortran code. The other two parts are xevdriver and xevutils. The xevdriver provides a\nsimple script language to control code transformations using our toolset. The xevutils provide\nsome miscellaneous functions that are useful in transformations, for example, choosing new names,\ncontrolling the order of code transformations, helping debugging of code transformations, modularize\nset of code transformations, and so forth.\n3 Xevtgen\nWe develop xevtgen, because most Fortran programmers are unfamiliar to XSLT and similar XML\ntransformation systems, even to XML. For such Fortran code developers, it is really painful to learn\nXML and XSLT. Our experience is that XSLT is quite hard to debug, unless the developer is very\nwell familiar to most features of the XSLT coding. This is perhaps because XSLT assumes a little\nsimpler XML transformations than that of a practical Fortran AST. Motivated by this, we designed\nxevtgen so that the user does not need to know XML and XSLT at all.\nBefore explaining deﬁnitions of code transformations, we explain command line usage ofxevtgen.\nThe xevtgen command takes two arguments:\nxevtgen infile outfile\nHere the ﬁrst argumentinﬁle is the ﬁle with code transformation deﬁnitions, and the second argument\noutﬁle is the name of the ﬁle to which XSLT translation rules are output. The inﬁle is formatted as\na Fortran program, as is discussed below, and the outﬁle is in XML. (It is more precise to say that\ninﬁle is an XML document which is converted from a Fortran-like code by xevparse. However for\nsimplicity, we call the input ﬁle of xevparse as inﬁle of xevtgen.)\n265\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nTo transform a program src.f90 to dst.f90 by using the XSLT code transformation rules\ngenerated as outﬁle, one should run the commands as follows:\nxevparse src.f90 src.xml\nxsltproc outfile src.xml > dst.xml\nxevunparse dst.xml dst.f90\nXevolver is developed based on ROSE compiler infrastructure[12], and hence supports most features\nof Fortran 77/90/95 and 2003.\n3.1 Inﬁle format\nThe inﬁle describes the code transformation. Its basic format is just a dummy Fortran program —\nhere a “dummy” program may do no meaningful computation, but must be conformant with the\nFortran programming language — plus some directives. The generic directive format is as follows:\ndirective := !$ xev clause [clause . . .]\nclause := name |name(term[,term, . . .])\nterm := name |int |str |‘exp‘\n|name([term[,term, . . .])\nwhere int is an integer, str is a string, and exp is a Fortran expression. Integers and strings are in\nthe Fortran format. A name consists of alphanumerics, underscores, and periods. Each directive\nstarts with !$xev, followed by one or more clauses. Each clause has a name, possibly followed by\narguments, i.e., a list of terms enclosed by parentheses. Each term is one of name, integer, string,\nFortran expression, or name with arguments. A directive with a begin clause corresponds to a\ndirective with an end clause, and they form a single statement. A directive without begin is a single\nstatement by itself.\n3.2 Deﬁning a code transformation in xevtgen\nAn xevtgen inﬁle deﬁnes one or more code transformations. The most basic transformation is literal\nreplacement. For example, if inﬁle contains a directive\n!$xev tgen trans exp src(‘N‘) dst(‘10**3‘)\nthen xevtgen generates an XSLT transformation rule that converts all occurrences of variable N\ninto integer 10**3. Here the ﬁrst two clauses !$xev tgen represent that the directive is of xevtgen\nrule. The next clause trans introduces a transformation rule. The following clause speciﬁes the\ntype (explained below) of the transformation rule. In this example, exp implies that the rule is a\ntransformation from an expression to another expression. The expression in the src clause, which\nis N in this example, deﬁnes what pattern of Fortran code fragment is extracted to be transformed.\nWe call it source pattern. Expression in the dst clause, which is 10**3 in this example, deﬁnes the\nresult of the transformation. We call it destination pattern.\nThere are six types of entities in xevtgen:\n•Name: names of variables, functions, modules, named labels of DO and IF statements, etc. in\nFortran, and name of clauses and terms in directives.\n•Value: integer or string values, either in Fortran program or in directive.\n•Clause: clause of directive.\n•Term: term of directive.\n•Exp: Fortran expression.\n•Stmt: statement of either Fortran program or directive.\n266\nInternational Journal of Networking and Computing\nTransformation rules of terms and expressions are deﬁned as in the above example. Transformation\nrules of clauses and statements are speciﬁed with two directives, for example:\n!$xev tgen trans stmt src begin\nIF (I .EQ. 0) EXIT\n!$xev tgen trans stmt src end\n!$xev tgen trans stmt dst begin\nIF (I == 0) THEN\nEXIT\nEND IF\n!$xev tgen trans stmt dst end\nCurrently, xevtgen does not support transformation of names and values. One may want to\nchange the name of a function from foo to bar. Transformation of names will provide a one-step\nsolution to this requirement. But because of some technical issues caused by the XML structure\nand limitations of XSLT, such a solution is not provided in xevtgen. We are planning to provide a\nseparate tool to change names and values.\n3.3 Tgen-variable\nCode transformations need meta-variables, which enable transformations with some parameters. In\nxevtgen, they are called tgen-variables. Tgen-variables work in two ways: one is a wildcard in\nthe source pattern, and the other is to convey information from a source pattern to its destination\npattern. The following is a simple example of using a tgen-variable.\n!$xev tgen var(a) exp\n!$xev tgen trans exp src(‘sq(a)‘) dst(‘a*a‘)\nIn the ﬁrst line, a is declared as a tgen-variable of type exp. In the source pattern sq(a), it matches\nany call of a function named sq with a single argument, since a behaves as a wildcard. In the\ndestination pattern a*a, the subexpression a of the source pattern sq(a), that is, the argument of\nsq, is copied into each occurrence of a. Thus,\nk = sq(4) + sq(b) + sq(3+c)\nis transformed into\nk = 4*4 + b*b + (3+c)*(3+c)\nHere, a small diﬀerence from macros of C language is that, the parentheses of(3+c)*(3+c) automat-\nically appear, since the replacement is done at an AST level, not at a text level. If the tgen-variable\nappears in the source pattern, then the transformation rules are applied to the tgen-variable. For\nexample, sq(sq(3)) will be transformed into (3*3)*(3*3). But the recursive application can be\nprohibited by adding norec clause in the tgen-variable declaration.\nIn many cases, tgen-variables appear as named variables in the pattern, as in the example above.\nThere are some special forms. The following example contains uses of tgen-variables of type stmt.\n!$xev tgen list(body\nif, body else) stmt\n!$xev tgen src begin\nIF (.false.) THEN\n!$xev tgen stmt(body if)\nELSE\n!$xev tgen stmt(body else)\nENDIF\n!$xev tgen src end\n!$xev tgen dst begin\n!$xev tgen stmt(body else)\n!$xev tgen dst end\n267\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nHere, !$xev tgen stmt(name) behaves as one single tgen-variable of type stmt. One cannot write\njust body if instead of !$xev tgen stmt(body if). This is because we use dummy Fortran code\nto represent transformation. As body if is not a valid Fortran statement, it is not accepted by the\nparser.\nThis example introduces two more things: First, trans stmt can be omitted in !$xev tgen\nsrc and !$xev tgen dst, since they are so frequently used. Second, !$xev tgen list(name list)\ndeclares tgen-variables of list kind, matching lists of non-negative numbers of entities.\nIn the above example, !$xev tgen stmt(body if) catches all statements between IF and ELSE,\nand !$xev tgen stmt(body else) catches all statements between ELSE and ENDIF. The present\ncode transformation conducts, if the condition of IF is a constant .false., then the IF sentences is\nremoved, and only the body of ELSE-part remains.\nNote that the above transformation is not safe in general. The body of THEN-part may contains\na statement with a label, and there may be a GOTO statement with that label. At least at the\ncurrent status, our toolset does not provide a checking mechanism of such an unsafe transformation.\nIt should be emphasized that our purpose is to provide code transformations to avoid modifying the\noriginal code, and thus, as is the case in conventional manual code modiﬁcation, programmers still\nneed to be responsible for the correctness or safety of their code transformations.\nFigure 1 shows a little long example, which splits a loop into two. A source code is assumed to\nhave a loop, for example,\n!$xev loop split\nDO k = 1, N\na(k) = . . .\n!$xev split point\nb(k) = . . .\nEND DO\nand after transformation, it will become\nDO k = 1, N\na(k) = . . .\nEND DO\nDO k = 1, N\nb(k) = . . .\nEND DO\nthat is, there become two loops, keeping loop indices and ranges, and the statements before !$xev\nsplit point are stored in the body of the ﬁrst loop, and the statements after !$xev split point\nare in the body of the second loop. This loop splitting, also known asloop ﬁssion, sometimes improves\nlocality of computations, and is one of the basic loop transformation techniques for HPC. Generally,\na scientiﬁc code needs to be modiﬁed for achieving high performance because the compiler does not\nnecessarily work as expected. Therefore, this kind of basic loop transformation techniques are yet\nneeded for performance tuning of practical scientiﬁc codes.\nThe transformation rule contains three deﬁnitions of transformations. The ﬁrst transformation\n(lines 5 to 19) is an initialization. It ﬁnds a DO loop preceded by !$xev loop split. Then it\ncreates the ﬁrst loop with an empty body, and with the same index variable and range. Here, the\nincrement i2 is included in the pattern, but it matches with DO loops without increment. This\nis a little tricky, but convenient to write slightly general transformation rules. Next see the third\ntransformation (lines 41 to 62), which moves the ﬁrst statement in the second loop to the last\nstatement in the ﬁrst loop. Last, the second transformation (lines 21 to 39) is a ﬁnalization. If the\nﬁrst statement of the second loop is !$xev split point, then the split has been successfully done.\nIt just removes some directives.\nOnly one of them is applied at once. The transformation is assumed to be applied repeatedly,\nuntil no transformation is done any more. The order of three transformation rules is signiﬁcant. If\nthe code matches multiple transformations, then the transformations deﬁned ﬁrst is applied. This\nprioritization on earlier transformations is diﬀerent from XSLT, but is conventional in programming\nlanguages with pattern matching functionalities.\n268\nInternational Journal of Networking and Computing\n3.4 Conditional transformation\nUsers may need to choose transformations depending on some conditions. If the condition appears\nin a matching pattern, then just deﬁning multiple transformations may be enough, placing a more\nspeciﬁc matching pattern before a more general matching pattern.\nAnother possible condition is related to an ancestor node in an AST. For example, one statement\nshould be transformed only if it is within the deﬁnition of a speciﬁc function. In xevtgen, such a\ncondition can be speciﬁed by a context. Such a context can be deﬁned as\n!$xev tgen ctxdef(infoo) stmt begin\nFUNCTION foo(args)\n!$xev tgen stmt(body)\nEND FUNCTION\n!$xev tgen ctxdef end\nand is named as infoo. The deﬁned context is referred in the matching pattern as\n!$xev tgen src context(infoo) begin\n. . .\n!$xev tgen src end\nThen the transformation is only applied within the deﬁnition of the function foo.\nAnything which can be speciﬁed as a source pattern can be a context. The pattern should\ncontain one or more tgen-variable(s). When the transformation rules are applied to a code fragment\nwhich corresponds to such a tgen-variable, the context is regarded as valid, and the rules with the\ncontext are applied. Otherwise, the context is regarded as invalid, and the rules with the context\nare ignored. In the above example, !$xev tgen stmt(body) is the tgen-variable in the context\ndeﬁnition, and it corresponds to the body of the function deﬁnition. Thus the transformation rule\nwith context(infoo) is applied only to the code fragments within the deﬁnition of function foo.\nBy using contexts, one can deﬁne, for example, rules which are valid only within some speciﬁed DO\nloop, within an argument of some function call, or within some speciﬁed directive structure.\nSome additional functionalities related to contexts are provided by xevtgen. One is logical\noperations of contexts, such as context(and(ctx0, or(ctx1, not(ctx2)))), where ctx0, ctx1\nand ctx2 are context names. Another feature is a context for another context: If a context (say,\nctx1) deﬁnition is conditioned by another context (say, ctx0), then the context ctx1 will be active\nonly when it is in context ctx0. A context (say, ctx2) can cancel another context (say,ctx1). Those\nfeatures are designed to resemble scoping rules in many programming languages.\nThe third method of limiting matching patterns is conditions, which is designed to catch more\ndetailed conditions in the matching pattern. A condition is deﬁned by condef, for example, as\nfollows:\n!$xev tgen var(x) exp\n!$xev tgen condef(upd) stmt contains begin\ni = x\n!$xev tgen condef end\nThe condition upd becomes active if the variable i is updated by an assignment (note that x is a\ntgen-variable, so can be any expression). Then it can be used, for example, as follows:\n!$xev tgen var(i0, i1, i2) exp\n!$xev tgen list(body) stmt condition(upd)\n!$xev tgen src begin\nDO i = i0, i1, i2\n$xev tgen stmt(body)\nEND DO\n!$xev tgen src end\n269\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nHere, the condition is referred to as condition(upd) in the declaration of tgen-variable body. Then,\nif a source pattern contains a reference to the tgen-variable body, then it ﬁres only when the code\nfragment that corresponds to body satisﬁes the condition: in this case, contains an assignment\nstatement to the variable i. So the above pattern matches if the loop index i is updated within the\nloop body, and perhaps one can warn the programmer. The assignment to i can be found within\na deeper program structure, for example, within an inner DO loop or an IF construct within the\nouter DO loop indexed with i.\nThere are four kinds of conditions inxevtgen: is, same, contains, and listwith. The condition\nis means that the tgen-variable directly matches the pattern given by the condition. It is useful\nwhen the condition deﬁnition contains tgen-variables, and when the condition is used in logical\noperations and, or, and not. The condition same means that the tgen-variable has the same name\nor value as the condition speciﬁes, which can be used only for names and values. Condition same\nfor other types, such as expression and statements, are not supplied in xevtgen. Such a condition\ncorresponds to a uniﬁcation, and XSLT does not provide uniﬁcation, so xevtgen does not. Section\n5.1 introduces a technique which is similar to uniﬁcation. The condition contains means that the\ntgen-variable contains the speciﬁed pattern. The condition listwith is activated only when the\nspeciﬁed pattern is an element of the list that the tgen-variable represents.\nAs described above, xevtgen allows users to deﬁne transformation rules without any knowledge\nabout compilers, XML, nor XSLT. Basically, users just need to write two versions of a code, the\nsource pattern and the destination pattern. Moreover, combining matching patterns with contexts\nand conditions, xevtgen can provide many matching conditions which is available in XSLT. But the\npossible set of transformations of xevtgen is less than that of XSLT. For example, one can write\nXSLT template with character string manipulations, which is not made available in xevtgen. In a\nsense, that restriction reduces the risk of deﬁning syntactically illegal rules.\nOverall, xevtgen has been designed and developed so that it can be used to deﬁne code trans-\nformations frequently required in performance tuning of scientiﬁc codes. The following sections will\nshow several use cases to demonstrate that xevtgen can deﬁne various code transformations useful\nin practical programming.\n4 Simple examples\nThis section shows two use cases to exemplify the expression ability and limitations of xevtgen\n(rather than performance tuning with xevtgen).\n4.1 Choose\nThe ﬁrst example is an implementation of choose, which is something like the conditional operators\np?x:y in the C language. One can use choose(p, x, y) in expressions, which is expanded to IF\nsentences. Note that choose(p, x, y) cannot be implemented as a function, because y should be\nevaluated only if p is true, and y should be evaluated only if p is false.\nIn this paper, we focus on a very simple implementation, to keep the explanation brief. First,\nwe assume there is only one occurrence of choose in a program. If there are many choose instances,\nthey must be translated one by one, and such a control will be achieved by using xevutils and\nxevdriver of our toolset. Second, we assume a choose expression in an assignment, which is simplest\nto treat. If choose appears in the condition of an IF statement, it would be better to evaluate the\ncondition before the IF statement.\nIt is possible to deﬁne choose in one ﬁle, but for simplicity, we explain it in three transformations.\nThe ﬁrst transformation is to ﬁnd choose and make an IF statement.\n!$xev tgen var(p, x, y, u) exp\n!$xev tgen condef(has\nchoose) contains exp(‘choose(p,x,y)‘)\n!$xev tgen var(chexp) exp cond(has choose)\n!$xev tgen src begin\nu = chexp\n270\nInternational Journal of Networking and Computing\n!$xev tgen src end\n!$xev tgen dst begin\nIF (p) THEN\n!$xev choose then\nu = chexp\nELSE\n!$xev choose else\nu = chexp\nEND IF\n!$xev tgen dst end\nAn assignment of some expression chexp that contains choose is transformed to an IF statement\nwith condition p, the ﬁrst argument of choose. The assignment statement is copied to both THEN\npart and ELSE part, preceded by directives with choose then and choose else, respectively.\nThe second transformation is as follows. If an expression choose(p, x, y) is in a statement\nfollowed by choose then, then it is transformed into just x. If it is followed by choose else, then\nit is transformed into y.\n!$xev tgen var(s) stmt\n!$xev tgen var(p, x, y) exp\n!$xev tgen ctxdef(ch1) stmt begin\n!$xev choose then\n!$xev tgen stmt(s)\n!$xev tgen ctxdef end\n!$xev tgen trans exp src(‘choose(p,x,y)‘) dst(‘x‘) context(ch1)\n!$xev tgen ctxdef(ch2) stmt begin\n!$xev choose else\n!$xev tgen stmt(s)\n!$xev tgen ctxdef end\n!$xev tgen trans exp src(‘choose(p,x,y)‘) dst(‘y‘) context(ch2)\nThe third transformation is just to remove choose then and choose else, which is not shown\nhere, because it is trivial. Let us apply these transformations to the following Fortran code:\nfunction test(a, b)\ninteger :: a, b, test\ntest = choose(a < b, -1, 1)\nend function\nAfter the ﬁrst transformation, it will become:\nfunction test(a, b)\ninteger :: a, b, test\nIF (a < b) THEN\n!$xev choose then\ntest = choose(a < b, -1, 1)\nELSE\n!$xev choose else\ntest = choose(a < b, -1, 1)\nEND IF\nend function\nThen it is converted by the second transformation:\nfunction test(a, b)\ninteger :: a, b, test\n271\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nIF (a < b) THEN\n!$xev choose then\ntest = -1\nELSE\n!$xev choose else\ntest = 1\nEND IF\nend function\nFinally it becomes as follows:\nfunction test(a, b)\ninteger :: a, b, test\nIF (a < b) THEN\ntest = -1\nELSE\ntest = 1\nEND IF\nend function\n4.2 Unswitching\nUnswitching is a widely-used coding technique, that moves IF switches with loop-invariant conditions\nout of DO loops. Let us ﬁrst see an example of target code:\nsubroutine test(n, a, ch)\ninteger :: n, ch\nreal :: a(n)\n!$xev loop unswitch\ndo i = 1, n\nif (ch .eq. 0) then\na(i) = 1.0 / i\nelse if (ch .eq. 1) then\na(i) = i\nelse if (ch .eq. 2) then\na(i) = 0.0\nelse\na(i) = 1.0\nend if\nend do\nend subroutine test\nUnswitching translates the code above into the following code:\nsubroutine test(n, a, ch)\ninteger :: n, ch\nreal :: a(n)\nif (ch .eq. 0) then\ndo i = 1, n\na(i) = 1.0 / i\nend do\nelse if (ch .eq. 1) then\ndo i = 1, n\na(i) = i\nend do\nelse if (ch .eq. 2) then\ndo i = 1, n\na(i) = 0.0\nend do\n272\nInternational Journal of Networking and Computing\nelse\ndo i = 1, n\na(i) = 1.0\nend do\nend if\nend subroutine test\nThe former code is more readable, but the latter code performs better on many platforms. Some\ncompilers can do unswitching automatically, but sometimes cannot, because it is hard for compilers\nto check whether the conditions are loop-invariant or not.\nThe following code is a deﬁnition of unswitching transformation.\n!$xev tgen var(i, i0, i1, p, q) exp\n!$xev tgen list(body1, body2, body3) stmt\n!$xev tgen src begin\n!$xev loop unswitch\ndo i = i0, i1\nif (p) then\nbody1 = xevtgen\nvar\nelse if (q) then\nbody2 = xevtgen var\nelse\nbody3 = xevtgen var\nend if\nend do\n!$xev tgen src end\n!$xev tgen dst begin\nif (p) then\ndo i = i0, i1\nbody1 = xevtgen\nvar\nend do\nelse\n!$xev loop unswitch\ndo i = i0, i1\nif (q) then\nbody2 = xevtgen var\nelse\nbody3 = xevtgen var\nend if\nend do\nend if\n!$xev tgen dst end\n!$xev tgen src begin\n!$xev loop unswitch\ndo i = i0, i1\nif (p) then\nbody1 = xevtgen var\nelse\nbody2 = xevtgen var\nend if\nend do\n!$xev tgen src end\n!$xev tgen dst begin\nif (p) then\ndo i = i0, i1\nbody1 = xevtgen\nvar\nend do\n273\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nelse\ndo i = i0, i1\nbody2 = xevtgen var\nend do\nend if\n!$xev tgen dst end\nIt consists of two rules, one for three or more conditional branches, the other for two (IF-THEN-\nELSE). Our parser converts a series of ELSE IF switches into a nested IF-THEN-ELSE syntax, so the\nabove two cases are enough for any number of IF switches. Some statement like body1=xevtgen var\nis equivalent to !$xev tgen stmt(body1), which are sometimes slightly more readable.\nThe above transformation produces a code which is little uglier than expected as:\nif (ch .eq. 0) then\n...\nelse\nif (ch .eq. 1) then\n...\nelse\nif (ch .eq. 2) then\n...\nelse\n...\nend if\nend if\nend if\nbut it is possible to deﬁne a code transformation to convert the code above into a simpler one.\n5 Some use cases in code generation\nXevolver and xevtgen are not restricted to transformations that preserve the semantics of the\ncodes. In this section we introduce a use case of xevtgen for a kind of meta-programming. We are\ndeveloping a code generator for mathematical routines of autotuning based on Bayesian statistical\nmodeling[15]. Our generator takes an input ﬁle that describes a Bayesian model in a format of\nFortran code. Then it outputs an executable Fortran code that computes a ﬁtting of observed data\ninto the given Bayesian model. We do not explain the details, but introduce some transformations\nthat are used in our code generation.\n5.1 Triplet transformation\nBefore explaining the code transformations, we introduce an extension of transformations inxevtgen,\nwhich we call triplet transformation.\nThe need of triplet transformation comes from the lack of uniﬁcation in XSLT. Without uniﬁ-\ncation, the matching rule (the source pattern) cannot depend on the source code. For example, we\nhave no way to ﬁnd the speciﬁcation of a variable found in the source code, or to ﬁnd the occur-\nrences of an expression found in the source code. Triplet transformation is a method to mitigate\nthat restriction.\nA simple example is a macro. Here we have the following source code:\n!$xev macro(N, 100)\nx += N * N\nand want to transform it to the code below.\nx += 100 * 100\n274\nInternational Journal of Networking and Computing\nTo do that, we just need an xevtgen inﬁle as\n!$xev tgen trans exp src(‘N‘) dst(‘100‘)\nTo attain the usual semantics of macro directive, expressions N and 100 should be speciﬁed within\nthe macro directive, which is in the source code. But in xevtgen the replacement patters must be\nspeciﬁed in the inﬁle of the xevtgen, rather than the code to be transformed.\nTriplet transformation is a simple trick to enable it. It consists of three transformations. First,\nwe prepare a dummy inﬁle:\n!$xev tgen trans exp src(‘aaa‘) dst(‘bbb‘)\nwhere aaa and bbb are dummy expressions. Next, we deﬁne another transformation, which we call\nspecializing rule, as follows.\n!$xev tgen var(xxx, yyy) exp\n!$xev tgen src begin\n!$xev macro(‘xxx‘, ‘yyy‘)\n!$xev tgen src end\n!$xev tgen dst begin\n!$xev tgen trans exp src(‘aaa‘) dst(‘xxx‘)\n!$xev tgen trans exp src(‘bbb‘) dst(‘yyy‘)\n!$xev tgen dst end\nThose two transformation rules are suﬃcient to a triplet transformation. At the ﬁrst transformation,\nthe specializing rule is applied to the source code that have one or more !$xev macro lines. The\nsource code will be transformed into the following:\n...\n!$xev tgen trans exp src(‘aaa‘) dst(‘N‘)\n!$xev tgen trans exp src(‘bbb‘) dst(‘100‘)\n...\nThe above transformed code is used at the second transformation, and is applied to the dummy\ninﬁle. It results in the following code, which we call specialized inﬁle:\n!$xev tgen trans exp src(‘N‘) dst(‘100‘)\nwhich is exactly what we wanted to have. At the third transformation, the specialized inﬁle is\napplied to the source code, and the macro transformation is done. (In this example, the source code\ncan have only one macro deﬁnition. To treat multiple macro deﬁnitions, we need an external helper\nthat sequentialize multiple transformations.)\nA triplet transformation is illustrated in Figure 2. Here, the thick boxes represent the ﬁles exist\nbefore the transformations and the thin boxes represent the ﬁles created by the transformations. The\nthick arrows represent sources and destinations of the transformations, and the thin arrows show\ntransformation rules. It looks much more complex than a simple transformation, but the only added\nﬁle is the specializing rule, which inserts some information of the source code into the transformation\nrule.\n5.2 Finding array size\nNext, a few transformations used in our code generator are explained. The ﬁrst transformation ﬁnds\nthe array size speciﬁcation, which is given as follows.\n1 real :: xxx(100)\n2\n3 !$xev tgen list(aaa) exp\n4 !$xev tgen condef(has\nxxx) contains exp(‘xxx(aaa)‘)\n275\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\n5 !$xev tgen list(vars) cond(has xxx) exp\n6\n7 !$xev tgen var(t) exp\n8 type :: t\n9 integer :: dummy\n10 end type t\n11\n12 !$xev tgen list(rem) stmt\n13 !$xev tgen ctxdef(sizedefined) stmt begin\n14 type(t) :: vars\n15 !$xev tgen stmt(rem)\n16 !$xev end tgen contextdef\n17\n19 !$xev tgen src context(sizedefined) begin\n20 !$xev catch\nsize(‘xxx‘)\n21 !$xev end tgen src\n22 !$xev tgen dst begin\n23 !$xev size\ninfo(‘xxx‘, ‘aaa‘)\n24 !$xev end tgen dst\n25\n26 !$xev tgen src begin\n27 !$xev catch\nsize(‘xxx‘)\n28 !$xev end tgen src\n29 !$xev tgen dst begin\n30 !$xev size\ninfo(‘xxx‘, ‘1‘)\n31 !$xev end tgen dst\nThe above code is a dummy inﬁle, and xxx should be replaced with a real variable name via a triplet\ntransformation.\nLine 1 speciﬁes that xxx is an array. Lines 3 to 5 give a standard usage of a condition: The\ncondition in line 4 has a variable part aaa, which is declared in line 3. The condition must be used\nin a tgen-variable, which is deﬁned in line 5. In the following rules, vars represents any list of\nexpressions that contains xxx(...).\nLines 7 to 10 deﬁne a user-deﬁned type t, which is actually a dummy type, because the type\nname t is a tgen-variable. That is used in line 14.\nLines 12 to 16 deﬁne a context named sizedefined. Line 14 means that, the context is activated\nif there is a variable speciﬁcation with any type (type(t)) that contains xxx(...) in vars. The\ncontext is valid in the following statements, as designated by !$xev tgen stmt(rem).\nLines 19 to 24 deﬁne the transformation from catch size to size info. There the tgen-variable\naaa is replaced with the array size speciﬁer, as it is speciﬁed in line 4 as xxx(aaa). For exam-\nple, if there is a speciﬁcation with integer :: xxx(10, 20), then the transformation generates\nsize info(‘xxx‘, ‘10, 20‘).\nIf there is no such a speciﬁcation, then xxx seems to be a scalar variable, and the transformation\ndeﬁned in lines 26 to 31 will be activated. It inserts 1 in size info directive.\n5.3 Declaring a new temporary array\nIn the next example, we insert a declaration of a new temporary array yyy, which has the same\ndimension as obtained in size info. In our real usage, we rearrange multiple dimensions into one\ndimension (for example, yyy(10*20) is generated from xxx(10,20)), but we omit that part for\nsimplicity. The simpliﬁed transformation rule is as follows.\n1 !$xev tgen list(aaa) exp\n2 !$xev tgen condef(has size) contains stmt begin\n3 !$xev size info(‘xxx‘, ‘aaa‘)\n4 !$xev end tgen condef\n5 !$xev tgen list(body\nwith size) stmt cond(has size)\n276\nInternational Journal of Networking and Computing\nTable 1: System speciﬁcations.\nSpeciﬁcations\nNEC NEC Intel NVIDIA NVIDIA\nSX-9 SX-ACE Xeon E5-2630v2 Telsa K20 Tesla C2070\nType Vector Vector x86 GPU GPU\nYear 2007 2013 2013 2012 2009\nPeak Perf. 102.4 Gﬂop/s 256 Gﬂop/s 124.8 Gﬂop/s 1170 Gﬂop/s 515 Gﬂop/s\nMemory Size 1000 GBytes 64 GBytes 128 GBytes 5 GBytes 6 GBytes\nMemory BW 256 Gbytes/s 256 GBytes/s 51.2 GBytes/s 208 GBytes/s 150 GBytes/s\nNo. Cores 1 4 6 2496 448\nCore Clock 3.2 GHz 1 GHz 2.6 GHz 0.71 GHz 1.15 GHz\nLast-level Cache 256 KBytes 1 MBytes 15 MBytes 1.5 MBytes 768 KBytes\n6\n7 !$xev tgen src begin\n8 !$xev end\nof spec\n9 !$xev tgen stmt(body with size)\n10 !$xev end tgen src\n11 !$xev tgen dst begin\n12 real :: yyy(aaa)\n13 !$xev end\nof spec\n14 !$xev tgen stmt(body with size)\n15 !$xev end tgen dst\nAgain, this is a dummy inﬁle, and xxx and yyy should be replaced with names of real variables via\na triplet transformation.\nLines 1 to 5 deﬁne a tgen-variable body with size that represents a list of statements containing\n!$xev size info(‘xxx‘, ‘...‘).\nLines 7 to 15 give a transformation to insert an array declaration. Here it is assumed that a\nline !$xev end of spec is inserted at the end of the speciﬁcation part. It is technically possible\nfor xevtgen to search for the end of the speciﬁcation part, but it needs very lengthy coding. So we\nassume a mark that shows the end of the speciﬁcation part, for simplicity and eﬃciency. Under that\nassumption, the transformation is easy. Note that the tgen-variable aaa conveys the size information\nfrom the size info directive to the destination pattern of the transformation rule.\nHere, it is assumed that size info directive is placed after end of spec. Thus this is an example\nthat information is brought from a place after the transformed directive, while the previous example\nbrings information from a place before the transformed directive. One can write more complex\ntransformation rules that collect information before and after the transformation point.\nBy using those methods, we can insert execution statements. By using 29 transformation rules,\nwe could generate a model ﬁtting code from a Bayesian model. That result will be reported in our\nfuture work.\n6 Optimization of a real-world application with xevtgen\nThis section shows a case study of using xevtgen for optimizing a real-world application, called\nNumerical Turbine [8], which has been originally developed and optimized for the NEC SX-9 vector\ncomputing system installed at Tohoku University Cyberscience Center [14]. In this case study,\nxevtgen is used to migrate Numerical Turbine to other platforms so that the kernel codes are\nexecuted on the processors listed in Table 1. NEC SX compiler is used for the SX-9 and SX-ACE\nsystems. PGI Accelerator compiler 16.4 is used for the others, and OpenACC directives [11] are\nused to compile the code for GPUs.\nAs observed in many other scientiﬁc applications, Numerical Turbine has a lot of (at least 44)\nsimilar loop nests that have almost the same loop structure shown in Figure 3(a). To achieve\nhigh performance, those loop structures must be changed so as to make better use of the system\nperformance considering the architectural characteristics. In the original code, the length of each\n277\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\ninnermost loop is basically increased so that the SX-9 vector computing system can exploit the\nloop parallelism. On the other hand, it is not always best for GPUs to use the parallelism of the\ninnermost loop. Hence, so-called loop interchange is frequently used to optimize Numerical Turbine\nfor GPUs.\nOne problem is that it is diﬃcult for the compiler to judge if each loop nest in the original\ncode is interchangeable and parallelizable. Our preliminary evaluation indicates that those loop\nstructures have to be altered as shown in Figure 3(b) in order to allow the OpenACC compiler\nto parallelize the loop nests. Note that it is necessary to insert several statements to prevent the\nloop interchange from changing the program behaviors. Obviously, it is diﬃcult for compilers to\nautomate this transformation by properly inserting the statements. Accordingly, for GPUs, all of\nthe loop nests in the code need to be modiﬁed to make their loop structures more friendly to the\nOpenACC compiler.\nIt is eﬀortful even for expert programmers to manually change all the 44 loop nests. In our\nprevious work [16], one transformation rule is written in XSLT and used for transforming the loop\nnests in the same way as in Figure 3. The case study in [16] has demonstrated that Xevolver is\nuseful to perform such repetitive code modiﬁcations by using a mechanical code transformation,\nwhich is deﬁned by XSLT rules of only 36 code lines in the case study.\nIn [16], however, the users are supposed to have expert knowledge about both of performance\ntuning and XML technologies, even though HPC programmers are rarely familiar with both of them.\nOn the other hand, in the case of xevtgen, the same rule can be represented as a dummy Fortran\ncode of 28 code lines shown in Figure 4. This rule is general enough to transform all of the 44 loop\nnests whose structures are almost the same as that in Figure 3(a). For the generality, the code in\nlines 2 to 11 deﬁnes a list of statements, which organize a code pattern written in lines 6 to 9. The\noriginal and transformed code patterns actually deﬁning the transformation rule are written in lines\n12 to 27. This means that the rule could be simpler if the rule is used only for transforming a more\nspeciﬁc code pattern.\nAccording to our observation, such a simple transformation rule is often required for optimizing\na speciﬁc code in practice. Such a rule could be simple but speciﬁc to a particular code, i.e., not\nusable for other codes, and thus requires a custom code transformation rule. In such a situation,\nxevtgen will be helpful to deﬁne and use a custom code transformation for optimizing the particular\ncode without major code modiﬁcations.\nIn terms of the number of code lines, the dummy Fortran code is about 22% shorter than the\nXSLT rules. A more important point is that the users can write the dummy Fortran code if they\nknow the Fortran syntax and the basic usage ofxevtgen described in this paper. On the other hand,\nto describe the XSLT rules in [16], the users need to learn XML, XSLT, and ASTs generated by the\nROSE compiler. Accordingly, it is obvious that the users can describe custom code transformation\nrules much more easily by using xevtgen than writing XSLT by hand.\nFigure 5 shows the performance impact of the code transformation in Figure 4. The vertical axis\nindicates the speedup ratio of the transformed code to the original one. Thus, if the speedup ratio\nis less than one, the performance of the system is degraded by the code transformation.\nNote that diﬀerent architectures might prefer diﬀerent loop structures and hence require diﬀerent\nloop optimizations. In this case study, the original code is optimized for the SX-9 vector computing\nsystem, while the code transformation is deﬁned for GPU-aware loop optimizations. As a result,\nthe code transformation signiﬁcantly improves the GPU performances, i.e., K20 and C2070, and\ndegrades the performances of the others. These results clearly indicate that, if a code is simply\noptimized for a particular system, the optimization often leads to performance degradation of others.\nIn the case of using code transformations, however, this performance degradation is not a problem\nbecause each system can use its own code transformation. In this particular case, the original code\nwithout any code transformation is used for the SX systems, and the transformed code is used for\nthe GPU systems. In this way, the Xevolver approach can decouple “how to compute” from “what\nto compute” written in standard Fortran, and xevtgen allows users to beneﬁt from the approach\nmuch more easily.\n278\nInternational Journal of Networking and Computing\n7 Implementation Overview\nIn this section, the implementation of xevtgen is brieﬂy explained.\nAs explained in Section 2, the xevtgen inﬁles (written in Fortran) are ﬁrst transformed into\nXML documents by xevparse. Xevparse parses a Fortran code based on Xevolver, also parses\n!$xev directives, and outputs an XML document. Fortran source codes should be also converted to\nXML documents by xevparse.\nAfter reading an inﬁle formatted in XML, xevtgen works in two paths. In the ﬁrst path, the\nnumbers of tgen-variable declarations, contexts, and transformation rules are counted. In the second\npath, xevtgen outputs the outﬁle, as an XSLT template ﬁle, while traversing the XML tree once\nagain.\nThe XSLT template ﬁle has just one big transformation rule, schematically shown as follows.\n<xsl:template match=\"*\">\ndeclare XSLT parameters\n<xsl:choose>\n<xsl:when test=\"match source pattern\">\ngenerate destination pattern\n</xsl:when>\npossibly morewhen nodes\n<xsl:otherwise>\nmake a copy\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\nThe phrases in italics will be explained below. The last one, make a copy is a well-known XLST\nidiom that makes a copy of the current node, and recursively applies the rules to the children (see\nFigure 7).\nWe chose to use one big transformation rule with when branches, because we use a diﬀerent\nmethod to prioritize matchings than XSLT: an earlier rule has higher priority than a later one, while\nin XSLT, priority is deﬁned by numbers. It could be implemented with numbered priority, but the\ncurrent implementation is more straightforward.\n7.1 Declaring XSLT parameters\nXevtgen uses three types of XSLT parameters. First, one parameter is used for each tgen-variable.\nOnce a node or a set of nodes is caught by a tgen-variable, it is transferred to the subsequent\ntransformations.\nSecond, one string parameter is used to maintain the information about whether each node is in\na context or not. Each character in this parameter corresponds to one context deﬁned in the inﬁle,\nand it is ‘t’ if the node is within the context, and ‘f’ otherwise. The string is modiﬁed when a new\ncontext is found.\nThird, one parameter is used for sibling transformation, which is not found in XSLT. Sibling\ntransformation will be explained later in Section 7.5.\nThese parameters and <xsl:choose> are written in the outﬁle when the second path of xevtgen\nbegins. When xevtgen ﬁnds a tgen-variable declaration or a condition deﬁnition, it registers those\ninformation to its internal data structure. When xevtgen ﬁnds a rule of src-dst pair or a context\ndeﬁnition, it outputs a corresponding new xsl:when node. When xevtgen ﬁnds other kinds of XML\nnodes, it does nothing and keeps traversing the children and the siblings. At the end of the second\nphase, xevtgen outputs the xsl:otherwise node and closes the template.\n7.2 Matching source pattern\nOne transformation rule of xevtgen creates a xsl:when node of the XSLT template. An XPath[6]\nexpression for the xsl:test attribute corresponds to the source pattern of the xevtgen rule.\n279\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nFirst suppose that the source pattern has no tgen-variable. Then the current node matches the\nsource pattern when the subtree rooted by the current node is exactly the same as the subtree in the\nsource pattern. In the current implementation, we ignore texts (which is used to indent the XML\ndocument) and comments. Xevtgen generates an XPath expression that requires:\n•The current node has the same name as the source pattern,\n•Each attribute of the source pattern has a matching attribute in the current node,\n•The current node and the source pattern have the same number of attributes,\n•Every child of the current node exactly matches the corresponding child of the source pattern,\nand\n•The current node and the source pattern have the same number of child nodes.\nWe need to check the number of attributes (and children), not to allow a matching with a node\nwhich has more attributes (and children, respectively) than the source pattern. But if a child node\nis a list kind of tgen-variable, then the comparison of the numbers of children is not written to allow\ndiﬀerent numbers of children.\nWhen xevtgen ﬁnds a tgen-variable in the source pattern, the corresponding XPath rule is not\nwritten. The path from the root of the source pattern to the tgen-variable is registered to an inner\ndata structure. If the tgen-variable has conditions, an XPath rule corresponds to the conditions is\nwritten.\n7.3 Generating destination pattern\nWhen xevtgen reaches the destination pattern of a rule, it outputs XSLT codes to generate the\ndestination pattern (which can be empty).\nIf the current node is not a tgen-variable, then a copy node with the same set of attributes is\ngenerated. Here, the children are also generated recursively.\nIf the current node is a tgen-variable, then the corresponding subtree is generated. If the tgen-\nvariable is deﬁned within the corresponding source pattern, then an XPath referring to the corre-\nsponding node is written. If the tgen-variable has norec speciﬁcation, then a copy of the subtree is\nmade, and otherwise, the rules are applied to the subtree with xsl:apply-templates.\nIf the tgen-variable is not deﬁned within the corresponding source pattern, then it must be\ndeﬁned in a preceding transformation and be transferred via an XSLT parameter. So the reference\nto the corresponding XSLT parameter is generated. The transformation rules are not applied to\ntgen-variables transferred from preceding transformations.\n7.4 Context\nContext is nothing but a code transformation rule with source and destination patterns exactly\nthe same. Not only context deﬁnition, but also a src-dst pair of transformation rule can be at-\ntributed as a context. The XSLT parameter corresponding to the context is modiﬁed when an\nxsl:apply-templates is invoked within the context.\n7.5 Sibling transformation\nIn XSLT, a node or a subtree is converted to another. No mechanism is provided to transform a list\nof sibling nodes to another list of sibling nodes. For example, XSLT can convert A to B C, but does\nnot provide a way to directly deﬁne a conversion from A Bto C, i.e., a pair of two sibling nodes A\nand B is converted to a diﬀerent node C. We found this limitation is very inconvenient for xevtgen.\nWe call a transformation rule from a list of sibling nodes into another, sibling transformation, and\nimplemented it in xevtgen. Examples of sibling transformation are found in this paper: the context\nch1 and ch2 in Section 4.1, and “unswitch” transformation in Section 4.2, and the rule in Section\n280\nInternational Journal of Networking and Computing\n5.3. The number of siblings is not limited to two, but for simplicity, the following descriptions\nassume two siblings.\nThe basic idea of sibling transformation is simple. To transform A Binto C, a pair of transfor-\nmations are deﬁned: one to transform A followed by B to C, and another to remove B preceded by\nA.\nThere is a subtle problem in this implementation. Consider a rule to transform A Bto A′ B.\n!$xev tgen var(B) stmt\n!$xev tgen src begin\nA\n!$xev tgen stmt(B)\n!$xev end tgen src\n!$xev tgen dst begin\nA’\n!$xev tgen stmt(B)\n!$xev end tgen dst\nHere B part is caught by a tgen-variable B, and copied in the destination pattern. Note that\nxevtgen applies the transformation rules to the tgen-variables by default. When the rules are applied\nto the tgen-variable B, it is removed by the rule, since it is B preceded by A. Then the result is A′\ninstead of A′ B.\nTo solve this problem, an XSLT parameter is used to identify the applied rule. Then the rule for\nB preceded by A is deﬁned to remove it only if it is not the destination pattern of the applied rule.\nAnd the rule for A is conversion into A′ B, where B is not removed because it is in the destination\npattern of the rule.\n7.6 An example of generated XSLT template\nIn this section, we show output examples for the ﬁrst transformation in Section 3.3 ( sqrt example).\nFirst, the Fortran dummy code is converted to an XML document byxevparse as shown in Figure 6.\nHere, only the part of the pragma is shown, but actually it is surrounded by default Fortran preambles\nand postambles. This XML document should be input to xevtgen, and the output is as shown in\nFigure 7.\n8 Limitations and prospective solutions\nXevtgen is not a complete tool, but a code transformer generator, and we are developing related\ntools in our toolset Xevolver tools. In this section, we describe some limitations of xevtgen and\nhow they will be solved in the toolset we are developing.\nBecause xevtgen outputs code transformation rules in XSLT, it inherits all the limitations of\nXSLT. The most notable limitation in our preliminary experiences was the lack of uniﬁcation. Match-\ning between a subtree in a code and a subtree in the inﬁle of xevtgen is possible, but one cannot\ncompare two subtrees in the same source code. It becomes possible by creating a new inﬁle referring\nto the source code. That generation of inﬁle can be done by our toolset, since the inﬁle format\nfollows standard Fortran plus directives, which is exactly the format our toolset can do transfor-\nmations. Triplet transformation reported in Section 5.1 is an example, and in our plan, it can be\nspeciﬁed in a simpler manner with xevdriver and xevutils.\nAnother limitation is that, the code is transformed only from source to destination, and thus\nrecursive application of code transformations, which plays an essential role in many code transforma-\ntion systems, cannot be done solely by xevtgen. Xevdriver will control such recursive application\nof transformations.\nIn many code transformations, one has to introduce new variables. The new variable name\nmust be diﬀerent from any existing variable names. Also, sometimes one has to rename labels, as\nlabels in a scope must be unique. Introduction of new names and new labels is, if not impossible,\ndiﬃcult or at least ineﬃcient only with xevtgen. Xevutils will provide such functions. Another\n281\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nlimitation caused by the XSLT is the lacks of transformations of names and values. We will provide\na separate tool for those transformations. Also, the xevutils will provide information exchange\namong multiple ﬁles, for example, to enable interprocedural transformations.\nThe code transformation generated by xevtgen is based on the syntactic information. Extracting\nsemantic information from codes by using xevtgen is technically possible, but will be complex and\nineﬃcient. In our plan, xevutils include some tools that embed semantic information in the code.\nBy referring such embedded semantic information, code transformations depending on semantics\nwill become available.\nThe transformations deﬁned with xevtgen may not keep the semantics of the code. Preserving\nthe semantics is not only hard to attain in general, but also unwanted in some cases: it is too\nrestrictive. It is possible to write code transformation rules with xevtgen that breaks Fortran\nsyntax, though its possibility is much more limited than direct XML transformations.\n9 Related work\nThere are too many research works in source-to-source code transformations to list them up. By\nlimiting the scope into Fortran, and limiting those tools that provide general source-to-source trans-\nformations (that is, not limited to a predeﬁned set of transformations), still there are several closely\nrelated papers [12, 10, 18, 7, 1, 13]. Many of them provide deeper analysis than what xevtgen does,\nand high-level interface to predeﬁned transformations.\nAn advantage of xevtgen compared to those related studies is its simple interface. The trans-\nformation can be deﬁned by a dummy Fortran code with simple directives, while the other code\ntransformation tools require a certain level of knowledge in theory and practices about compiler\nconstruction, and knowledge about some programming language (C, C++ or Java) in addition to\nFortran. The simplicity of xevtgen might be closer to the C preprocessor, which is basically a\ntext rewriting tool. But, unlike text rewriting tools, xevtgen’s transformation reﬂects the Fortran\nsyntax, and it is easy to keep the transformed code following the Fortran syntax.\nXevtgen resembles to syntactic macro systems . However, there are some diﬀerences between\nxevtgen and other syntactic macro systems [9, 17, 5]. The biggest diﬀerence is that, xevtgen\napplies transforms onto particular code patterns deﬁned in dummy Fortran codes, while in most\nmacro systems, macros (and also C++ template) are invoked by macro identiﬁers. This is important\nfor our purpose: in many cases there is already a source code of a huge number of lines, and some\ntransformations need to be applied. Rewriting code with newly deﬁned macros will be cumbersome\nand error-prone, and the maintainer of the code may not want to modify the code for a particular\nplatform. Transformations of xevtgen can be applied without modifying the original code, or with\nlittle modiﬁcations such as insertions of some directives. Another diﬀerence is that, macro systems\nextend the language syntax, but xevtgen does not. So the xevtgen source code can be understood\nwith the standard knowledge about the Fortran language.\nThe purpose of the work reported in [2] is similar to ours. They use a complex tool chain to\nattain code analysis and rewriting. However, their approach assumes that users already know how\nto use each tool of their tool chain. Thus, the users need to learn the usage of several tools. On\nthe other hand, xevtgen allows users to write transformation rules in Fortran plus a small set of\ndirectives. Therefore, xevtgen is expected to be easier-to-learn than other tools that need special\nlanguages and/or tools for deﬁning code transformations.\nIn HPC code tuning, various simple transformations are frequently needed. In some supercom-\nputer centers, such knowledge is documented by showing examples of code rewrites, each of which\nconsists of the code before rewrite and the code after rewrite. Sometimes it is straightforward to\nmodify such a rewrite example into an xevtgen rule. Based on that observation, we expect that\nxevtgen can be used also for documentation of useful code rewrites. Actually, our collaborators[4],\nwho have collected HPC code rewrites independently from xevtgen, are now trying to formulate\ntheir knowledge into xevtgen rules. It would be useful to collect such code rewrites in a format both\nhuman readable and machine executable.\n282\nInternational Journal of Networking and Computing\n10 Conclusion\nIn this paper, we have reported xevtgen, a code transformer generator of Xevolver tools. Trans-\nformations can be deﬁned by a dummy Fortran code with some directives. Users do not need to know\ntheory and practices of compilers to deﬁne code transformations. We have shown several examples\nand use cases of xevtgen. The implementation of xevtgen, which generates an XSLT template from\ninﬁle, is brieﬂy explained.\nBy using list tgen-variables and repeated applications, xevtgen can provide reasonably useful\ntransformations. Some missing features will be provided by other parts of our toolset, as is discussed\nin Section 8. In combination with the toolset, xevtgen will provide the basic functionality of user-\ndeﬁned code transformation.\nAcknowledgment\nThis work is partially supported by a JST CREST project “An evolutionary approach to construction\nof a software development environment for massively-parallel heterogeneous systems.” The authors\nwould like to thank Prof. Yamamoto of Tohoku University for allowing us to use the Numerical\nTurbine application. The authors are grateful also to the anonymous reviewers, whose comments\nenhance and improve this article.\nReferences\n[1] Ira D. Baxter, Christopher Pidgeon, and Michael Mehlich. DMS: Program transformations\nfor practical scalable software evolution. In Proc. 26th International Conference on Software\nEngineering (ICSE’04), pages 625–634, 2004.\n[2] Daniel Chavarria-Miranda, Ajay Panyala, Wenjing Ma, Adrian Prantl, and Sriram Krish-\nnamoorthy. Global transformations for legacy parallel applications via structural analysis and\nrewriting. Parallel Computing, 43:1–26, 2015.\n[3] Zachary Devito, Niels Joubert, Francisco Palacios, Stephen Oakley, Montserrat Medina, Mike\nBarrientos, Erch Elsen, Frank Ham, Alex Aiken, Karthik Duraisamy, Eric Darve, Juan Alonso,\nand Pat Hanrahan. Liszt: A domain speciﬁc language for building portable mesh-based pde\nsolver s. In 2011 International Conference for High Performance Computing , Networking,\nStorage and Analysis (SC’11), pages 9:1–9:12, 2011.\n[4] Ryusuke Egawa, Kazuhiko Komatsu, and Hiroaki Kobayashi. Designing an HPC refactoring\ncatalog toward the exa-scale computing era. Sustained Simulation Performance 2014, pages\n91–98, 2014.\n[5] Kanako Homizu, Ken Wakita, and Akira Sasaki. An implementation of a hygienic syntactic\nmacro system for JavaScript using parsing expression grammar and a scheme macro expander.\nIPSJ Transactions on Programming, 6(2):85–101, 2013.\n[6] Michael Kay. XSLT 2.0 and XPath 2.0 Programmer’s Reference (Programmer to Programmer).\nWrox Press Ltd., 4 edition, 2008.\n[7] Uwe Kuester. A language for the deﬁnition of Fortran source to source transformations. In\nComputational Science and High Performance Computing IV , pages 181–190. Springer, 2011.\n[8] Satoshi Miyake, Satoru Yamamoto, Yasuhiro Sasao, Kazuhiro Momma, Toshihiro Miyawaki,\nand Hiroharu Ooyama. Unsteady ﬂow eﬀect on nonequilibrium condensation in 3-D low pressure\nsteam turbine stages. In ASME Turbo Expo 2013, 2013.\n[9] Hiroyasu Nagata. FORMAL: a language with a macro-oriented extension facility. computer\nLanguages, 5:65–76, 1980.\n283\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\n[10] Boyana Norris, Albert Hartono, and William Gropp. Annotations for productivity and per-\nformance portability. In Petascale Computing: Algorithms and Applications , Computational\nScience, pages 443–462. Chapman & Hall / CRC Press, Taylor and Francis Group, 2007.\n[11] OpenACC.org. OpenACC – Directives for Accelerators, 2011.\n[12] Daniel J. Quinlan, Markus Schordan, Bobby Philip, and Markus Kowarschik. The speciﬁcation\nof source-to-source transformations for the compile-time optimization of parallel object-oriented\nscientiﬁc applications. In Proc. LCPC 2001, pages 383–394, 2003.\n[13] Georges-Andre Sibler and Alain Darte. The Nestor Library: A tool for implementing Fortran\nsource to source transformations. In Proc. 7th Int. Conf. High-Performance Computing and\nNetworking (HPCN Europe 1999), pages 653–662, 1999.\n[14] Takashi Soga, Akihiro Musa, Youichi Shimomura, Kenichi Itakura, Koki Okabe, Ryusuke\nEgawa, Hiroyuki Takizawa, and Hiroaki Kobayashi. Performance evaluation of NEC SX-9 us-\ning real science and engineering applications. In International Conference on High Performance\nComputing, Networking, Storage and Analysis (SC09) , pages 1–12, 2009.\n[15] Reiji Suda, Luo Cheng, and Takahiro Katagiri. A mathematical method for online autotuning of\npower and energy consumption with corrected temperature eﬀects. Procedia Computer Science,\n18:1302–1311, 2013.\n[16] Hiroyuki Takizawa, Shoichi Hirasawa, Yasuharu Hayashi, Ryusuke Egawa, and Hiroaki\nKobayashi. Xevolver: An XML-based code translation framework for supporting HPC ap-\nplication migration. In Proc. IEEE International Conference on High Performance Computing\n(HiPC’14), pages 1–11, December 2014.\n[17] Daniel Weise and Roger Crew. Programmable syntax macros. InProc. PLDI ’93, pages 156–165,\n1993.\n[18] Songqing Yue and Jeﬀ Gray. SPOT: A DSL for extending Fortran programs with metapro-\ngramming. Advances in Software Engineering, 2014:23, December 2014.\n284\nInternational Journal of Networking and Computing\n1 !$xev tgen list(l, l1, l2) stmt\n2 !$xev tgen var(v) stmt\n3 !$xev tgen var(i, i0, i1, i2) exp\n4\n5 !$xev tgen src begin\n6 !$xev loop split\n7 DO i = i0, i1, i2\n8 !$xev tgen stmt(l)\n9 END DO\n10 !$xev tgen src end\n11 !$xev tgen dst begin\n12 !$xev loop split begin\n13 DO i = i0, i1, i2\n14 END DO\n15 DO i = i0, i1, i2\n16 !$xev tgen stmt(l)\n17 END DO\n18 !$xev loop split end\n19 !$xev tgen dst end\n20\n21 !$xev tgen src begin\n22 !$xev loop split begin\n23 DO i = i0, i1, i2\n24 !$xev tgen stmt(l1)\n25 END DO\n26 DO i = i0, i1, i2\n27 !$xev split point\n28 !$xev tgen stmt(l2)\n29 END DO\n30 !$xev loop split end\n31 !$xev tgen src end\n32 !$xev tgen dst begin\n33 DO i = i0, i1, i2\n34 !$xev tgen stmt(l1)\n35 END DO\n36 DO i = i0, i1, i2\n37 !$xev tgen stmt(l2)\n38 END DO\n39 !$xev tgen dst end\n40\n41 !$xev tgen src begin\n42 !$xev loop split begin\n43 DO i = i0, i1, i2\n44 !$xev tgen stmt(l1)\n45 END DO\n46 DO i = i0, i1, i2\n47 !$xev tgen stmt(v)\n48 !$xev tgen stmt(l2)\n49 END DO\n50 !$xev loop split end\n51 !$xev tgen src end\n52 !$xev tgen dst begin\n53 !$xev loop split begin\n54 DO i = i0, i1, i2\n55 !$xev tgen stmt(l1)\n56 !$xev tgen stmt(v)\n57 END DO\n58 DO i = i0, i1, i2\n59 !$xev tgen stmt(l2)\n60 END DO\n61 !$xev loop split end\n62 !$xev tgen dst end\nFigure 1: Transformation for loop split\n285\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\nspecializing rule -\nsource code\n?\ntemporary rule -\ndummy inﬁle\n6\nspecialized inﬁle\n6\n- destination ﬁle\nFigure 2: A triplet transformation\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g16 /g688 /g616 /g345 /g16 /g9\n/g7\n/g18 /g3 /g617 /g613 /g613 /g3 /g14 /g688 /g616 /g345 /g14 /g9\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g13 /g688 /g616 /g345 /g13 /g9\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g15 /g688 /g142 /g149 /g150 /g131 /g148 /g150 /g345 /g142 /g135 /g144 /g134\n/g12 /g12 /g616 /g3 /g688 /g3 /g12 /g22 /g383 /g15 /g384\n/g12\n/g12 /g617 /g3 /g688 /g3 /g12 /g12 /g616 /g683 /g616\n/g12 /g12 /g618 /g3 /g688 /g3 /g12 /g12 /g617 /g683 /g616\n/g12 /g12 /g9 /g3 /g688 /g3 /g12 /g23 /g383 /g15 /g384\n/g12 /g12 /g8 /g3 /g688 /g3 /g12 /g12 /g9 /g350 /g616\n/g12 /g12 /g7 /g3 /g688 /g3 /g12 /g12 /g8 /g350 /g616\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g12 /g688 /g12 /g12 /g617 /g345 /g12 /g12 /g9\n/g12 /g9 /g3 /g383 /g12 /g348 /g15 /g8 /g348 /g12 /g12 /g618 /g348 /g18 /g21 /g348 /g12 /g348 /g10 /g8 /g348 /g12 /g12 /g8 /g384 /g23 /g11 /g8 /g17 /g3\n/g22\n/g23 /g5 /g6 /g688 /g613 /g348 /g613 /g7 /g613\n/g8 /g15 /g22 /g8\n/g22 /g23 /g5 /g6 /g688 /g616 /g348 /g613 /g7 /g613\n/g8 /g17 /g7 /g3 /g12 /g9\n/g54 /g59/g3 /g89 /g72/g85 /g86 /g76 /g82 /g81\n/g670\n(a) Loop structure in the original code.\n/g50 /g83 /g72 /g81 /g36/g38 /g38 /g89 /g72/g85 /g86 /g76 /g82 /g81\n/g352 /g603 /g131 /g133 /g133 /g3 /g142 /g145 /g145 /g146 /g3 /g146 /g148 /g139 /g152 /g131 /g150 /g135 /g383 /g15 /g384\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g16 /g688 /g616 /g345 /g16 /g9\n/g352 /g603 /g131 /g133 /g133 /g3 /g142 /g145 /g145 /g146 /g3 /g137 /g131 /g144 /g137\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g14 /g688 /g616 /g345 /g14 /g9\n/g352 /g603 /g131 /g133 /g133 /g3 /g142 /g145 /g145 /g146 /g3 /g137 /g131 /g144 /g137 /g345 /g152 /g135 /g133 /g150 /g145 /g148\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g13 /g688 /g616 /g345 /g13 /g9\n/g352 /g603 /g131 /g133 /g133 /g3 /g142 /g145 /g145 /g146 /g3 /g152 /g135 /g133 /g150 /g145 /g148\n/g7 /g18 /g3 /g617 /g613 /g613 /g3 /g12 /g688 /g616 /g345 /g139 /g144 /g151 /g143\n/g352 /g603 /g131 /g133 /g133 /g3 /g142 /g145 /g145 /g146 /g3 /g149 /g135 /g147\n/g7 /g18 /g3 /g15 /g688 /g142 /g149 /g150 /g131 /g148 /g150 /g345 /g142 /g135 /g144 /g134\n/g12 /g9 /g3 /g383 /g12 /g348 /g137 /g135 /g348 /g12 /g22 /g383 /g15 /g384 /g3 /g348 /g131 /g144 /g134 /g348 /g3 /g12 /g348 /g142 /g135 /g348 /g12 /g23 /g383 /g15 /g384 /g384 /g3 /g8 /g27 /g12 /g23\n/g8\n/g17 /g7 /g3 /g7 /g18\n/g12 /g9 /g3 /g383 /g139 /g348 /g144 /g135 /g348 /g12 /g22 /g383 /g15 /g384 /g384 /g3 /g23 /g11 /g8 /g17\n/g12 /g9 /g3 /g383 /g12 /g348 /g15 /g8 /g348 /g383 /g12 /g22 /g383 /g15 /g384 /g683 /g617 /g384 /g348 /g18 /g21 /g348 /g12 /g348 /g10 /g8 /g348 /g383 /g12 /g23 /g383 /g15 /g384 /g350 /g616 /g384 /g384 /g3 /g23 /g11 /g8 /g17\n/g22 /g23 /g5 /g6 /g688 /g613 /g348 /g613 /g7 /g613\n/g8 /g15 /g22 /g8\n/g22 /g23 /g5 /g6 /g688 /g616 /g348 /g613 /g7 /g613\n/g8 /g17 /g7 /g3 /g12 /g9\n/g670 (b) Loop structure for the OpenACC com-\npiler.\nFigure 3: Loop nests of Numerical Turbine.\n286\nInternational Journal of Networking and Computing\nprogram nt_opt\n!$xev tgen var(i1,i2,i3,i4,i5,i6,if) stmt\n!$xev tgen list(body) stmt\n!$xev tgen var(lstart,lend,II2,IIF) exp\n!$xev tgen condef(has_doi) contains stmt begin\nDO I=II2,IIF\n!$xev tgen stmt(if)\n!$xev tgen stmt(body)\nEND DO\n!$xev tgen end\n!$xev tgen list(stmt_with_doi) stmt cond(has_doi)\n!$xev tgen src begin\nDO L=lstart,lend\n!$xev tgen stmt(stmt_with_doi)\nEND DO\n!$xev end tgen src\n!$xev tgen dst begin\nDO I=1,inum\nDO L = lstart, lend\nIF (I .GE. IS(L) .AND. I .LE. IT(L)) THEN\nEXIT\nEND IF\nEND DO\n!$xev tgen stmt(if)\n!$xev tgen stmt(body)\nEND DO\n!$xev end tgen dst\nend program nt_opt\nFigure 4: A dummy Fortran code for optimizing Numerical Turbine.\n/g1004/g856/g1004/g1005\n/g1004/g856/g1005\n/g1005\n/g1005/g1004\n/g1005/g1004/g1004\n/g1005/g1004/g1004/g1004\n/g62/g381/g381/g393/g882/g1006/g1004/g1004 /g62/g381/g381/g393/g882/g1006/g1005/g1004 /g62/g381/g381/g393/g882/g1007/g1004/g1004 /g62/g381/g381/g393/g882/g1007/g1005/g1004 /g62/g381/g381/g393/g882/g1008/g1004/g1004 /g62/g381/g381/g393/g882/g1008/g1005/g1004\n/g94/g393/g286/g286/g282/g437/g393/g3/g90/g258/g410/g349/g381\n/g94/g121/g882/g1013/g94/g121/g882/g4/g18/g28/g121/g286/g381/g374/g3/g28/g1009/g882/g1006/g1010/g1007/g1004/g18/g1006/g1004/g1011/g1004/g60/g1006/g1004\nFigure 5: Numerical Turbine performance evaluation results.\n287\nXevtgen: Fortran code transformer generator for high performance scientiﬁc codes\n<xev pragma>\n<xev clause list>\n<xev clause name=\"xev\"/>\n<xev clause name=\"tgen\"/>\n<xev clause name=\"var\">\n<xev literal name=\"a\"/>\n</xev clause>\n<xev clause name=\"exp\"/>\n</xev clause list>\n</xev pragma>\n<xev pragma>\n<xev clause list>\n<xev clause name=\"xev\"/>\n<xev clause name=\"tgen\"/>\n<xev clause name=\"trans\"/>\n<xev clause name=\"exp\"/>\n<xev clause name=\"src\">\n<xevparse code exp>\n<SgFunctionCallExp>\n<SgFunctionRefExp name=\"sqrt\"/>\n<SgExprListExp>\n<SgVarRefExp name=\"a\"/>\n</SgExprListExp>\n</SgFunctionCallExp>\n</xevparse code exp>\n</xev clause>\n<xev clause name=\"dst\">\n<xevparse code exp>\n<SgMultiplyOp paren=\"0\">\n<SgVarRefExp name=\"a\"/>\n<SgVarRefExp name=\"a\"/>\n</SgMultiplyOp>\n</xevparse code exp>\n</xev clause>\n</xev clause list>\n</xev pragma>\nFigure 6: Converted XML document from sqrt example by xevparse (Only the pragma parts are\nshown)\n288\nInternational Journal of Networking and Computing\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n<xsl:template match=\"*\">\n<xsl:param name=\"xevtgencontext\" select=\"’f’\"/>\n<xsl:param name=\"xevtgensibling\" select=\"0\"/>\n<xsl:param name=\"xevtgenvar0\" select=\"/..\"/>\n<xsl:choose>\n<xsl:when test=\"count(self::*[self::SgFunctionCallExp][count(@*)=0]\n[count(*)=2][*[1]/self::SgFunctionRefExp][*[1]/@name=&quot;sqrt&quot;]\n[count(*[1]/@*)=1][count(*[1]/*)=0][*[2]/self::SgExprListExp]\n[count(*[2]/@*)=0][count(*[2]/*)=1])>0\">\n<xsl:element name=\"SgMultiplyOp\">\n<xsl:attribute name=\"paren\">0</xsl:attribute>\n<xsl:apply-templates select=\"*[2]/*[1]/self::*\">\n<xsl:with-param name=\"xevtgencontext\" select=\"’t’\"/>\n<xsl:with-param name=\"xevtgensibling\" select=\"1\"/>\n<xsl:with-param name=\"xevtgenvar0\" select=\"*[2]/*[1]/self::*\"/>\n</xsl:apply-templates>\n<xsl:apply-templates select=\"*[2]/*[1]/self::*\">\n<xsl:with-param name=\"xevtgencontext\" select=\"’t’\"/>\n<xsl:with-param name=\"xevtgensibling\" select=\"1\"/>\n<xsl:with-param name=\"xevtgenvar0\" select=\"*[2]/*[1]/self::*\"/>\n</xsl:apply-templates>\n</xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:copy>\n<xsl:copy-of select=\"@*\"/>\n<xsl:apply-templates>\n<xsl:with-param name=\"xevtgencontext\" select=\"$xevtgencontext\"/>\n<xsl:with-param name=\"xevtgenvar0\" select=\"$xevtgenvar0\"/>\n</xsl:apply-templates>\n</xsl:copy>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n</xsl:stylesheet>\nFigure 7: Generated XSLT template from sqrt example by xevtgen\n289"
}