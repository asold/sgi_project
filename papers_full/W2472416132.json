{
  "title": "Improving an Industrial Test Generation Tool Using SMT Solver",
  "url": "https://openalex.org/W2472416132",
  "year": 2016,
  "authors": [
    {
      "id": "https://openalex.org/A5101591241",
      "name": "Hao Ren",
      "affiliations": [
        "Iowa State University"
      ]
    },
    {
      "id": "https://openalex.org/A5112588904",
      "name": "Devesh Bhatt",
      "affiliations": [
        "Honeywell (United States)"
      ]
    },
    {
      "id": "https://openalex.org/A5050118609",
      "name": "Jan Hvozdovic",
      "affiliations": [
        "Honeywell (Czechia)"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2081144899",
    "https://openalex.org/W2020116018",
    "https://openalex.org/W4239921445",
    "https://openalex.org/W1567306564",
    "https://openalex.org/W2161488870",
    "https://openalex.org/W92576581"
  ],
  "abstract": "We present an SMT solving based test generation approach for MATLAB Simulink designs, implemented in the HiLiTE tool developed by Honeywell for verification of avionic systems. The test requirements for a Simulink model are represented by a set of behavioral equivalence classes for each block in the model, in terms of its input(s) and output. A unique feature of our approach is that the equivalence class definitions, as well as the upstream subgraph of a block under test, are translated as constraints into SMT expressions. An SMT solver is called at the back-end of HiLiTE to find a satisfiable solution that is further augmented into an end-to-end test case at the model level.",
  "full_text": "Improving an Industrial Test Generation\nTool Using SMT Solver\nHao Ren1, Devesh Bhatt2(B), and Jan Hvozdovic3\n1 Department of Electrical and Computer Engineering, Iowa State University,\nAmes, IA 50014, USA\n2 Honeywell Aerospace Advanced Technology, 1985 Douglas Dr N,\nGolden Valley, MN 55422, USA\ndevesh.bhatt@honeywell.com\n3 Honeywell spol. s.r.o. - Aerospace Engineering, 100 Turanka,\n627 00 Brno, Czech Republic\nAbstract. We present an SMT solving based test generation approach\nfor MATLAB Simulink designs, implemented in the HiLiTE tool devel-\noped by Honeywell for veriﬁcation of avionic systems. The test require-\nments for a Simulink model are represented by a set of behavioral equiv-\nalence classes for each block in the model, in terms of its input(s) and\noutput. A unique feature of our approach is that the equivalence class\ndeﬁnitions, as well as the upstream subgraph of a block under test, are\ntranslated as constraints into SMT expressions. An SMT solver is called\nat the back-end of HiLiTE to ﬁnd a satisﬁable solution that is further\naugmented into an end-to-end test case at the model level.\n1 Introduction\nAs the industry practices engage model-based design increasingly, model-based\nveriﬁcation and testing [ 1] techniques emerge to keep up with the trends. In\navionics area, comprehensive testing methods and tools are required to assure\nthat safety-critical systems like ﬂight controls are certiﬁed to the guidelines\nestablished by standard processes such as the DO-178C [2].\nAt Honeywell, researchers have developed theHoneywell Integrated Lifecycle\nTools & Environment (HiLiTE) suite of tools for the automated veriﬁcation\nof avionics applications developed using MATLAB Simulink/Stateﬂow. HiLiTE\nperforms automatic test generation [3] on Simulink models based upon the low-\nlevel requirements (LLRs) expressed by the model elements. The tests are then\napplied to the executable object code generated from the model to verify that the\ncode complies with the LLRs in the design model. HiLiTE has been qualiﬁed as a\nDO-178C veriﬁcation tool and deployed in several avionics product certiﬁcations\nto deliver signiﬁcant cost savings in the veriﬁcation eﬀort.\nThis paper presents an SMT solving technique to extend the earlier\nheuristics-based test case generation approaches implemented in HiLiTE, pro-\nviding improved performance on models with complex constraints or non-linear\nThis research was supported in part by NASA Contract NNA13AC55C.\nc⃝ The Author(s) 2016\nS. Rayadurgam and O. Tkachuk (Eds.): NFM 2016, LNCS 9690, pp. 100–106, 2016.\nDOI: 10.1007/978-3-319-40648-0\n8\nImproving an Industrial Test Generation Tool Using SMT Solver 101\narithmetic computations. SMT solving is the decision procedure of determining\nwhether a formula in ﬁrst-order-logic is satisﬁable and ﬁnding a concrete solution\nif it is. SMT Solvers, such as Z3 [ 4], Yices [5], etc., have rapidly matured over\nthe last 5 years and have been used in various areas including automated test\ncase generation [6,7]. In our SMT solving based approach, each LLR equivalence\nclass for a block type is represented by a set of constraints, applied on block-level\ninput(s) and expected output. Meanwhile, test space is also constrained by the\nsubgraph environment that the block under test (BUT) is embedded in. The\ncollection of constraints can be formulated as an SMT problem and expressed in\na standard format by HiLiTE in an automatic fashion. SMT solver is then called\nto generate the satisﬁable solution once for all ports in the related subgraph. The\nsolution is merged back to the entire graph for a complete model-level input-to-\noutput test case. With the integration of heuristics and SMT solving techniques,\nHiLiTE has been successfully used to generate requirement-based test cases for\na great range of large-scale complex constrained avionics models.\nSection2 describes the HiLiTE normal test case generation approach and the\nneed for improvements. Section 3 describes the formalized language of equiva-\nlence classes of block’s behaviors and SMT solving based test case generation\napproach. Finally, the conclusion and future work are discussed in Sect.4.\n2 HiLiTE Test Generation Approach\nHiLiTE generates speciﬁc tests at the model level to exercise the equivalence\nclasses of the behavior of each block embedded in the model. In the original\nHiLiTE tool, each equivalence class of a block’s behavior is represented by a set\nof test case templates , each of which uses heuristics to select a speciﬁc combina-\ntion of values for the block under test (BUT) input(s) and output that satisfy this\nequivalence class. Backward and forward propagation search through the com-\nputations of other blocks in the model generates a test vector in terms of model\ninputs and outputs to ensure controllability of the BUT inputs and observability\nof the expected BUT output. Figure1 shows a Simulink model extracted from a\ncomplex industrial model to illustrate this.\nFig. 1. Test case generation for product block.\n102 H. Ren et al.\nWhen the product block is the BUT, the test case template (Fig.2) assigns\nthe two inputs with non-zero values 2 and 4 respectively. After the backward and\nforward propagation search, the generated test vectors are given in Fig.2 where\nblue column heading denotes model input and green denotes model output.\nFig. 2. Test case template (top) and test vector for the product block in Fig. 1.\nWhen the switch block is the BUT, the equivalence class requires diﬀerent\nvalues at its data inputs (FalseIn, TrueIn) to verify unique impact of an input\non the block’s output. One test case template assigns 44 to FalseIn and 46 to\nTrueIn, but this leads to a conﬂict at the model inputAdjustPct after backward\ncomputation through the two look-up tables since their data points are in the\nsame range. HiLiTE then further tries several alternative templates based on\nheuristics, yet all result in search failure. The root cause is that HiLiTE templates\nheuristics in the equivalence class domain prematurely pick block’s local input\nvalues, while this problem involves taking into account constraints imposed by\nthe look-up table blocks driven by the same input AdjustPct.\n3 Applying SMT Solving in Test Case Generation\nTest generation diﬃculties such as those noted above can be addressed by an\napproach that solves computational constraints of the upstream subgraph of\nBUT in conjunction with the constraints on BUT inputs imposed by the behav-\nior equivalence class. SMT can be thought of the constraint satisfaction prob-\nlem expressed in Boolean formulas, linear/nonlinear arithmetic in integer/real\ndomain, bit-vectors and so on. In HiLiTE, we added SMT solving based approach\nthat embodies formulating test case generation constraints from both equivalence\nclasses, constraints related to upstream source ports and the subgraph compu-\ntations upstream of the BUT into an SMT problem. Therefore, constraints can\nbe solved together to ﬁnd a satisfying solution which excludes any conﬂicts.\n3.1 Formal Speciﬁcation of Equivalence Classes of Block Behaviors\nAn equivalence class of a block behavior, which represents a test requirement, is\nnow expressed in HiLiTE with formalized rules on the block’s input and output\nImproving an Industrial Test Generation Tool Using SMT Solver 103\nTable 1. Equivalence class deﬁnitions for switch block.\nEquiv. Class Deﬁnition for each input and output\nEquiv. Class Name TrueIn FalseIn Control Output\nVerify TRUE Input Exists NEQ(FalseIn, TrueIn) EQ(Control, 1) Valid\nVerify FALSE Input Exists NEQ(FalseIn, TrueIn) EQ(Control, 0) Valid\nports. These rules are expressed in a language as shown in Table 1 for switch\nblock with rule names in blue. Each rule is automatically translated, based\nupon formal deﬁnitions, into SMT logic formula in a straightforward way.\nFor example, “Exists” for port TrueIn is evaluated to “ true” if any value is\npresent, “NEQ(FalseIn, TrueIn)” of portFalseIn is interpreted as “FalseIn ̸=\nTrueIn”, and “Equal(Control, 1)” of portControl is interpreted as “Control =\ntrue” since Control has a Boolean type. The overall SMT logic formula for an\nequivalence class is the conjunction of individual formulas translated from equiv-\nalence class rules for each block port. E.g., the equivalence class “Verify TRUE\nInput” corresponds to “(FalseIn ̸= TrueIn)∧(Control = true)”.\n3.2 SMT Logic Formula for the Blocks’ Computation\nSMT logic formula for a block captures the block’s mathematical computation for\neach time step; block formulas are stitched together to yield a subgraph formula.\nLet m be the number of time steps tried in test case generation. Examples:\n– Sum: ⋀\nm−1\nj=0 (Outj =Σ n\ni=1In ij ).\n– Comparator: ⋀ m−1\nj=0 (Outj = In 1j ∼ In 2j ), ∼∈ {=, ̸=,> ,< , ≥, ≤}.\n– Switch: ⋀ m−1\nj=0 (((!In 3j ) ∧ (Outj = In 1j )) ∨ (In 3j ∧ (Outj = In 2j ))).\n– 1D Look-up Table : ⋀ m−1\nj=0 ((⋁ n\ni=1((Inj ∈ Rangei)∧(Outj = fi(Inj )))), where\nfi is a linear function of Inj given the value of Inj in Rangei.\n– UnitDelay:( Out0 = initial constant) ∧ ⋀ m−1\nj=1 (Outj = Inj−1).\nNote: support for time-dependent blocks (e.g., UnitDelay) also allows us to\nexplore feedback loops in the model for bounded number of steps.\n3.3 Formulated SMT Problem\nHiLiTE explores the upstream subgraph of the BUT to ensure all constraints\nimposed by the subgraph computations on the test case generation are included.\nThe subgraph exploration uses depth-ﬁrst search, starting from the inputs of the\nBUT identiﬁed in its equivalence class, all the way back to the model inputs.\nOnce the SMT-available subgraph is obtained, HiLiTE loops through each block\nin it to collect its SMT logic formulas. SMT logic formulas are further translated\ninto expressions in SMT-LIB 2.0 standard format, recognized by popular SMT\nsolvers like Z3, with actual port names as variables. Additionally, to specify\n104 H. Ren et al.\nthe block connections, each input in the formula is replaced by its source block\noutput. For instance, the SMT expression for theswitch block in Fig.1 is (assert\n(and (not (= gainTable 1.O1 gainTable 2.O1)) (= equalTo.O1 true))) . Finally,\nthe variables in the SMT expressions are substituted by a short formy i j (time\nstep subscript j is omitted if there are no time-dependent blocks), where each\nblock is assigned with a unique index i as shown in Fig.3.\nFig. 3. Input ﬁle for SMT solver Z3 of test generation for switch block in Fig. 1.\nThe SMT logic formula is built initially with the number of time steps m\ndetermined by the equivalence class of the BUT: if the result of SMT solving is\n“unsat”, the formula is then updated with m ← m + 1. The process is repeated\nuntil either SMT solver returns “sat” or a pre-deﬁned time step limit is reached.\nIn the worst case,m may become very large before a value at some point (such as\nthe output of a timer/integrator/counter) of the model is accumulated to satisfy\nthe constraints, in which case SMT solver may break down or return “unknown”.\nTo bypass blocks causing over-sized formulas, and certain mathematical blocks\n(e.g., sin) not supported by SMT solving, HiLiTE identiﬁes those blocks, records\nthem as pending, and explores the neighbor paths, resulting in an incomplete\nsubgraph. The pending blocks and their upstream blocks are excluded from the\nsolution returned by SMT solver. HiLiTE normal method then picks up from\nhere to further propagate the pending values. An improvement can be done if\nthe backward search goes through a switch block, only one data input of which\nhas pending block(s) on its upstream. The values on the branch with pending\nblock(s) do not matter if we force the switch block to disable that branch. This\nis done by modifying the SMT logic formula of that switch block. Suppose port\nIn\n1 of block switch is to be disabled, then the SMT logic formula becomes⋀ m−1\nj=0 (In 3j ∧ (Outj = In 2j )).\nImproving an Industrial Test Generation Tool Using SMT Solver 105\nFig. 4. Architecture of SMT solving in test case generation.\n3.4 Tool Architecture\nThe SMT solving based test case generation is implemented by HiLiTE as a\nfully automated process shown in Fig. 4. Test cases needing SMT solving based\napproach are identiﬁed by the complexity of relationships detected during model\nanalysis. For these, the test generation module formulates a collection of SMT\nexpressions and writes them into a .smt2 ﬁle as described in Sect. 3. The SMT\nsolver is called as a back-end, generating a solution which is then merged into\ntest generation search space. HiLiTE normal method takes over from here to\npropagate the switch block output through the forward path to the model\noutput GainAdj via the intervening product block, using a non-zero value for\nthe second input of product block to ensure observability. This process results\nin valid test cases (Fig.5) for the switch block in Fig.2.\nFig. 5. Test vector generated for the switch block in Fig. 2 via SMT solving.\n3.5 Nonlinear Applications\nModern SMT solvers are capable of solving a great range of non-linear problems\nused be computational intractable. Figure 6 shows a simple two-variable 2nd-\norder polynomial model. Z3 returns an answer for this case (as shown in Fig.6)\nas in many other nonlinear problems.\n106 H. Ren et al.\nFig. 6. A polynomial model and the test vector for the product block via SMT solving.\n4 Conclusion and Future Work\nWe extended the HiLiTE test generation capability with an SMT solving based\napproach for solving certain complex constrained problems. The improved tool\ncombines HiLiTE normal search method and SMT solving, and has been suc-\ncessfully applied on many large-scale industrial models. HiLiTE is also being\nextended to derive invariant bounds on the number of time steps (e.g., for a\ntimer) that will help bound the array size. We are also applying SMT solving to\nsupport such invariant generation, in which each condition-guarded path that\ncaptures a certain pattern of model behavior can be validated by SMT solving.\nOpen Access. This chapter is distributed under the terms of the Creative Com-\nmons Attribution 4.0 International License ( http://creativecommons.org/licenses/by/\n4.0/), which permits use, duplication, adaptation, distribution and reproduction in any\nmedium or format, as long as you give appropriate credit to the original author(s) and\nthe source, a link is provided to the Creative Commons license and any changes made\nare indicated.\nThe images or other third party material in this chapter are included in the work’s\nCreative Commons license, unless indicated otherwise in the credit line; if such mate-\nrial is not included in the work’s Creative Commons license and the respective action\nis not permitted by statutory regulation, users will need to obtain permission from the\nlicense holder to duplicate, adapt or reproduce the material.\nReferences\n1. Bhatt, D., Madl, G., Oglesby, D.: System Architecture Driven Software Design\nAnalysis Methodology and Toolset. In: SAE International (2012)\n2. RTCA DO-178C, Software Considerations in Airborne Systems and Equipment Cer-\ntiﬁcation, RTCA Inc. (2011)\n3. Bhatt, D., Madl, G., Oglesby, D., Schloegel, K.: Towards scalable veriﬁcation of\ncommercial avionics software. In: Proceedings of the AIAA Infotech @ Aerospace\nConference, April 2010\n4. Z3Prover. https://github.com/Z3Prover/z3/wiki/\n5. The Yices SMT Solver. http://yices.csl.sri.com/\n6. Beyer, D., Chlipala, A.J., Henzinger, T.A., Jhala, R., Majumdar, R.: Generating\nTests from Counterexamples. In: ICSE (2004)\n7. Peleska, J., Vorobev, E., Lapschies, F.: Automated test case generation with SMT-\nsolving and abstract interpretation. In: Bobaru, M., Havelund, K., Holzmann, G.J.,\nJoshi, R. (eds.) NFM 2011. LNCS, vol. 6617, pp. 298–312. Springer, Heidelberg\n(2011)",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.8082398176193237
    },
    {
      "name": "Solver",
      "score": 0.6854814291000366
    },
    {
      "name": "Satisfiability modulo theories",
      "score": 0.6240178942680359
    },
    {
      "name": "Avionics",
      "score": 0.5431851148605347
    },
    {
      "name": "Block (permutation group theory)",
      "score": 0.542222797870636
    },
    {
      "name": "Equivalence (formal languages)",
      "score": 0.49689725041389465
    },
    {
      "name": "Algorithm",
      "score": 0.43349215388298035
    },
    {
      "name": "Programming language",
      "score": 0.4326717257499695
    },
    {
      "name": "MATLAB",
      "score": 0.4212111830711365
    },
    {
      "name": "Test set",
      "score": 0.4209938049316406
    },
    {
      "name": "Artificial intelligence",
      "score": 0.1771148443222046
    },
    {
      "name": "Mathematics",
      "score": 0.07902082800865173
    },
    {
      "name": "Composite material",
      "score": 0.0
    },
    {
      "name": "Geometry",
      "score": 0.0
    },
    {
      "name": "Materials science",
      "score": 0.0
    },
    {
      "name": "Discrete mathematics",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I173911158",
      "name": "Iowa State University",
      "country": "US"
    },
    {
      "id": "https://openalex.org/I82514191",
      "name": "Honeywell (United States)",
      "country": "US"
    },
    {
      "id": "https://openalex.org/I4210120083",
      "name": "Honeywell (Czechia)",
      "country": "CZ"
    }
  ],
  "cited_by": 8
}