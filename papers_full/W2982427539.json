{
  "title": "Weighted parsing for grammar-based language models",
  "url": "https://openalex.org/W2982427539",
  "year": 2019,
  "authors": [
    {
      "id": "https://openalex.org/A5027810566",
      "name": "Richard Mörbitz",
      "affiliations": [
        "Technische Universität Dresden"
      ]
    },
    {
      "id": "https://openalex.org/A5013068281",
      "name": "Heiko Vogler",
      "affiliations": [
        "Technische Universität Dresden"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2026113340",
    "https://openalex.org/W2322097385",
    "https://openalex.org/W2911246871",
    "https://openalex.org/W2115753373",
    "https://openalex.org/W1503860275",
    "https://openalex.org/W2125528794",
    "https://openalex.org/W1984256985",
    "https://openalex.org/W3005278268",
    "https://openalex.org/W2061786858",
    "https://openalex.org/W1987010534",
    "https://openalex.org/W2001023560",
    "https://openalex.org/W1980516134",
    "https://openalex.org/W2185441650",
    "https://openalex.org/W2083816738",
    "https://openalex.org/W2056653303",
    "https://openalex.org/W28676555",
    "https://openalex.org/W2169528473",
    "https://openalex.org/W2513212889",
    "https://openalex.org/W1975638108",
    "https://openalex.org/W1996484504",
    "https://openalex.org/W2152096446",
    "https://openalex.org/W2167954650",
    "https://openalex.org/W162009636",
    "https://openalex.org/W2150752478"
  ],
  "abstract": "We develop a general framework for weighted parsing which is built on top of grammar-based language models and employs flexible weight algebras. It generalizes previous work in that area (semiring parsing, weighted deductive parsing) and also covers applications outside the classical scope of parsing, e.g., algebraic dynamic programming. We show an algorithm which terminates and is correct for a large class of weighted grammar-based language models.",
  "full_text": "Proceedings of the 14th International Conference on Finite-State Methods and Natural Language Processing, pages 46–55\nDresden, Germany, September 23-25, 2019.c⃝2019 Association for Computational Linguistics\n46\nWeighted parsing for grammar-based language models\nRichard Mörbitz\nFaculty of Computer Science\nTechnische Universität Dresden\n01062 Dresden\nrichard.moerbitz@tu-dresden.de\nHeiko Vogler\nFaculty of Computer Science\nTechnische Universität Dresden\n01062 Dresden\nheiko.vogler@tu-dresden.de\nAbstract\nWe develop a general framework for weighted\nparsing which is built on top of grammar-\nbased language models and employs ﬂexible\nweight algebras. It generalizes previous work\nin that area (semiring parsing, weighted de-\nductive parsing) and also covers applications\noutside the classical scope of parsing, e.g., al-\ngebraic dynamic programming. We show an\nalgorithm which terminates and is correct for\na large class of weighted grammar-based lan-\nguage models.\n1 Introduction\nThe weighted parsing problem takes as input a\nweighted language model (LM) and a syntactic\nobject a. For instance, the LM can be given by\nsome grammar G, e.g., a context-free grammar\n(CFG) or a linear context-free rewriting system\n(LCFRS), and a can be some string. Each rule r\nof G has a value ( weight of r ); the weight is an ele-\nment of some weight algebra K. That algebra has\na binary commutative and associative operation ⊕\non its carrier set, which is used to handle ambigu-\nity of G. As output we expect an element k ∈K\nwhich is the ⊕-accumulation of the weight wt( d)K\nof each abstract syntax tree (AST) d of a in G, i.e.,\nk = ∑⊕\nd∈AST(G,a)\nwt(d)K\nwhere wt( d)K is computed by other operations of\nthe algebra K (using the weights of the occurring\nrules) and ∑⊕ is an extension of ⊕to inﬁnitely\nmany summands ( inﬁnitary sum operation ). For\ninstance, if K = [0,1] is the set of probabilities,\n⊕= max, ∑⊕ = sup, and wt( d)K is the product of\nall weights of occurrences of rules in d, then k is\nthe maximal probability of an AST of a in G.\nGoodman (1999) developed a formal frame-\nwork for weighted parsing, called semiring pars-\ning. As weight algebras he used complete semir-\nings ( K,⊕,⊗,0,1,∑⊕) ( Eilenberg, 1974), i.e., ∑⊕\nis the inﬁnitary sum operation extending ⊕. The\nbinary operation ⊗is used to compute wt( d)K.\nBy appropriate choices of the complete semiring,\nhe formalized the following problems as weighted\nparsing problems for a CFG G and a: the calcula-\ntion of recognition, string probabilities, number of\nderivations, derivation forests, probability of best\nderivation, best derivation, and best n derivations.\nThe algorithm which he proposed for solving the\nweighted parsing problem is a pipeline with two\nphases. In the ﬁrst phase, the CFG G, a deduc-\ntion system I (Shieber et al. , 1995), and the syn-\ntactic object a (i.e., a string) are combined into a\nsingle CFG G′ (using a construction idea of Bar-\nHillel et al. , 1961). In the second phase, the value\nk (from above) is calculated, if G′is acyclic.1\nNederhof (2003) developed a similar frame-\nwork, called weighted deductive parsing . As\nweight algebras he employed algebras of the form\n(K,min,0,Ω, ∑min) where K is a totally ordered\nset, ∑min = inf (inﬁmum), inf( K) ∈ K, and Ω\nis a set of superior functions; a superior function\nf is an operation on K which is monotone non-\ndecreasing in each argument and f (k1,..., km) ≥\nmax(k1,..., km) holds. The algorithm which he\nproposed for solving the weighted parsing prob-\nlem is again a pipeline with two phases, where\nthe ﬁrst phase is the same as in the framework\nof Goodman (1999) and the resulting CFG G′ is\ndenoted by c(G,a). In the second phase, he em-\nployed the algorithm of Knuth (1977), which gen-\neralizes the shortest distance algorithm of Dijkstra\n(1959) from graphs to hypergraphs and also works\nif G′ is cyclic. If the CFG G′ is non-branching,\ni.e., a linear grammar ( Khabbaz, 1974, Def. 1),\nthen in the second phase a graph algorithm can\n1Goodman (1999) actually deﬁnes the algorithm so that it\nattempts to compute an inﬁnite sum. He states that in appli-\ncations, this computation needs to be replaced by instructions\nspeciﬁc to the used semiring.\n47\nbe used as an alternative to Knuth’s algorithm;\ne.g., the single source shortest distance algorithm\nof Mohri (2002) if the weight algebra K is a com-\nplete semiring which is closed for G ′.\nIn this paper, we generalize the two-phase\npipeline approach of Goodman (1999) and Neder-\nhof (2003) as follows. We specify the LM by\nusing the general approach of initial algebra se-\nmantics ( Goguen et al. , 1977). For this, we em-\nploy weighted regular tree grammars (wRTG) and\nevaluate the generated trees (by the unique ho-\nmomorphism) in some language algebra L, which\nprovides the set of syntactic objects as carrier set.\nThis approach is very ﬂexible and covers LMs for\nstrings (CFG, LCFRS), but also trees and graphs\n(Drewes et al. , 2016). Our second generalization\nconcerns the weight algebra. We consider com-\nplete multioperator monoids ( Kuich, 1999) which\nare algebras of the form ( K,⊕,0,Ω, ∑⊕), where\nΩ is a set of operations on K and ∑⊕ is the in-\nﬁnitary sum operation which extends ⊕. We call\nthe combination of such an LM and weight alge-\nbra weighted RTG-based language model (wRTG-\nLM). These combinations are very general and\neven exceed the scope of parsing; e.g., each alge-\nbraic dynamic programming problem ( Giegerich\net al. , 2004), like minimum edit distance or ma-\ntrix chain multiplication, can be formalized within\nthis framework.\nFor solving the weighted parsing problem,\ngiven a wRTG-LM and a syntactic object a, we\nformalize the ﬁrst phase as canonical weighted\ndeduction system , which uses a CYK-like deduc-\ntion system. For the second phase ( value com-\nputation algorithm ), we propose a generalization\nof Mohri’s approach to hypergraphs, in the spirit\nof Knuth’s generalization of Dijkstra’s algorithm.\nWe prove (in sketches) that our weighted parsing\nalgorithm is terminating and solves the weighted\nparsing problem for every closed wRTG-LM with\na ﬁnitely decomposing language algebra. This\ncovers the approaches of Goodman (1999) and\nNederhof (2003); our value computation algo-\nrithm subsumes the algorithms of Knuth (1977)\nand Mohri (2002). Due to space restrictions, we\ncannot show our detailed proofs of the theorems\nin this paper.\n2 Preliminaries\nMathematical notions. We let N = {0,1,2,... }\nbe the set of natural numbers and [ m] = {1,..., m}\nfor each m ∈N. An alphabet is a ﬁnite, nonempty\nset. The powerset of a set A is denoted by P(A).\nLet f : A → B be a mapping; we extend it to\nthe mapping f ′: P(A) →P(B) by letting f (U) =\n{f (a) |a ∈U}, and we denote f ′ also by f . A\nfamily over A is a mapping f : I →A, where I is\na countable set (index set). As usual, we represent\neach family f over A by ( f (i) |i ∈I) and abbrevi-\nate f (i) by fi.\nRanked sets, trees, and regular tree grammars.\nA ranked set is a set Γ such that each γ ∈ Γ is\nassociated with a natural number rk Γ(γ), its rank.\nThe set of all elements of Γ with rank m ∈N is\ndenoted by Γm. A ranked set Σwith Σ ⊆Γis rank\npreserving (in Γ) if Σm ⊆Γm for each m ∈N. Let\nH be a set. The set of trees over Γand H is deﬁned\nin the usual way, where elements of H may only\noccur at leaves. We denote this set by T Γ(H) and\nabbreviate T Γ(∅) by T Γ. Let t ∈TΓ(H). A path\nin t is a sequence of positions of d from the root to\na leaf. Let p be a path in t. The sequence of labels\nof d along p is denoted by seq( d,p). A ranked\nalphabet is a ranked set which is an alphabet.\nA regular tree grammar (RTG) ( Brainerd,\n1969) is a tuple G = (N,Σ, A0,R) where N is an\nalphabet (nonterminals), Σ is a ranked alphabet\n(terminals) with N ∩Σ = ∅, A0 ∈N (initial non-\nterminal), and R is ﬁnite set of rules where each\nrule has the form A →σ(A1,..., Am) with m ∈N,\nA,A1,..., Am ∈N, and σ ∈Σm. Each RTG G can\nbe considered as a context-free grammar G′(with\nterminal alphabet Σ ∪{(,),comma}), which gen-\nerates well-formed expressions. Thus the deriva-\ntion relation ⇒G is the usual derivation relation of\nG′. The tree language generated by G is the set\nL(G) = {t ∈TΣ |A0 ⇒∗\nG t}.\nBy viewing each rule A → σ(A1,..., Am) of\nR as symbol with rank m, we can deﬁne the set\nAST(G) of abstract syntax trees of G to be the set\nof all d ∈TR such that for each position wof d the\nfollowing holds: if d has label A →σ(A1,..., Am)\nat w, then the i-th successor of w (i ∈[m]) is la-\nbeled by a rule with left-hand side Ai (cf. Fig. 2).\nWe deﬁne the mapping πΣ: AST(G) → TΣ such\nthat πΣ(d) is obtained from d by replacing each la-\nbel A →σ(A1,..., Am) by σ(cf. Fig. 2). Hence\nπΣ(AST(G)) = L(G).\nΓ-algebras. Let Γbe a ranked set. A Γ-algebra\n(or: algebra) is a pair ( A,φ) where Ais a set ( car-\nrier set ) and φ is a mapping ( interpretation map-\n48\nping) which maps each γ ∈Γm (m ∈N) to an m-\nary operation φ(γ) over A, i.e., φ(γ): Am →A. In\nthe sequel, we will sometimes identify φ(γ) and γ\n(as it is usual in algebra).\nThe Γ-term algebra is the Γ-algebra (T Γ,φΓ)\nwhere φΓ(γ)(t1,..., tm) = γ(t1,..., tm) for every\nm ∈ N, γ ∈ Γm, and t1,..., tm ∈ TΓ. For each\nΓ-algebra ( A,φ) there is exactly one homomor-\nphism, denoted by ( .)A, from the Γ-term algebra\nto ( A,φ) ( Wechler, 1992). We write its applica-\ntion to an argument t ∈TΓ as tA. Intuitively, ( .)A\nevaluates a tree t in ( A,φ), in the same way as\narithmetic expressions (e.g., 3 + 2 ·(4 + 5)) are\nevaluated in the {+,·}-algebra (Z,+,·) to some val-\nues (here: 21). Often we abbreviate an algebra\n(A,φ) by its carrier set A. For every a ∈A we\nlet factors( a) = {b ∈ A |b <factor∗a}, where for\nevery a,b ∈ A, b <factor a if there is a γ ∈ Γ\nsuch that b occurs in some tuple ( b1,..., bm) with\nφ(γ)(b1,..., bm) = a. We call ( A,φ) ﬁnitely de-\ncomposable if factors(a) is ﬁnite for every a ∈A.\nMonoids. A monoid is an algebra ( K,⊕,0) such\nthat ⊕is a binary, associative operation on K and\n0 ⊕k = k = k ⊕0 for each k ∈K. In the rest of\nthis paper, each occurrence of k,k1,k2,... is as-\nsumed to be universally quantiﬁed over K if not\nspeciﬁed otherwise. The monoid is commutative\nif ⊕is commutative; it is extremal (Mahr, 1984) if\nk1⊕k2 ∈{k1,k2}; it is idempotent if k⊕k = k. It is\nnaturally ordered if the binary relation ⪯⊆K ×K\n(deﬁned by k1 ⪯k2 if there is a k ∈K such that\nk1⊕k = k2) is anti-symmetric (in which case it is a\npartial order, since reﬂexivity and transitivity hold\nby deﬁnition). It is complete if for each count-\nable set I, there is an operation ∑⊕\nI which maps\neach family ( ki |i ∈ I) to an element of K, co-\nincides with ⊕when I is ﬁnite, and otherwise sat-\nisﬁes axioms which guarantee commutativity and\nassociativity (Eilenberg, 1974, p. 124). We abbre-\nviate ∑⊕\nI (ki |i ∈I) by ∑⊕\ni∈I ki. A complete monoid\nis d-complete (Karner, 1992) if for every k ∈K\nand family ( ki |i ∈N) of elements of K the fol-\nlowing holds: if there is an n0 ∈N such that for\nevery n ∈N with n ≥n0, ∑⊕\ni∈N:i≤n ki = k, then∑⊕\ni∈N ki = k. A complete monoid is completely\nidempotent if for every k ∈K and countable set I\nit holds that ∑⊕\ni∈I k = k.\nBy easy calculations we obtain the following\nimplications: (1) if K is extremal, then it is idem-\npotent, (2) if K is completely idempotent, then it\nis d-complete, and (3) if K is d-complete, then it\nis naturally ordered.\nMultioperator monoids. A multioperator\nmonoid (M-monoid) ( Kuich, 1999) is an algebra\n(K,⊕,0,Ω) such that ( K,⊕,0) is a commutative\nmonoid and Ω is a set of operations on K which\ncontains at least the unary identity id: K → K.\nWe view Ωas a ranked set, and hence ( K,φ) as an\nΩ-algebra where φ(ω) = ωfor each ω ∈Ω. Thus\ntK ∈K is the evaluation of t ∈TΩ in the algebra\n(K,φ). An M-monoid inherits the properties of\nits monoid (e.g., being complete). We denote a\ncomplete M-monoid by ( K,⊕,0,Ω, ∑⊕).\nAn M-monoid is distributive if for each m-ary\nω∈Ωand every i ∈[m],\nω(k1,i−1,ki ⊕k,ki+1,m)\n= ω(k1,i−1,ki,ki+1,m) ⊕ω(k1,i−1,k,ki+1,m)\nwhere k1,i−1 and ki+1,m abbreviate k1,..., ki−1 and\nki+1,..., km, respectively. If K is complete, then\nwe additionally require that the above equation\nalso holds for each countable set of summands.\nNext we show examples of M-monoids.\n•Each semiring ( K,⊕,⊗,0,1) can be considered\nas the M-monoid ( K,⊕,0,Ω⊗) ( Fülöp et al. ,\n2009) where Ω⊗ = {mul(m)\nk | m ∈ N,k ∈ K}\nand for every m ∈N we deﬁne\nmul(m)\nk (k1,..., km) = k ⊗k1 ⊗···⊗ km .\nNote that 1 = mul(0)\n1 ().\n•Knuth (1977) uses complete, distributive M-\nmonoids of the form ( K,min,0,Ω, ∑min) where\nK is a totally ordered set, inf( K) ∈ K, and\nthe operations in Ω are superior functions. We\nwill call such M-monoids superior M-monoids .\nWe note that each superior M-monoid is d-\ncomplete.\n3 Weighted RTG-based language models\nand the weighted parsing problem\nAs framework for the deﬁnition of our lan-\nguage models we use the initial algebra approach\n(Goguen et al. , 1977). An RTG-based language\nmodel (RTG-LM) is a tuple ( G,(L,φ)) where\n•G = (N,Σ, A0,R) is an RTG and\n•(L,φ) is a Γ-algebra ( language algebra ) such\nthat Σ ⊆Γis rank preserving; the elements of L\nare called syntactic objects.\nThe language generated by (G,(L,φ)) is the set\nL(G)L= {tL|t ∈L(G)}⊆L ,\ni.e., the set of all syntactic objects which result\n49\nr1: S\n1.0\n−→⟨x1 x2⟩(NP,VP) r8: NN\n1.0\n−→⟨fruit⟩\nr2: NP\n0.2\n−→⟨x1⟩(NN) r9: NNS\n0.4\n−→⟨ﬂies⟩\nr3: NP\n0.5\n−→⟨x1 x2⟩(NN,NNS) r10: NNS\n0.6\n−→⟨bananas⟩\nr4: NP\n0.3\n−→⟨x1⟩(NNS) r11: VBZ\n1.0\n−→⟨ﬂies⟩\nr5: VP\n0.4\n−→⟨x1 x2⟩(VBZ,PP) r12: VBP\n1.0\n−→⟨like⟩\nr6: VP\n0.6\n−→⟨x1 x2⟩(VBP,NP) r13: IN\n1.0\n−→⟨like⟩\nr7: PP\n1.0\n−→⟨x1 x2⟩(IN,NP)\nFigure 1: Rules of RTG of Ex. 1.\nfrom evaluating trees of L(G) in the language al-\ngebra L. For each a ∈L, we let\nAST(G,a) = {d ∈AST(G) |πΣ(d)L= a} .\nExample 1. We consider the Γ-algebra\nCFG∆ = (∆∗,φ) as language algebra where\n∆ = {fruit,ﬂies,like,bananas}, Γ = ⋃\nm∈N Γm, and\nΓm = {⟨u0 x1u1 ··· xmum⟩| ui ∈∆∗}. We deﬁne\nφ(⟨u0 x1u1 ··· xmum⟩)(a1,..., am)\n= u0a1u1 ··· amum\nfor every a1,..., am ∈∆∗.\nWe consider the RTG G = (N,Σ, S,R) with\nN = {S,NP,VP,PP,NN,NNS,VBZ,VBP,IN}\nand Σ = {⟨δ⟩| δ ∈∆}∪{⟨ x1⟩,⟨x1 x2⟩}⊆ Γ, and\nR contains the rules shown in Fig. 1 (ignoring the\nnumbers above the arrows for the time being).\nThe tree in the middle of the upper row of\nFig. 2 is an abstract syntax tree d ∈ AST(G).\nIt expresses that certain insects ( fruit ﬂies ) like\nsomething ( bananas). We obtain πΣ(d) by drop-\nping the non-highlighted parts of d (left of up-\nper row). The application of the homomorphism\n(.)CFG∆: TΣ → CFG∆ to πΣ(d) yields the string\na = fruit ﬂies like bananas . We note that there\nis another abstract syntax tree d′ ∈AST(G), viz.,\nd′ = r1(r2(r8),r5(r11,r7(r13,r4(r10)))) such that\nπΣ(d′)CFG∆ = a. It expresses how fruit performs\na certain activity (to ﬂy like bananas). Hence this\nRTG-LM is ambiguous. □\nIt should be clear from Ex. 1 that each context-\nfree grammar with terminal alphabet ∆ can be\nrepresented as an RTG-LM ( G,CFG∆), and vice\nversa, each RTG-LM ( G,CFG∆) represents a\nCFG. In the same way, one can characterize\nLCFRS and tree adjoining grammars by (1) super-\nposing sorts to the set N of nonterminals of the\nRTG (in order to represent fanout and the char-\nacteristic “substitution tree / adjoining tree” of ar-\nguments, respectively), and (2) by deﬁning ap-\npropriate Γ-algebras LCFRS∆ (Kallmeyer, 2010,\nDef. 6.2 +6.3) and TAG∆ (Büchse et al. , 2012;\nKoller and Kuhlmann , 2012), respectively. The\nlanguage algebras CFG∆, LCFRS∆, and TAG∆\nare ﬁnitely decomposable.\nA weighted RTG-based language model\n(wRTG-LM) is a tuple\n( (G,(L,φ)), (K,⊕,0,Ω, ∑⊕), wt ) ,\nwhere\n•(G,(L,φ)) is an RTG-LM,\n•(K,⊕,0,Ω, ∑⊕) is a complete M-monoid\n(weight algebra), and\n•wt maps each rule of G with rank m to an m-\nary operation in Ω. We lift wt to the mapping\nwt′: TR →TΩ and denote wt ′also by wt.\nDeﬁnition 2. The weighted parsing problem\nis the following problem: given a wRTG-LM((G,(L,φ)),(K,⊕,0,Ω, ∑⊕),wt ) and an a ∈ L,\ncompute the value parse( a) ∈K where\nparse(a) = ∑⊕\nd∈AST(G,a)\nwt(d)K . □\nExample 3. (Ex. 1 cont.) The best derivation\nproblem of ( Goodman, 1999) consists of comput-\ning, given a syntactic object a and a grammar, the\nabstract syntax trees of a with maximal probabil-\nity (and this probability). Let R∞ be a ranked set\nsuch that ( R∞)m is inﬁnite for each m ∈N. In anal-\nogy to Goodman, we deﬁne the best derivation M-\nmonoid to be the d-complete M-monoid\nBD = (V, maxBD, (0,∅), ΩBD, ∑maxBD ),\nwhere V = [0,1] ×P(TR∞) and [0 ,1] is the inter-\nval of real numbers from 0 to 1 and\n•for every ( p1,D1),(p2,D2) ∈ V, the value\nmaxBD((p1,D1),(p2,D2)) is ( pi,Di) if pi > pj\nfor i, j ∈{1,2}, and ( p1,D1 ∪D2) if p1 = p2,\n•ΩBD = {tcp,r | p ∈ [0,1] and r ∈ R∞},\nwhere for each p ∈ [0,1] and r ∈ R∞ of\nrank m, we deﬁne tc p,r: Vm → V (tc abbre-\nviates top concatenation) such that for every\n(p1,D1),..., (pm,Dm) ∈V\ntcp,r\n((p1,D1),..., (pm,Dm)) = (p′,D′)\nwhere p′ = p · p1 ·... · pm and D′ =\n{r(d1,..., dm) |di ∈Di,1 ≤i ≤m}, and\n•for every family (( pi,Di) | i ∈ I) over V, we\ndeﬁne ∑maxBD\ni∈I (pi,Di) = (p,D), where p =\nsup{pi |i ∈I}and D = ⋃\ni∈I:pi=p Di.\nSince BD is completely idempotent, it is also d-\ncomplete.\n50\n⟨x1x2⟩\n⟨x1x2⟩\n⟨fruit⟩ ⟨ﬂies⟩\n⟨x1x2⟩\n⟨like⟩ ⟨x1⟩\n⟨bananas⟩\nS→\nNP→\nNN→ NNS→\nVP→\nVBP→ NP→\nNNS→\n(NP,VP)\n(NN,NNS) (VBP,NP)\n(NNS)\nd ∈AST(G)\n⟨x1x2⟩\n⟨x1x2⟩\n⟨fruit⟩ ⟨ﬂies⟩\n⟨x1x2⟩\n⟨like⟩ ⟨x1⟩\n⟨bananas⟩\nt ∈TΣ\ntc1.0,r1\ntc0.5,r3\ntc1.0,r8 tc0.4,r9\ntc0.6,r6\ntc1.0,r12 tc0.3,r4\ntc0.6,r10\nin TΩ\n(0.0216,{r1(r3(r8,r9),r6(r12,r4(r10)))})\n(0.0144,{r1(r2(r8),r5(r11,r7(r13,r4(r10))))})\nmaxBDa = fruit ﬂies like bananas\nwt(d′) ∈TΩd′∈AST(G)πΣ(d′) ∈TΣ\nπΣ wt\n(.)CFG∆\n(.)BD\n(.)BD\nwtπΣ\n(.)CFG∆\nparse\nFigure 2: Illustration of the weighted parsing problem for the wRTG-LM ((G,CFG∆),BD,wt ) and the syntactic\nobject a = fruit ﬂies like bananas of ∆∗, see Ex. 3.\nNow we consider the ﬁnite set R of rules\nof the RTG G given in Ex. 1. We can as-\nsume that R ⊆ R∞ is rank preserving. We de-\nﬁne the mapping wt: R → ΩBD by wt( ri) =\ntcpi,ri where pi is shown in Fig. 1 above the ar-\nrow of ri. For each d ∈ AST(G,a), the sec-\nond component of wt( d)BD has exactly one el-\nement. Recall d′ from Ex. 1, a second AST\nwhich is evaluated to a. We obtain wt( d′)BD =\n(0.0144,{r1(r2(r8),r5(r11,r7(r13,r4(r10))))}). Thus\nmaxBD\n(wt(d)BD,wt(d′)BD\n) = wt(d)BD .\nAs one might expect, it is more likely that a refers\nto the preferences (to like bananas ) of certain in-\nsects ( fruit ﬂies ). Fig. 2 illustrates the parsing\nproblem for the wRTG-LM (( G,CFG∆),BD,wt)\nand a = fruit ﬂies like bananas . □\nIn summary, each wRTG-LM consists of two\ncomponents: a syntax component and a weight\ncomponent. The syntax component (cf. the left of\nFig. 2) contains the language algebra ( L,φ). This\nis a Γ-algebra whose carrier set is the set of syn-\ntactic objects. The mapping πΣ maps each abstract\nsyntax tree to a tree in the Σ-term algebra T Σ,\nwhich is then evaluated to a syntactic object by the\nunique homomorphism ( .)L(recall that Σ ⊆Γ).\nThe weight component (cf. the right of Fig. 2)\ncontains a complete M-monoid ( K,⊕,0,Ω, ∑⊕)\nwhose carrier set is the set of weights. The map-\nping wt maps each abstract syntax tree to a tree in\nthe Ω-term algebra T Ω, which is then evaluated to\na weight in K by the unique homomorphism ( .)K.\nWeights in K are accumulated using ⊕.\nA →dela(A) φ(dela)(w) = aw dela(n) = n + 1\nA →insa(A) φ(insa)(w) = wa insa(n) = n + 1\nA →repa,b(A) φ(repa,b)(w) = awb repa,b(n) = n′\nA →nil φ(nil)() = $ nil() = 0\nFigure 3: Rules of G for each a,b ∈∆, the interpre-\ntation φ, and the operations in Ω where n′ = n + 1 if\na , b, and n otherwise.\nThe weighted parsing problem takes as input a\nwRTG-LM and a syntactic object a, and it com-\nputes the ⊕-accumulation of the weights of each\nAST of a.\nExample 4. Giegerich et al. (2004) formalized dy-\nnamic programming ( Bellman, 1952, 1954) in an\nalgebraic setting, called algebraic dynamic pro-\ngramming (ADP). We claim that each ADP prob-\nlem is a weighted parsing problem. To support\nthis statement, we consider the computation of\nthe minimum edit distance (med) between two\nwords over some alphabet ∆ by deletion, inser-\ntion, and replacement, and we “simulate” its ADP-\nspeciﬁcation as wRTG-LM (( G,(L,φ)),K,wt).\nThe rules of the RTG G and the interpretation\nφ are shown in the ﬁrst and second columns of\nFig. 3, respectively. Thus, for each tree t ∈L(G),\ntL = u$v for some u,v ∈ ∆∗. We choose the\ncomplete, distributive M-monoid ( K,⊕,∅,Ω, ∑⊕)\nwith K = {h(F) | F ∈ P(N)}for the single-\nvalued objective function h: P(N) → P(N) with\nh(F) = {min(F)}. We let F1 ⊕F2 = h(F1 ∪F2) for\nevery F1,F2 ∈K, and ∑⊕\ni∈N Fi = {inf(⋃\ni∈N Fi)}.\nThe set Ωis shown in the third column of Fig. 3.\n51\n- wRTG-LM((G,L),K,wt )\n- a ∈L\ncanonical weighted\ndeduction system\nwRTG-LM((G′,CFG∅),K,wt′) value computation\nalgorithm (Alg. 1)\nV(A′\n0) =∑⊕\nd∈AST(G′)\nwt′(d)K parse(a)=\nweighted parsing algorithm\nFigure 4: Two-phase pipeline for solving the weighted parsing problem ( A′\n0 is the initial nonterminal of G′).\nNote that h satisﬁes Bellman’s principle of op-\ntimality: h(ω(F)) = h(ω(h(F))) for each unary\nω∈Ωand F ∈K. Then med( u,v) = parse(u$v−1)\nfor every u,v ∈∆∗, where v−1 is the reversal of v.\nThis construction can be generalized to a pro-\ncedure which turns every speciﬁcation of an ADP\nproblem into a weighted parsing problem. Due to\nspace restrictions, we cannot present this proce-\ndure in its entirety. □\n4 The weighted parsing algorithm\nThe weighted parsing algorithm is supposed to\nsolve the weighted parsing problem. As input, it\ntakes a wRTG-LM Gand a syntactic object a. Its\noutput is intended to be parse( a). The algorithm is\na pipeline with two phases (cf. Fig. 4) and follows\nthe modular approach of Nederhof (2003). First,\na canonical weighted deduction system computes\nfrom Gand a a new wRTG-LM G′with the same\nweight structure as G, but a di ﬀerent RTG and the\nlanguage algebra CFG∅. Second, G′is the input to\nthe value computation algorithm (Alg. 1), which\ncomputes the value V(A′\n0); this is supposed to be∑⊕\nd∈AST(G′) wt(d)K = parse(a).\nWeighted deduction systems. Parsing of some\nstring wwith some grammar G can be formalized\nas a deduction system D(Shieber et al. , 1995).\nDconsists of a set of inference rules\nI1 ... Im\nI {c1,..., cp}\nwhere m ∈N, I,I1,..., Im are items, and c1,..., cp\nare side conditions. Each item represents a\nBoolean-valued property (of some combination of\nnonterminals of G and/or substrings of a = w).\nThe meaning of an inference rule is: given that\nI1,..., Im and c1,..., cp are true, I is true as well.\nNederhof (2003) pointed out that “a deduction sys-\ntem having a grammar G [...] and input string win\nthe side conditions can be seen as a construction\nc of a context-free grammar c(G,w) [...]”; also, he\nextended Dand c(G,a) with weights.\nInspired by this, we deﬁne the canonical\nweighted deduction system as a mapping cwds\nwhich takes two arguments: (a) a wRTG-LM\nG= ((G,L),K,wt ) such that the language alge-\nbra ( L,φ) is ﬁnitely decomposable and (b) a syn-\ntactic object a ∈L. Let G = (N,Σ, A0,R). Then\nwe deﬁne\ncwds (G,a) = ((G′,CFG∅),K,wt′) ,\nwhere G′= (N′,Σ′,A′\n0,R′) and\n•N′= {(A0,a)}∪(N ×Σ×factors(a)); N′is ﬁnite,\nbecause Lis ﬁnitely decomposable,\n•Σ′= {⟨x1 ... xm⟩| a rule with rank m is in R},\n•A′\n0 = (A0,a), and\n•for each σ ∈ Σ, the rule r′ = (A0,a) →\n(A0,σ,a) is in R′and wt ′(r′) = id; for each r =(A →σ(A1,..., Am)) in R and a0,a1,..., am ∈\nfactors(a) with φ(σ)(a1,..., am) = a0 and every\nrule Ai →σi(... ) (i ∈[m]) in R, the rule r′\n(A,σ,a0) →⟨x1 ... xm⟩((A1,σ1,a1),..., (Am,σm,am))\nis in R′and we let wt ′(r′) = wt(r).\nNote that cwds implements a CYK-like deduction\nsystem. The elements of N′ have a very general\nform. Depending on L, they can be understood\nas, e.g., spans of strings, occurrences of patterns\nin trees, or occurrences of subgraphs in graphs.\nWe note that for every d ∈AST(G′) it holds that\nπΣ(d)CFG∅ = ε, i.e., each abstract syntax tree is\nevaluated to the empty string. Moreover, cwds is\nweight-preserving in the following sense:\n(1) there is a bijective mapping ψ from the set\nAST(G,a) to AST( G′) and\n(2) for every d ∈ AST(G,a) we have that\nwt(d)K = wt′(ψ(d))K.\nValue computation algorithm. This is Alg. 1.\nIts input is a wRTG-LM G′with language algebra\nCFG∅. It maintains a mapping V, which assigns\na weight to each nonterminal, and a Boolean vari-\nable changed. The output is the value V(A′\n0). The\nalgorithm starts by assigning the weight 0 to each\nnonterminal (lines 1–2). Then, in a repeat-until\nloop (lines 3–12), the weight of each nonterminal\nis recomputed in every iteration of that loop as fol-\nlows (where ⟨x1,m⟩abbreviates ⟨x1,..., xm⟩):\nV(A) =\n⨁\nr∈R′:\nr=(A→⟨x1,m⟩(A1,...,Am))\nwt′(r)(V(A1),..., V(Am)) .\n52\nAlgorithm 1 Value computation algorithm\nInput: ((G′,CFG∅), (K,⊕,0,Ω, ∑⊕), wt′) which\nis a wRTG-LM with G′= (N′,Σ′,A′\n0,R′)\nVariables: V: N′→K, V′∈K, changed ∈B\nOutput: V(A′\n0)\n1: for each A ∈N′do\n2: V(A) ←0\n3: repeat\n4: changed ←false\n5: for each A ∈N′do\n6: V′←0\n7: for each r = (A →⟨x1,m⟩(A1,..., Am)) in R′ do\n8: V′←V′⊕wt′(r)(V(A1),..., V(Am))\n9: if V(A) , V′then\n10: changed ←true\n11: V(A) ←V′\n12: until changed = false\nThe algorithm terminates after the ﬁrst iteration in\nwhich no nonterminal has changed its weight.\nWe note that in practice, a complete compu-\ntation of cwds( G,a) prior to the execution of the\nvalue computation algorithm (Alg. 1) is impossi-\nble. Similar to Nederhof (2003), we execute the\nvalue computation algorithm on an incomplete in-\nput which is extended on demand (lazy evalua-\ntion). More precisely, G′ is initialized so that it\nonly contains the rules of rank 0 (and the nonter-\nminals in their left-hand sides). Then, each time a\nvalue diﬀerent from 0 is ﬁrst assigned to a nonter-\nminal A in line 11, we compute the following set\nof rules: each rule whose right-hand side only con-\ntains A and other nonterminals for which this com-\nputation has already been done is in that set. These\nnew rules (and the nonterminals in their left-hand\nsides) are added to G′.\n5 Termination and correctness\nWe are interested in two formal properties of the\nvalue computation algorithm (Alg. 1) and of the\nweighted parsing algorithm (Fig. 4): termination\nand correctness.\nThe value computation algorithm computes the\nweights of the ASTs bottom-up and reuses the re-\nsults of common subtrees (as in dynamic program-\nming); this requires distributivity of the weight\nalgebra. Moreover, solving the weighted parsing\nproblem by a terminating algorithm involves the\nfollowing di ﬃculty: there may be inﬁnitely many\nASTs (due to cycles) which are evaluated to the\nsame syntactic object a. Thus parse( a) is an in-\nﬁnite sum, which in general cannot be computed\nin ﬁnite time. Hence, a terminating algorithm can\nonly solve the weighted parsing problem if the in-\nﬁnite sum is equal to the sum over some ﬁnite sub-\nset of the inﬁnite sum’s index set.\nWe have organized this section as follows.\nIn Subsection 5.1 we deﬁne the class of closed\nwRTG-LMs (similar to Mohri, 2002) and prove\nthat the value computation algorithm (Alg. 1) is\nterminating and correct for closed wRTG-LMs as\ninput. We say that the value computation algo-\nrithm is correct if after termination\nV(A′\n0) = ∑⊕\nd∈AST(G′)\nwt′(d)K .\nIn Subsection 5.2 we prove that the weighted\nparsing algorithm (Fig. 4) is terminating and cor-\nrect for two classes of inputs. We say that the\nweighted parsing algorithm is correct if it com-\nputes parse(a).\n5.1 Properties of the value computation\nalgorithm\nSince each wRTG-LM has a ﬁnite set of rules, an\ninﬁnite set of ASTs is only possible if the ASTs\nare cyclic in the following sense. Recall that R′is\nthe set of rules of the input G′to the value compu-\ntation algorithm (Alg. 1). Let ρ∈(R′)∗. We call ρ\ncyclic if |ρ|≥ 2, ρ1 = ρ|ρ|, and for every i, j ∈N,\nif 1 ≤i < j < |ρ|, then ρi , ρj. From now on,\nlet ρ ∈(R′)∗ be cyclic, d ∈TR′, and c ∈N. A\npath p in d is ( c,ρ)-cyclic if ρ occurs exactly c\ntimes in seq( d,p). We deﬁne the set cutout( d,ρ)\nwhich contains every tree obtained from d by cut-\nting out at least one occurrence of ρ. We illustrate\ncutout by an example in Fig. 5.\nDeﬁnition 5. Let c ∈ N. A wRTG-LM G′ =((G′,CFG∅),K,wt′) is c-closed if K is distribu-\ntive and d-complete, and for each d ∈ TR′ and\ncyclic string ρ∈(R′)∗the following holds: if there\nis a ( c,ρ)-cyclic path in d, then\nwt′(d)K ⊕\n⨁\nd′∈cutout(d,ρ)\nwt′(d′)K =\n⨁\nd′∈cutout(d,ρ)\nwt′(d′)K .\nG′is closed if it is c-closed for some c ∈N. □\nFor every c ∈ N and ranked set R′, we let\nT(c)\nR′ be the set of all those d ∈ TR′ such that\nfor every cyclic ρ ∈ (R′)∗ and c′ > c, no path\nin d is ( ρ,c′)-cyclic. In other words, T (c)\nR′ con-\ntains all those trees of T R′ which have at most c\noccurrences of some cycle in some of their paths.\nClearly T (c)\nR′ is ﬁnite, T (c)\nR′ ⊆T(c+1)\nR′ for every c ∈N,\n53\nr3 r1\nr4\nr2 r1\nr2 r4\nr3 r1\nr2 r4\nr2 r1\nr4\nr4\nr3 r1\nr2 r4\nr3 r1\nr2 r4\nr2 r1\nr4\nr4r3 r1\nr4\nr2 r1\nr2 r4\nr3 r1\nr4\nr4 r3 r1\nr2 r4\nr3 r1\nr4\nr4\nFigure 5: Top: tree d over the ranked set R′ = {r(2)\n1 ,r(1)\n2 ,r(1)\n3 ,r(0)\n4 }with a (2 ,ρ)-cyclic path (horizontal line) for\nρ= r1r2r1. Bottom: the set cutout( d,ρ). Please do not confuse the elements of R′with the rules of Ex. 1 and 3.\nand ⋃\nc∈N T(c)\nR′ = TR′. Given a wRTG-LM G′ =((G′,CFG∅),K,wt′) with set of rules R′, we let\nAST(G′)(c) = T(c)\nR′ ∩AST(G′) for every c ∈N.\nTheorem 6. For every c ∈N and c-closed wRTG-\nLM ((G′,CFG∅),K,wt′) the following holds:\n∑⊕\nd∈AST(G′)\nwt′(d)K =\n⨁\nd∈AST(G′)(c)\nwt′(d)K .\nProof (sketch). As K is distributive, we can show\nby induction on n ∈ N that for every B ⊆\nAST(G′) ∖ AST(G′)(c) with |B|= n, adding B to\nthe index set of ⊕does not change the sum’s value.\nThen, as K is d-complete, the equality holds. ■\nThis theorem reﬂects the desired property:\ngiven that our wRTG-LM is c-closed (with c ∈N),\neach (possibly inﬁnite) sum over all ASTs can be\ncomputed as a sum over the ﬁnite set AST( G′)(c).\nTheorem 7. The value computation algorithm\n(Alg. 1) is terminating and correct for every closed\nwRTG-LM G′with language algebra CFG∅.\nProof (sketch). Let G′ be c-closed. We note that\nin line 8, the value in the right-hand side of ⊕al-\nways corresponds to the sum over the weights of\nsome trees in (T R′)A; this is due to the fact that K\nis distributive. By the form of recomputation in\nlines 3–12, each d ∈ (TR′)A contributes to that\nsum at most once. Furthermore, V′ only di ﬀers\nfrom V(A) if a tree from the ﬁnite set T (c)\nR′ has been\nused to compute V′, but not V(A) (this is a con-\nsequence of G′ being closed). Thus, changed is\nonly set to true ﬁnitely often and the algorithm\neventually terminates. Then, after termination,\nV(A′\n0) =\n⨁\nd∈AST(G′)(c) wt′(d)K and Theorem 6 im-\nplies correctness. ■\n5.2 Properties of the weighted parsing\nalgorithm\nWe discuss two classes of wRTG-LMs for which\nthe weighted parsing algorithm (Fig. 4) is termi-\nnating and correct.\n(1) Closed wRTG-LMs with arbitrary language al-\ngebras. Each of them is a wRTG-LM ((G,(L,φ)),\n(K,⊕,0,Ω, ∑⊕), wt ) which is c-closed for some\nc ∈N, and c-closed is deﬁned as in Def. 5. (We\nnote that this generalization is possible because\nDef. 5 does not use any property of CFG∅.) The\nfollowing particular wRTG-LMs are closed:\n•wRTG-LMs with acyclic RTG, where an\nRTG G is acyclic if AST( G) = AST(G)(0),\n•wRTG-LMs with superior, d-complete M-\nmonoids as weight algebras, and\n•wRTG-LMs with weight algebra BD if no chain\nrule and ε-rule has probability 1 .0 (as in Ex. 3).\n(2) Non-looping wRTG-LMs with distributive M-\nmonoids as weight algebras. A wRTG-LM Gis\nnon-looping if for every syntactic object a and\ntree d over the set of rules of Gwhich is evaluated\nto a the following holds: no proper subtree of d\nis evaluated to a. ADP problems can be speciﬁed\nby non-looping wRTG-LMs, because the syntactic\nobjects of ADP represent (sub-)problems which\nhave to be solved. Thus, if Gis looping, then the\nsolution of a subproblem would depend on itself,\nwhich contradicts dynamic programming. In gen-\neral, non-looping is not decidable, but it is for par-\nticular language algebras, e.g., CFG∆.\nLemma 8. For every closed or nonlooping\nwRTG-LM G with ﬁnitely decomposable lan-\nguage algebra and syntactic object a, the wRTG-\nLM cwds(G,a) is closed.\nTheorem 9. The weighted parsing algorithm\n(Fig. 4) is terminating and correct for every closed\nor nonlooping wRTG-LM with ﬁnitely decompos-\nable language algebra.\nProof. The weighted parsing algorithm terminates\nbecause (a) the computation of cwds is terminating\n54\nalgorithm class of valid inputs class C1 of RTG class C2 of weight algebras\n(a) Knuth (1977) C1 ×C2 RTG superior M-monoid\n(b) Goodman (1999) C1 ×C2 acyclic RTG complete semiring\n(c) Mohri (2002) C2 closed for C1 monadic RTG commutative, d-complete semiring\n(d) Alg. 1 closed wRTG-LM RTG distributive, d-complete M-monoid\nTable 1: Comparison of four value computation algorithms. The second column represents the class of wRTG-LMs\nto which the corresponding algorithm is applicable. The expression C1 ×C2 denotes the class of all wRTG-LMs\nwith RTGs in C1 and weight algebras in C2.\nfor every wRTG-LM with ﬁnitely decomposable\nlanguage algebra and (b) the value computation\nalgorithm (Alg. 1) is terminating by Theorem 7,\nwhich we can be applied due to Lemma 8. The\nweighted parsing algorithm is correct because (a)\ncwds is weight-preserving and (b) the value com-\nputation algorithm is correct by Theorem 7 (which\nis applicable again due to Lemma 8), hence\nparse(a)\n(a)\n= ∑⊕\nd∈AST(G′)\nwt′(d)K\n(b)\n= V(A′\n0) . ■\n6 Comparison of value computation\nalgorithms\nHere we compare our value computation algo-\nrithm (Alg. 1) to the algorithm of Knuth (1977),\nthe second phase of Goodman (1999), and the al-\ngorithm of Mohri (2002).\nWe focus on the question of applicability of\nthe algorithms, i.e., we identify the classes of\ninputs for which the algorithms are terminat-\ning and correct ( class of valid inputs ). In\norder to have a basis for a fair comparison,\nwe understand the inputs of the algorithms of\nKnuth (1977), Goodman (1999), and Mohri\n(2002) as particular wRTG-LMs of the form((G′,CFG∅),(K,⊕,0,Ω, ∑⊕),wt′) with G′ =\n(N′,Σ′,A′\n0,R′). An algorithm is correct for such\na wRTG-LM if it returns ∑⊕\nd∈AST(G′) wt′(d)K.\nWe employ two parameters: C1 (subset of the\nclass of all RTGs) and C2 (subset of the class of\nall weight algebras). Tab. 1 shows the classes of\nvalid inputs parameterized with values for C1 and\nC2. Each valid input in rows (a)–(d) is a closed\nwRTG-LM. Thus, if one of the value computation\nalgorithms (a)–(c) is applicable, then our value\ncomputation algorithm (Alg. 1) is applicable too.\nIn particular, Alg. 1 is applicable to wRTG-LMs\nwith the best derivation M-monoid BD as weight\nalgebra (cf. Ex. 3), which in general is the case for\nneither of algorithms (a)–(c). The reason for this\nis that BD is not superior (opposing (a)) and RTG-\nLMs are in general neither acyclic (opposing (b))\nnor monadic (opposing (c)). The same holds for\nADP problems.\nWe cannot give a general statement about the\ncomplexity of our value computation algorithm\n(Alg. 1), because the operations in the weight al-\ngebra of a wRTG-LM can be undecidable. If we\nabstract from the costs of particular operations,\nthen we obtain the complexity of Mohri’s algo-\nrithm. This complexity depends on the number of\ntimes the value of a nonterminal changes, which\nin general is not polynomial in the size of the in-\nput wRTG-LM. Mohri circumvents this problem\nby specifying the order in which nonterminals are\nprocessed for well-known classes of inputs, e.g.,\nacyclic graphs or superior weight algebras. We\ncan adapt this idea by imposing such an ordering\non the iteration over the nonterminals in line 5.\nThus our value computation algorithm achieves\nthe same complexity as Knuth’s algorithm (if the\ninput is restricted to superior wRTG-LMs) or the\nalgorithm in Goodman’s second phase (if the input\nis restricted to acyclic wRTG-LMs), respectively.\nWe note that although our value computation\nalgorithm (Alg. 1) has the same complexity as\nthe other algorithms, in average it performs more\ncomputations than those. This is because in each\niteration of lines 5–11, the values of all nontermi-\nnals are recomputed. This could be avoided by\nusing a direct generalization of Mohri’s algorithm\nto the branching case rather than Alg. 1. However,\nthe intricacies of such a generalization would ex-\nceed the scope of this paper.\nAcknowledgements\nWe thank the anonymous reviewers for their help-\nful comments and our colleagues Kilian Gebhardt\nand Frederic Dörband for fruitful discussions.\nReferences\nY . Bar-Hillel, M. Perles, and E. Shamir. 1961. On\nformal properties of simple phrase structure gram-\n55\nmars. 14:143–172. Reprinted in Y . Bar-Hillel.\n(1964). Language and Information: Selected Essays\non their Theory and Application , Addison-Wesley\n1964, 116–150.\nR. Bellman. 1952. On the theory of dynamic program-\nming. Proceedings of the National Academy of Sci-\nences, 38(8):716–719.\nR. Bellman. 1954. The theory of dynamic program-\nming. Technical report, RAND Corp Santa Monica\nCA.\nW. S. Brainerd. 1969. Tree generating regular systems.\nM. Büchse, M.-J. Nederhof, and H. V ogler. 2012.\nTree parsing for tree-adjoining machine translation.\nJournal of Logic and Computation , 22(6).\nE. Dijkstra. 1959. A note on two problems in connex-\nion with graphs. Numer. Math., 1:269–271.\nF. Drewes, K. Gebhardt, and H. V ogler. 2016. EM-\ntraining for weighted aligned hypergraph bimor-\nphisms. In Proceedings of the SIGFSM Workshop\non Statistical NLP and Weighted Automata , pages\n60–69, Berlin, Germany. Association for Computa-\ntional Linguistics.\nS. Eilenberg. 1974. Automata, languages, and ma-\nchines. Academic press.\nZ. Fülöp, A. Maletti, and H. V ogler. 2009. A Kleene\ntheorem for weighted tree automata over distribu-\ntive multioperator monoids. Theory of Computing\nSystems, 44(3):455–499.\nR. Giegerich, C. Meyer, and P. Ste ﬀen. 2004. A disci-\npline of dynamic programming over sequence data.\nScience of Computer Programming , 51:215–263.\nJ. A. Goguen, J. W. Thatcher, E. G. Wagner, and J. B.\nWright. 1977. Initial algebra semantics and con-\ntinuous algebras. Journal of the ACM (JACM) ,\n24(1):68–95.\nJ. Goodman. 1999. Semiring parsing. Computational\nLinguistics, 25(4):573–605.\nL. Kallmeyer. 2010. Parsing beyond context-free\ngrammars. Springer.\nG. Karner. 1992. On limits in complete semirings .\nSemigroup Forum, 45(1):148–165.\nN. A. Khabbaz. 1974. Control sets on linear grammars.\nInformation and Control , 25(3):206–221.\nD. E. Knuth. 1977. A Generalization of Dijkstra’s Al-\ngorithm. Inform. Process. Lett. , 6(1):1–5.\nA. Koller and M. Kuhlmann. 2012. Decomposing TAG\nalgorithms using simple algebraizations . In Pro-\nceedings of the 11th TAG + Workshop, Paris.\nW. Kuich. 1999. Linear systems of equations and au-\ntomata on distributive multioperator monoids. Con-\ntributions to general algebra , 12:247–256.\nB. Mahr. 1984. Iteration and summability in semirings.\nAnnals of Discrete Mathematics , pages 229–256.\nM. Mohri. 2002. Semiring frameworks and al-\ngorithms for shortest-distance problems. Jour-\nnal of Automata, Languages and Combinatorics ,\n7(3):321–350.\nM.-J. Nederhof. 2003. Squibs and discussions:\nWeighted deductive parsing and Knuth’s algorithm.\nComputational Linguistics, 29(1):135–143.\nS. Shieber, Y . Schabes, and F. Pereira. 1995. Principles\nand implementation of deductive parsing. The Jour-\nnal of Logic Programming , 24(12):3–36.\nW. Wechler. 1992. Universal Algebra for Computer\nScientists, ﬁrst edition, volume 25 of Monogr. Theo-\nret. Comput. Sci. EATCS Ser. Springer-Verlag, Hei-\ndelberg/Berlin.",
  "topic": "Parsing",
  "concepts": [
    {
      "name": "Parsing",
      "score": 0.8252743482589722
    },
    {
      "name": "Computer science",
      "score": 0.809251070022583
    },
    {
      "name": "Programming language",
      "score": 0.6927944421768188
    },
    {
      "name": "Top-down parsing language",
      "score": 0.6891045570373535
    },
    {
      "name": "Top-down parsing",
      "score": 0.6687788963317871
    },
    {
      "name": "Natural language processing",
      "score": 0.6157755851745605
    },
    {
      "name": "Grammar",
      "score": 0.5832738280296326
    },
    {
      "name": "Artificial intelligence",
      "score": 0.5669689178466797
    },
    {
      "name": "Bottom-up parsing",
      "score": 0.5491762161254883
    },
    {
      "name": "Parser combinator",
      "score": 0.549014687538147
    },
    {
      "name": "Scope (computer science)",
      "score": 0.5397456884384155
    },
    {
      "name": "S-attributed grammar",
      "score": 0.522646427154541
    },
    {
      "name": "Parsing expression grammar",
      "score": 0.4259136915206909
    },
    {
      "name": "Context-free grammar",
      "score": 0.2195245325565338
    },
    {
      "name": "L-attributed grammar",
      "score": 0.18269309401512146
    },
    {
      "name": "Linguistics",
      "score": 0.14865577220916748
    },
    {
      "name": "Philosophy",
      "score": 0.0
    }
  ]
}