{
    "title": "Model Checking Support for the ASM High-Level Language",
    "url": "https://openalex.org/W1485237120",
    "year": 2000,
    "authors": [
        {
            "id": "https://openalex.org/A2106604000",
            "name": "Giuseppe Del Castillo",
            "affiliations": [
                "Paderborn University"
            ]
        },
        {
            "id": "https://openalex.org/A2101585800",
            "name": "Kirsten Winter",
            "affiliations": []
        },
        {
            "id": "https://openalex.org/A2106604000",
            "name": "Giuseppe Del Castillo",
            "affiliations": []
        },
        {
            "id": "https://openalex.org/A2101585800",
            "name": "Kirsten Winter",
            "affiliations": [
                "Health First"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W179373627",
        "https://openalex.org/W1542875369",
        "https://openalex.org/W1940174675",
        "https://openalex.org/W53653536",
        "https://openalex.org/W4234177455",
        "https://openalex.org/W1948999075",
        "https://openalex.org/W4300021588",
        "https://openalex.org/W1547648104",
        "https://openalex.org/W1567803624",
        "https://openalex.org/W6601227276",
        "https://openalex.org/W1969402593",
        "https://openalex.org/W2503450805",
        "https://openalex.org/W1503170978",
        "https://openalex.org/W30853153",
        "https://openalex.org/W2152056423",
        "https://openalex.org/W1562626995",
        "https://openalex.org/W4285719527"
    ],
    "abstract": null,
    "full_text": "Model Checking Support for the\nASM High-Level Language\nGiuseppeDelCastillo 1⋆ andKirstenWinter 2\n1 HeinzNixdorfInstitut,Universit¨ at-GHPaderborn\nF¨urstenallee11,D-33102Paderborn,Germany\ngiusp@uni-paderborn.de\n2 GMDFIRST\nKekul´estr.7,D-12489Berlin,Germany\nkirsten@first.gmd.de\nAbstract Gurevich’sAbstractStateMachines(ASM)constituteahigh-\nlevelspeciﬁcationlanguageforawiderangeofapplications.Theexisting\ntoolsupportforASM–currentlyincludingtype-checking,simulationand\ndebugging–should be extended to support computer-aided veriﬁcation,\ninparticularbymodelchecking.Inthispaperweintroduceaninterface\nfrom our existing tool environment to the model checker SMV, based\non a transformation which maps a large subset of ASMinto the SMV\nlanguage.Throughacasestudyweshowhowtheproposedapproachcan\neasethevalidationprocess.\n1 Introduction\nGurevich’sAbstractStateMachines(ASM)[ 7]constituteasimplebutpowerful\nmethod for specifying and modeling software and hardware systems. Existing\ncase studies include speciﬁcations of distributed protocols, architectures, em-\nbeddedsystems,programminglanguages,etc.(see[ 1]and[ 8]).\nThe advantage of ASMs is in the simple language and its intuitive under-\nstanding.Themethodisbasedongeneralmathematicswhichallowstonaturally\nmodel systems on a suitable level of abstraction. Traditionally, the veriﬁcation\ntask is done by means of hand-written mathematical proofs. Tool support for\ntheveriﬁcationprocessisobviouslyneededforabroaderacceptance.\nOurcontributiontothistaskisthedevelopmentofaninterfacebetweenthe\nASM Workbench [2] and the SMV model checker [11]. The ASM Workbench\nis a toolenvironment,basedon a typed versionof ASM, which includes a type\ncheckerandasimulatorforASMs.SMVhasbeenchosenasatypicalrepresenta-\ntiveofaclassofmodelcheckersbasedontransitionsystemsandcouldbeeasily\nreplacedbyanyothersimilarmodelchecker,e.g.,SVE[ 5]orVIS[ 6].\nOntheotherhandourtransformationtoolsuppliesSMVwithahigherlevel\nmodeling language, namely ASMs. This facilitates the speciﬁcation task by al-\nlowingtheuseofmorecomplexdatatypesandof n-ary dynamic functionsfor\n⋆ PartiallysupportedbytheDFGSchwerpunktprogramm“Softwarespeziﬁkation”.\nS. Graf and M. Schwartzbach (Eds.): TACAS/ETAPS 2000, LNCS 1785, pp. 331–346, 2000.\nc⃝ Springer-Verlag Berlin Heidelberg 2000\n332 GiuseppeDelCastilloandKirstenWinter\nparameterization(apeculiarfeatureoftheASMlanguage,whichgeneralizesthe\nclassicalnotionofstatevariables).\nSince model checking is only applicable to ﬁnite-state systems, we have to\nput restrictionson the ASM model to be checkedin order to make it ﬁnite: all\nfunctionrangeshavetoberestrictedtoaﬁxedﬁnitesetofvalues.Tocopewith\na broadersubsetofthe ASMlanguage,weextendthebasicworkof[ 14],which\nintroduced a simple transformation schema, to support the transformation of\nn-ary dynamic functions forn> 0.To easethetransitionfrominﬁniteorlarge\nmodelstoﬁniteandfeasibleones,weintroducealanguagefeatureforadjusting\nthe function ranges in the declaration part of the system speciﬁcation. Thus,\nsuchchangescanbedonelocallyandarenotspreadoverthewholemodel.\nFromamethodicalpointofview,modelcheckingcan support the early design\nphase: checking properties of the system behavior may yield counterexamples\nwhich helpto “debug”the system speciﬁcation.Thesimulator providedby the\nASM Workbench can be fed with the counterexamples in order to illustrate\nthe erroneousbehavior.After locating and correctingthe errorthat causes the\ncounterexample, the transformation and model checking should be repeated.\nThis debugging process gives a deeper insight into the model at hand. Errors\nbecome visible that can be easily over seen when carrying out mathematical\nproofswhicharenotmechanicallychecked,borderlinecasesbecomevisiblethat\naremostlynotfoundwhensimulatingisolatedtestcases.\nWearenotclaimingthatmodelcheckingcanreplace,ingeneral,mathemati-\ncalproofs(developedwithorwithoutthehelpoftheoremprovers),astherange\nof applicability of model checking techniques is restricted to the veriﬁcation of\nﬁniteinstancesoftheproblemathandandisinmostcasesinsuﬃcienttoprove\ncorrectnessofasystemorprotocolingeneral.However,wearguethatusingtool\nsupportinthewaywesuggesthelpstoﬁnd errorswithsmalladditionaleﬀort.\nThis paper is structured as follows: after introducing the main features of\nASM (Sect.2), we show how the transformationfrom ASM into the SMV lan-\nguageisperformed(Sect. 3).Sect. 4presentsresultsfromapplyingourapproach\nto a case study, an ASM speciﬁcation of the FLASH cache coherenceprotocol.\nSect.5outlinesrelatedwork.WeconcludeinSect. 6withanoutlooktofurther\npossibleimprovementsofourtool.\n2 Basic Notions of Abstract State Machines\nInthissectionweintroducesomebasicnotionsofASM(see[ 7]forthecomplete\ndeﬁnition). Weﬁrstdescribetheunderlying computationalmodelandthen the\nsyntaxandsemanticsofthesubsetoftheASMlanguageneededinthispaper.\n2.1 Computational Model\nComputations Abstract State Machines deﬁne a state-based computational\nmodel,wherecomputations( runs)areﬁniteorinﬁnitesequencesofstates {Si},\nobtainedfromagiven initial state S0 byrepeatedlyexecuting transitions δi:\nModelCheckingSupportfortheASMHigh-LevelLanguage 333\nS0\nδ1\n−→ S1\nδ2\n−→ S2 ...\nδn\n−→ Sn ...\nStates The states are algebras over a givensignature Σ (or Σ-algebras for\nshort).Asignature Σ consistsofasetof basic typesandasetof function names,\neachfunctionname f comingwithaﬁxedarity n andtype T1 ...T n → T ,where\ntheTi andT arebasictypes(written f :T1 ...T n → T ,orsimply f :T ifn =0).\nforeachfunctionname f :T1 ...T n → T inΣ (theinterpretation ofthefunction\nnamef inS).Functionnamesin Σ canbedeclaredas:\n– static: static function names have the same (ﬁxed) interpretation in each\ncomputationstate;\n– dynamic: the interpretation of dynamic function names can be altered by\ntransitionsﬁredinacomputationstep(seebelow);\n– external:theinterpretationofexternalfunctionnamesisdeterminedbythe\nenvironment (thus, external functions may change during the computation\nasaresultofenvironmentalinﬂuences,butarenotcontrolledbythesystem).\nAnysignature Σ mustcontainatleastabasictype BOOL,staticnullaryfunction\nnames(constants) true :BOOL,false :BOOL,the usualbooleanoperations( ∧,\n∨,etc.),andtheequalitysymbol=.Wealsoassumethatthereisa(polymorphic)\ntype SET (T ) of ﬁnite sets with the usual set operations. When no ambiguity\narises we omit explicit mention of the stateS (e.g., we writeT instead ofT S\nforthecarriersets,and f insteadof fS forstaticfunctions,astheyneverchange\nduringarun).\nLocations Iff :T1 ...T n → T isadynamicorexternalfunctionname,wecall\napair l =(f,\n x)with\n x ∈T 1 ×... ×Tn alocation (then,the type ofl isT andthe\nvalue ofl inastate S isgivenby fS(\nx)).Notethat,withinarun,twostates Si\nandSj areequaliﬀthe valuesofalllocationsin Si andSj areequal(i.e., they\ncoincideiﬀtheycoincideonalllocations).\nTransitions Transitions transform a stateS into its successor stateS′ by\nchangingtheinterpretationofsomedynamicfunctionnamesonaﬁnitenumber\nofpoints(i.e.,byupdatingthevaluesofaﬁnitenumber of locations).\nMore precisely, the transition transformingS into S\n′ results from ﬁring a\nﬁnite update set ∆ at S,wh e r eupdates are of the form ((f,\n x),y ), with (f,\n x)\nbeingthelocationtobeupdatedand y thevalue.Inthestate S′resultingfrom\nﬁring∆ atS thecarriersetsareunchangedand,foreachfunction name f:\nfS′(\nx)=\n{y if((f,\n x),y )∈ ∆\nfS(\nx) otherwise.\nNotethattheabovedeﬁnitionisonlyapplicableif ∆ doesnotcontain conﬂicting\nupdates,i.e.,anyupdates(( f,\n x),y )and(( f,\n x),y ′)with y ̸=y′.\nT h eu p d a t es e t∆–which depends on the stateS–is determined by evalu-\nating inS a distinguished closedtransition rule P , called theprogram.T h e\nprogram consists usually of a set (block) of rules, describing system behavior\nunderdiﬀerent–usuallymutuallyexclusive–conditions.\n1\n1 See,forinstance,theexampleinSect. 4,containingaruleforeachmessagetype.\n334 GiuseppeDelCastilloandKirstenWinter\n2.2 The ASM Language\nTerms Terms are deﬁned as in ﬁrst-order logic:(i) if f : T1 ...T n → T is\na function name inΣ,a n dti are terms of typeTi (for i =1 ,...,n ), then\nf(t1,...,t n)i sat e r mo ft y p eT (written t : T )( i fn = 0 the parentheses are\nomitted, i.e. we writef instead off()); (ii) av a r i a b l ev (of a given typeT )\nis a term. The meaning of a termt : T in a stateS and environmentρ is a\nvalueSρ(t)∈T deﬁnedby:2\nSρ(t)=\n{\nfS(Sρ(t1),...,S ρ(tn)) if t ≡ f(t1,...,t n)\nρ(v)i f t ≡ v.\nAsopposedtoﬁrst-orderlogic,thereisnonotionofformula:booleantermsare\nused instead. Finite quantiﬁcations of the form “(Qv in A : G)”, whereQ is\n∀ or∃,v :T ,A :SET (T ),and G :BOOL,arealsovalidbooleanterms. 3\nTransition rules Whiletermsdenotevalues,transitionrules( rules forshort)\ndenoteupdate sets,andareusedtodeﬁnethedynamicbehaviorofanASM:the\nmeaningofarule R ina stateS andenvironment ρ isanupdateset ∆S,ρ(R).\nASM runs starting in a given initial stateS0 are determined by the pro-\ngram P : each stateSi+1 (i ≥ 0) is obtained by ﬁring the update set∆Si (P )\natSi:\nS0\n∆S0 (P)\n−→ S1\n∆S1 (P)\n−→ S2 ...\n∆Sn−1 (P)\n−→ Sn ...\nBasic transition rules are theskip, update, block,a n dconditional rules. Addi-\ntional rules are thedo-forall (a generalized block rule) andchoose rules (for\nnon-deterministicchoice).4\nR ::= skip | f(t1,...,t n):= t | R1 ... Rn | if G then RT else RF\n| do forall v in A with GR ′ | choose v in A with GR ′\nTheform“ if G then R”isashortcutfor“ if G then R else skip”.Omitting\n“with G”i ndo-forall andchoose rulescorrespondstospecifying “ with true”.\nThesemanticsoftransitionrulesisasfollows:\n∆S,ρ(skip )= {}\n∆S,ρ(f(t1,...,t n):= t )= { ((f, (Sρ(t1),...,S ρ(tn))),S ρ(t))}\n∆S,ρ(R1 ... Rn )= ⋃n\ni=1 ∆S,ρ(Ri )\n∆S,ρ(if G then RT else RF )=\n{\n∆S,ρ(RT )if Sρ(G)= true\n∆S,ρ(RF )otherwise\n2 Environments–denoted by the letterρ–are ﬁnite maps containing bindings which\nassociate(free)variablestotheircorrespondingvalues.Weadoptthefollowingno-\ntation:ρ[v↦→x]istheenvironmentobtainedbymodifying ρtobind vtox,while ρ\\v\nistheenvironmentwiththebindingofvariable v removedfrom ρ.Forclosedterms\nandrules,weomitexplicitmentionof ρ(e.g.,if tisaclosedterm, S(t)= S∅(t)).\n3 Alsointherestofthispaperweuse Aforset-typedtermsand Gforbooleanterms.\n4 TheASMWorkbenchsupportmorerules,suchas let andcase ruleswith pattern\nmatching:however,forreasonsofspace,wehavetoskipthemhere.\nModelCheckingSupportfortheASMHigh-LevelLanguage 335\n∆S,ρ(do forall v in A with GR ′)= ⋃\nx∈X ∆S,ρ[v→x](R′)\nwhereX ={x | x ∈ Sρ(A)∧ Sρ[v→x](G)= true}.\nNote that executing a block (or a do-forall) rule corresponds tosimultaneous\nexecutionofitssubrules 5 andmayleadtoconﬂicts.\nChooserulesarenotdirectlysupportedbyourtransformationtool,butcan\nalways be replaced by external functions for arbitrary choice of a value (by a\ntransformation similar to skolemization). For example, letAi be terms of type\nSET (Ti),i =1, 2, 3,and fx :T1,fz :T2 → T3 external functions withfx ∈ A1\nandfz(y)∈ A3 foreach y ∈ A2.Thenthefollowingtworulesareequivalent:\nchoose xin A1\ndo forall y in A2\nchoose z in A3\na(x,y,z ):= x+y+z\n∼= do forall y in A2\na(fx,y,fz(y)):= fx +y+fz(y)\nMulti-Agent ASM Concurrentsystemscan be modelled in ASM bythe no-\ntionofmulti-agentASM(called distributed ASM in[7]).Thebasicidea isthat\nthe system consists of moreagents, identiﬁed with the elements of a ﬁnite set\nAGENT (whichareactuallysortof“agentidentiﬁers”).Eachagent a ∈ AGENT\nexecutes its own programprog(a) and can identify itself by means of a special\nnullaryfunction self :AGENT,whichisinterpretedbyeachagent a asa.\nAs a semantics for multi-agent ASM we consider here a simple interleaving\nmodel,whichallowsustomodelconcurrentsystemsinthebasicASMformalism\nasdescribedabove.Inparticular,weconsider self asanexternalfunction,whose\ninterpretation selfSi determines the agent which ﬁres at stateSi.W ea s s u m e\nthatthereisoneprogram P ,sharedbyallagents,possiblyperformingdiﬀerent\nactionsfordiﬀerentagents,e.g.:\nif self =a1 then prog(a1)\n...\nif self =an then prog(an)\nwhere {a1,...,a n} are the agents andprog(ai) is the rule to be executed by\nagentai, i.e., the “program” ofai. (The FLASH model presented in Sect.4 is\nanexampleofthisstyleofmodelling,exceptthatallagentsexecuteexactlythe\nsameprogram,butondiﬀerentdata.)\nThe ASM-SL Notation The ASM language,including all constructsabove,\nis supported by the “ASM Workbench” tool environment [2], which provides\nsyntax-andtype-checkingofASMspeciﬁcationsaswellastheirsimulationand\ndebugging. The source language for the ASM Workbench, called ASM-SL, in-\ncludessomeadditionalfeatureswhicharenecessaryforpracticalmodellingtasks:\nconstructsfordeﬁningtypes,functions,andnamedtransitionrules(“macros”),\nas well as a set of predeﬁned data types (booleans, integers, tuples, lists, ﬁnite\nsets,etc.):astheASM-SLnotationisquiteclosetousualmathematicalnotation,\nnofurther explanationofASM-SLwillbeneeded.\n5 Forexample,ablockrule a :=b,b :=a exchangesa andb.\n336 GiuseppeDelCastilloandKirstenWinter\n3 Translating Abstract State Machines into SMV\nIn this section, after a brief comparison of the ASM and SMV speciﬁcation\nlanguages,wedescribethetransformationfromASMtoSMVintwostages.First\nwerecallthetranslationschemeintroducedin[ 14],deﬁnedforasubsetofASM\ncalledASM\n0 inthispaper(Sect. 3.1).Thenwedeﬁneatransformationtechnique\ntoreduceanyASMspeciﬁcationtoASM 0,suchthattheﬁrsttranslationscheme\ncanthenbeapplied(Sect. 3.2).\nASM versus SMV WhilethecomputationalmodelunderlyingbothSMVand\nASM is essentially the well-known model oftransition systems, there are some\nsigniﬁcantdiﬀerences: (1.) AbstractState Machinesdeﬁne, ingeneral,systems\nwithapossiblyinﬁnitenumberofstates(asboththenumberoflocationsandthe\nlocationrangesmaybeinﬁnite); (2.) thewayofspecifyingtransitionsinASM\nand SMV is diﬀerent: in SMV transitions are speciﬁed bynext-expressions,\nwhich completely deﬁne the value which a state variable assumes in the next\nstate, while updates of dynamic functions in ASM may be scattered troughout\ntheprogram; (3.) theASMnotionsof dynamic function andexternal function\ngeneralizethe notion ofstate variable typicalof basictransition systems (state\nvariablescorrespondto nullarydynamic/externalfunctionsofASM).\nTheﬁrstissueissolvedbyintroducing ﬁniteness constraints,thesecondand\nthirdareaddressedbythetransformationsofSect. 3.1and3.2,respectively.\nFiniteness constraints In order to ensure that the ASM programs to be\ntranslatedintoSMVdeﬁneﬁnite-statesystems,theuserhastospecify,foreach\ndynamic or external functionf : T\n1 ...T n → T , a ﬁniteness constraint of the\nform f(x1,...,x n) ∈ t[x1,...,x n], wheret : SET (T ) is a term denoting a ﬁ-\nnite set,possiblydepending onthe argumentsof f (seeFig. 1for anexample).\nForexternalfunctions,ﬁnitenessconstraintscorrespondtoenvironmentassump-\ntions,expressedintheresultingSMVmodelbytherangeofthegeneratedstate\nvariables;fordynamicfunctions,itmustbecheckedthattheconstraintsarenot\nviolatedbytherules,resultingintheSMVcodeinappropriateproofobligations,\nwhichwecall range conditions.6\n3.1 The Basic Translation Scheme\nThetranslationschemeintroducedin[ 14]canbeappliedtotransformintoSMV\nasubsetASM 0 ofASM,where: (i) onlynullary dynamicandexternalfunctions\nare allowed;(ii) the only available data types are integers, booleans and enu-\nmerated types; (iii) the only deﬁned static functions are those corresponding\ntopredeﬁnedoperationsinSMV(booleanoperations,+,-,etc.).\nAs the semantic models for ASM0 are essentially basic transition systems,\nthetranslationofASMintoSMVisveryclose:\n6 Note,however,thattherangeconditionscanoftenbediscardedbyasimplestatic\nanalysisoftherules,whichpreventstheirexpensiveproofbymodel-checking.\nModelCheckingSupportfortheASMHigh-LevelLanguage 337\n– non-staticfunctions(i.e.,dynamicandexternalfunctions)areidentiﬁedwith\nlocationsandthusmappedone-to-onetoSMVstatevariables;\n– valuesoftheASMdatatypesaremappedone-to-oneto SMVconstants;\n– applications of static functions are translated to applications of the corre-\nspondingbuilt-in operatorsofSMV.\nWhatremainstobedoneistorestructuretheASMprogramintoaformwhere\nupdatesofthesamelocation,togetherwiththeirguards,arecollectedtogether.\nThisisdoneintwosteps.First,wetransformanASMprogram P intoanequiv-\nalentASMprogram P ′consistingonlyofablockofguardedupdates(i.e.,rules\noftheform if G then f(\nt):= t)bymeansofa “ﬂattening”transformation:\n[[skip ]]= (empty block)\n[[f(\nt):= t]]= if true then f(\nt):= t\n[[R1 ...R n ]]=[ [R1 ]] ... [[Rn ]]\n[[RT ]]=\n{if G1\nT then R1\nT\n...\nif Gn\nT then Rn\nT\n[[RF ]]=\n{if G1\nF then R1\nF\n...\nif Gm\nF then Rm\nF\n⇒ [[if Gthen RT else RF ]]=\n\n\n\n\n\n\n\nif G∧ G1\nT then R1\nT\n...\nif G∧ Gn\nT then Rn\nT\nif ¬G∧ G1\nF then R1\nF\n...\nif ¬G∧ Gm\nF then Rm\nF\nSecond, we collect all guarded updates of the same location, thus obtaining,\nfor eachlocation loc occurring on the left-hand side of an update inP ′,ap a i r\n(loc, {(G1,t 1),..., (Gn,t n)})whichmaps loc toasetofpairs(guard,right-hand\nside).SuchapairistranslatedintothefollowingSMVassignment: 7\nASSIGN next(C [[loc ]]): =\ncase C [[G1 ]] : C [[t1 ]] ; ... C [[Gn ]] : C [[tn ]] ;1 : C [[loc ]] esac;\nwhereC [[. ]] denotesherethe ASM → SMV compiling function for terms,which\nis straightforward for ASM0. For each locationl of a dynamic functionf,i n\naddition to thenext assignment above, the transformation also generates the\nlocation’sinitialization(an init assignmentinSMV)aswellastwoproofobli-\ngations,a range condition (seediscussionofﬁniteness constraintsabove)anda\nno-conﬂict condition, which ensures that no conﬂicts arise on this location. In\nfact,duetothesemanticsof case inSMV,thetranslationschemeiscorrectonly\nif for alli, jwith i ̸= j, S |= ¬(Gi ∧ Gj)∨ (ti = tj) in any reachable stateS:\nif, in somestateS,this conditionis notsatisﬁed, the ASM transitionproduces\na conﬂict (i.e., an error), while the corresponding SMV transition simply picks\noneoftheupdates(theﬁrstoneinthe case whoseguardissatisﬁed). 8\n3.2 The Extended Translation Scheme\nInthissectionweshowhowtoreduceanarbitrary(ﬁnite-state)ASMtoASM 0.\nThis transformation allows to deal with the complete ASM language as in [7],\n7 Notethatwehavetospecifythedefaultcaseexplicitly(ifnoneoftheguardsistrue)\nwhichisgivenimplicitlyinASMrules(seeASMsemanticsabove).\n8 Likerangeconditions,no-conﬂictconditionscanbeoftendiscardedstatically.\n338 GiuseppeDelCastilloandKirstenWinter\nwith the exception ofimport rules (rules which allow the dynamic creation of\nelementsatrun-time)and choose rules.(However,onecandealwith choose as\nexplainedinSect. 2.2.)Arbitrarydatatypesandoperations(inparticular,lists,\nﬁnitesets,ﬁnitemapsanduser-deﬁnablefreelygeneratedtypes,asprovidedby\nASM-SL) can be used without any restriction. Finite quantiﬁcations are also\nsupported.\nThe main problem here, as opposed to ASM0, is that in general we do not\nknowwhich locationis updated by an update rulef(t1,...,t n):= t (ifn> 0):\ntheupdatedlocationmaydiﬀerfromstatetostateifsome ti containsnon-static\nfunctionnames.However,ifallterms ti containonlystaticfunctionnames,they\ncanbeevaluatedstaticallytovalues xi,andtheterm f(t1,...,t n)tothelocation\nl =(f,\n x).Thus,thebasicideaofthetransformationistoiterativelyunfoldand\nsimplifyrulesuntilalltermscanbereducedto valuesorlocations.\nTo formally deﬁne the transformation, we extend the syntactic category of\nterms to “partially evaluated terms” (simply called “terms” in the sequel) by\naddingvaluesandlocations:\nt ::= f(t\n1,...,t n) | v | (Qv in A :G) | x | l\n(Weadopttheconventionthat x standsforavalueand l foralocation).\nTerms can be simpliﬁed by means ofthe transformation[[. ]]ρ deﬁned in Ta-\nble1,whichisthenextendedtorulesinacanonicalway.Notethat,whenever ρ\ncontainsbindingsforallfreevariablesoccurringin t:(i) ift isastaticterm,then\n[[t ]]ρ isavalue x (coincidingwith Sρ(t)inev erystate S);(ii) ift ≡ f(t1,...,t n)\nisatermwhere f isadynamicorexternalfunctionnameandallthesubterms ti\narestatic(wecallsuchaterma locational term),then [[t ]]ρ isalocation l.9\nTherule-unfoldingtransformation E,whichoperatesonclosedrulessuchas\ntheprogram P ,isformallydeﬁnedinTable 2.Itworksasfollows:\n– iftherule R consistsofablockofupdaterulesoftheform location :=value,\nitterminatesandyields R asresult(thereisnothingleft tounfold);\n– otherwise,itlooksfortheﬁrstlocation l occurringin R (butnotasleft-hand\nside of some update rule) and unfoldsR according to the possible values10\nof l. In turn, the unfolding has to be applied to the subrules[[R[l/xi]]] ob-\ntainedbysubstituting thevalues xi forl inR andsimplifying.\nApplying E to the (simpliﬁed) ASM program[[P ]]∅ yields a programP ′ =\nE([[P ]]∅)whichisessentiallyanASM 0 program(formally,thelocationshavestill\ntobereplacedbynullarydynamicorexternalfunctionnamesandthevaluesby\nnullarystaticfunctionnames,i.e.byconstants). 11\n9 Asimpleconsequenceofthisfactisthateveryclosedstatictermsimpliﬁestoavalue\nandeveryclosedlocationaltermtoalocation.\n10 Theﬁniterangeoflocation l=(f,\nx)isderivedfromtheﬁnitenessconstraintfor f.\n11 The unfolding transformation often results in very large decision trees (case-\nstructuresinSMV):however,thisdoesnothaveanegativeinﬂuenceontheeﬃciency\nofveriﬁcationwithSMV,astheveriﬁcationcostsdependonthesizeoftheBDDs\nrepresentingthetransitionrelationandnotonthesizeoftheSMVsourcecode(and\nBDDs,foragivenvariableordering,areacanonicalrepresentation).\nModelCheckingSupportfortheASMHigh-LevelLanguage 339\nTable 1. TermandRuleSimpliﬁcation\nTerm Simpliﬁcation\n[[x]]ρ =x [[l]]ρ =l\n[[v ]]ρ =\n{\nx=ρ(v)i f v∈ dom(ρ)\nv otherwise\n[[ti ]]ρ =xi foreach i∈{ 1,...,n }⇒\n[[f(t1,...,t n)]]ρ =\n{\nx=f(x1,...,x n)i f f staticfunctionname\nl=(f,(x1,...,x n)) iff dynamic/externalfunctionname\n[[ti ]]ρ =lor [[ti ]]ρ =f′(\nt\n′\n)forsome i∈{ 1,...,n }⇒\n[[f(t1,...,t n)]]ρ =f([[t1 ]]ρ,..., [[tn ]]ρ)\n[[(Qv in A:G)]]ρ =\n\n\n\n[[G]]ρ[v↦→x1] op ... op [[G]]ρ[v↦→xn]\nif [[A]]ρ =x={x1,...,x n} (i.e.,if [[A]]ρ isavalue)\n(Qv in [[A]]ρ :[[G]](ρ\\v))\notherwise.\n(whereop ≡∧ ifQ≡ forall,op ≡∨ ifQ≡ exists).\nRule Simpliﬁcation\n[[skip ]]ρ =skip\n[[tL :=tR ]]ρ =[[tL ]]ρ := [[tR ]]ρ\n[[R1 ...R n ]]ρ =[[R1 ]]ρ ... [[Rn ]]ρ\n[[if Gthen RT else RF ]]ρ =\n{ [[RT ]]ρ if [[G]]ρ =true\n[[RF ]]ρ if [[G]]ρ =false\nif [[G]]ρ then [[RT ]]ρ else [[RF ]]ρ otherwise.\n[[do forall v in Awith GR ′]]ρ =\n=\n\n\n\n[[if Gthen R′]]ρ[v↦→x1] ... [[if Gthen R′]]ρ[v↦→xn]\nif [[A]]ρ =x={x1,...,x n} (i.e.,if [[A]]ρ isavalue)\ndo forall v in [[A]]ρ with [[G]](ρ\\v) [[R′]](ρ\\v)\notherwise.\nTable 2. RuleUnfolding\nRule Unfolding\nIfRhastheform l1 :=x1 ...l n :=xn,then E(R)= R.\nOtherwise:\nE(R)= if l=x1 then E([[R[l/x1]]]∅)\nelse if l=x2 then E([[R[l/x1]]]∅)\n...\nelse if l=xn then E([[R[l/xn]]]∅)\nwherelistheﬁrstlocationoccurringin R(butnotaslhsofanupdaterule)\nand{x1,...,x n} istherangeoflocation l.\n\n340 GiuseppeDelCastilloandKirstenWinter\nFig.1illustratesgraphicallythetransformationtechnique(forsimplicity,we\nconsider a rule without variables, such that we can omit mentioning environ-\nments).Therootofthetree–enclosedinthedashedbox–isthe(simpliﬁed)ASM\nprogram\n[[P ]] tobetransformed.Thesuccessorsofeachnodeinthetreeareob-\ntainedasresultofanunfoldingstep(underthegivenﬁnitenessconstraints):for\ni n s t a n c e ,t h es u c c e s s o r so ft h er o o tn o d ea r et h er u l e s[[[[P ]][a/1]]], [[[[P ]][a/2]]],\nand [[[[P ]][a/3]]], respectively. Locations are emphasized by enclosing them in\nboxes:notethat,attheleaves,locationsoccuronlyasleft-handsideofupdates,\nthus they cause no further unfolding. The dashed box on the right contains\ntheASM0 programproducedbythetransformation:notethatthelocationsac-\ntually aﬀected by the ASM program–which are revealed by the unfolding–are\nmappedto nullaryfunctions (“statevariables”),whoserangesarederivedfrom\ntheﬁnitenessconstraints(seeboxatthetoprightcorner).\na\nf(x)\ng(x)\n{1, 2, 3}\n{x, x + 1 }\n{ 1,...,5 }\nFiniteness constraints\n(f,(1)) f1→ : { 1, 2 }\n(f,(2)) f2→ : { 2, 3 }\naa → : { 1, 2, 3 } (g,(1))\n(g,(2))\n(g,(3))\ng2\ng1\ng3\n→\n→\n→\n: { 1,...,5 }\n: { 1,...,5 }\n: { 1,...,5 }\n→Locations State variables\nthen skipa = 3else if\nthen if\nif then\nf2 = 2\nf2 = 3\nthen :=g2\ng3\n2\n:= 2\na = 2else if\nthen g1 := 1then if f1 = 1\nif then := 1g2\nif a = 1\nf1 = 2\n→\nASM0\nASM\n∈\n∈\n∈\naathen :=g(f( ))\naif 2≤\ng, (3) := 2g, (2) := 1 g, (2) := 2\n:= 2g( )f, (2)\ng, (1) := 1\n:= 1f, (1)g( ) skip\na = 1 a = 2 a = 3\n(f,(2)) = 2(f,(1)) = 1 (f,(2)) = 3(f,(1)) = 2\nFig. 1. RuleTransformationExample\n4 Case Study: The FLASH Cache Coherence Protocol\nAsanexampleforourmodelcheckingapproachwechoseaformalizationofthe\nFLASH protocol[9]with ASM. Our modelisbasedonthe workofDurand[ 4].\nIn Sect.4.1, after a short introduction to FLASH, we describe an ASM model\nderived from [4] and motivate our reﬁnements. Then we sketch the debugging\nprocesssupportedbythetransformationandcheckingwithSMV(inSect. 4.2).\n4.1 FLASH Cache Coherence Protocol\nThe Stanford FLASH multiprocessor integrates support for cache coherent\nshared memory for a large number of interconnected processing nodes. Each\nline-sizedblockofthedistributed memoryisassociatedwith a home nodecon-\ntaining the partof the physical memory where that line resides. Every read or\nwrite miss concerninga remotememory line triggersaline requestto itshome\nnode that in turn initiates the corresponding part of the protocol. The request\nModelCheckingSupportfortheASMHigh-LevelLanguage 341\nmayaskfor shared orexclusive accessdependingonwhetherreadingorwriting\naccessiswanted.\nTheASM descriptionofthe protocolisbasedonagents.Asetoftransition\nrulesdescribesthebehaviorofasingleagent.Thebehaviorisdeterminedbythe\ncurrentlyprocessedmessagetype–anotionthatyieldstheclearmodelstructure\nthatissketchedinFig. 2.\nMessage Structure. A message is modeled as a quintuple consisting of\nthetypeofthemessage,theaddressedagent,senderagent,agentinitiatingthe\nrequestandrequestedline 12.Messagetypesrelatedto shared accessare:\nget: requestingalinefromits home\nput: grantingalinetotherequester( source oftherequest)\nfwdget: forwardingtherequestto anexclusiveowneroftheline\nswb: requestinga write-backofanownedlinethatistobeshared\nnack, nackc: negativelyacknowledgingtherequestorforwardedrequestre-\nspectively,ifitcannotbeperformednow.\nInanalogy,messagetypesrelatedto exclusive accessare:\ngetx,putx,fwdgetx,andalso\ninv: requestingacurrent sharer ofthelineto invalidateitslocalcopy\ninvAck: acknowledgingtheinvalidationoftheline\nfwdAck: owner’sgrantingaccordingtoaforwardedsharedrequest.\nAdditionally, for releasing a shared or exclusive copy from its cache an agent\nsendsawrite\n back(wb)andareplacemessage( rpl)to home,respectively.Aread\norwritemissofaline, ortheend ofaccessing,issimulatedwiththe helpofan\noraclefunction whichnon-deterministicallytriggersanagentto send get/getx\norrpl/wb messages.\nState Functions. Besides the message type, the agent’s behavior depends\non several local state variables:curPhase(line) (phase of the current request),\nState(line) (state of the local line copy in use), andpending(line) (ﬂag for cur-\nrently processed request).Owner(line) and the set ofSharers of a line are also\ntakenintoaccount.\nAdjustable Parameters. The transition rules are parameterized byself,\nthe agent that is currently active (this is implicit in Fig.2), and the requested\nline. The domains of these parameters,Agents and Lines, and their extent are\neasilyadjustableinthedeclarationpartofthespeciﬁcation.\nNecessary Reﬁnements. Sendingamessageisgivenasamacrodeﬁnition.\nIntheabstractmodelof[ 4]SendMsg addsamessagetoa(possiblyinﬁnite)set\nofmessagesintransit.Thestrategyforreceivingamessagefromthissetisnot\nspeciﬁed.Fortheproofit isjustassumedthatthe messagesarereceivedin the\nrightorder.Inordertokeepthemodelﬁniteandtoformalizetheassumptionon\nthemodelbehaviorwehavetoreﬁnethemodel.Wereplacethesetofmessages\nin transit by a ﬁnite queue for each agent, and we extend the overall behavior\nby means of a sub-step for synchronization. In the synchronization step the\nmessagesarepassedthroughtotheaddressedagentintheproperorder.\n12 Inouradaptationofthemodelthepartsrelatedtodataarediscarded.\n342 GiuseppeDelCastilloandKirstenWinter\nif\n MessType =\n get\nthen\n if\n pending(l)then\n SendMsg(nack,source, self ,source,l )\nelse\n if\n Owner(l)̸=undef\nthen\n SendMsg(fwdget,Owner(l),self ,source,l )\npending(l): = true\nelse\n SendMsg(put,source, self ,source,l )\nSharer(l,source): = true\nif\n MessType =\n fwdget\nthen\n ...\nif\n MessType =\n put\nthen\n ...\nif\n MessType =\n swb\nthen\n ...\nif\n MessType =\n nack\nthen\n curPhase(l): = ready\nif\n MessType =\n nackc\nthen\n pending(l): = false\nif\n MessType =\n getx\nthen\n if\n pending(l)\nthen\n SendMsg(nack,source, self ,source,l )\nelse\n if\n Owner(l)̸=undef\nthen\n SendMsg(fwdgetx,Owner(l),self ,source,l )\npending(l): = true\nelse\n if\n ∃u:Sharer(l,u)\nthen\n ∀u:Sharer(l,u)SendMsg(inv,u,self ,source,l )\npending(l): = true\nelse\n SendMsg(putx,source, self ,source,l )\nOwner(l): = source\nif\n MessType =\n fwdgetx\nthen\n ...\nif\n MessType =\n fwdAck\nthen\n ...\nif\n MessType =\n inv\nthen\n SendMsg(invAck,home,self ,source,l )\nif\n State(l)= shared\nthen\n State(l): = invalid\nelse\n if\n curPhase(l)= wait\nthen\n curPhase(l): = invalidPhase\nif\n MessType =\n invAck\nthen\n Sharer(l,MessSender ): = false\nif\n ∀a:Agents| a̸=MessSender ∧ Sharer(l,a)= false\nthen\n SendMsg(putx,source, self ,source,l )\npending(l): = false\nif\n MessType =\n putx\nthen\n ...\nif\n MessType =\n rpl\nthen\n ...\nif\n MessType =\n wb\nthen\n ...\nFig. 2. AgentbehaviormodeledbyASMtransitionrules\nModelCheckingSupportfortheASMHigh-LevelLanguage 343\nInanASMmodel,introducingasub-stepisstructurepreserving:inaddition\nto the ASM for message computation (explained above) we specify an ASM\nfor the messagepassing through.An overallASM invokesboth “sub-ASMs” in\nturn. Taking this, we beneﬁt from the clear and understandable structure of\nthe abstract model. The entire reﬁned ASM-model is available on the web at\nhttp://www.first.gmd.de/~kirsten/publications/flash_param.asm.\n4.2 Model Checking the Transformed System Speciﬁcation\nWetakemodelcheckingofthetransformedASMmodelasanevolutionarypro-\ncess of debugging: we edit the ASM model, transform it automatically into an\nSMV model, run SMV to check the properties under investigation, investigate\nthe resulting counterexample (if any) within the ASM model, and debug the\nASMmodel.Sincetherearenorestrictionsonthebehavioroftheenvironment\n(producingrequestsonaline),wedonotsuﬀerfrom“wrong”counterexamples\nthatarenotsuitablefordebuggingtheordinarysystembehavior.(Wecallcoun-\nterexampleswrong,if theyarecausedbynon-reasonableenvironmentbehavior\nthat should be excluded. They obstruct the debugging process, since only one\ncounterexamplewillbeproduced.)\nAs the debuggingprocess is more eﬃcient if the model checkingterminates\nin a reasonable span of time, we keep our model as small as possible. We ﬁnd\nthat,evenwhenthemodelisrestrictedtofewagentsandlines,wedetecterrors\nin theabstractmodelaswellasinour reﬁnement.Inthe followingwedescribe\ntwoofthem asexamples.Wecheckthemodelfor safety andliveness,i.e.:\n– Notwoagentshaveexclusiveaccessonthesamelinesimultaneously.\n– Eachrequestwilleventuallybeacknowledged.\n– Wheneveranagentgetssharedaccess,homewillnoteitasasharer.\nWeformalizetheserequirementsinCTL,e.g.\n13:⋀\ni̸=j[AG (!(State(a(i),l)=exclusive & State(a(j),l)=exclusive))]\n⋀\ni[AG (curPhase(a(i),l) = wait -> AF (curPhase(a(i),l) = ready))]\n⋀\ni[AG (State(a(j),l)=shared -> AX (Sharer(l,a(i)) = true))]\nOur ﬁrst counterexample shows simultaneous exclusive access (for reasons of\nspacewehavetoomitthelistinghere).Theerrorthatcausedthecounterexample\ncanalsobefoundintheabstractASMmodelof[ 4]:\nWhenevera putx-messageissenttograntexclusiveaccesstheaddressed\nrequester has to be noted as owner of the line. This is speciﬁed in the\ngetx-rule but it is missing in theinvAck-rule that might also cause a\nputx-messageto be send (see also Fig.2). The protocol is unsafe since\nsimultaneousexclusiveaccessmayoccur,andwrittendatamaybelost.\n13 Thoughthethirdspeciﬁcationisratherweak,ityieldshelpfulcounterexamples.\n344 GiuseppeDelCastilloandKirstenWinter\nThefollowingcounterexamplesarededicatedtotheproblemofracing(i.e.,con-\nﬂicts)ontheﬁnitemessagequeue.Althoughourdataspaceislimitedtoavery\nshortqueue,wecanderivemoregeneralremarks,e.g.:\nEach sharer of a requested line has to process the rule for invalidation\n(inv-rule).Itsendsan invAck-messageto home foracknowledgingthein-\nvalidation.Whenreceivingan invAck-message,home deletesthesender\nfromthelistofsharers.If home issharertoo,\n14 adeadlockmayoccurif\nthenumberofsharersisgreaterorequalthanthelengthofthemessage\nqueue: home may fail to complete with theinv-rule when the queue is\nfullandsendingamessageisnotpossible(sinceeveryothersharermay\nhave sent before);home stays busy and can not process the incoming\ninvAck-ruleto clear the queue. In general, we found out that the mes-\nsage queue must be larger or equal than the number of agents since in\nthe worst case each agent is a sharer and will send simultaneously an\ninvAck-messagetothehomenode.\nTheexamplesshowthathelpfulborderlinecasescanbedetectedmoreeasily\nby a model checker than by pure simulation. The computational eﬀort for the\nautomatedtransformationofourmodelsrangesfromthreetoﬁveseconds.The\nsize of the resulting SMV models is given below.\n15 The variable ordering is\ndeterminedbytheautomaticreorderingfacilitythatisgivenbytheSMV.\nresourcesused: 2agents,1line\n 3agents,1line\n 2agents,2lines\nusertime/systemtime: 4.69s/0.13s\n 5687.52s/0.6s\n 17263.2s/0.86s\nBDDnodesallocated: 70587\n 1612740\n 2975127\nBytesallocated: 4849664\n 37748736\n 54657024\nBDDnodesrepr.transitionrelation: 19261+78\n 288986+82\n 78365+96\nAlthoughcheckingourmodeloftheFLASHprotocolisonlyfeasibleforasmall\nnumber of agents and lines, the results showthat the counterexamples yield\nextremelyhelpful scenariosforlocatingerrors.\n5 Related Work\nExtendingtoolenvironmentsforhigh-levelspeciﬁcationlanguageswithaninter-\nfacetoamodelcheckerisanupcomingtopic.Onecanﬁndapproachesthatare\nquitesimilartooursbutworkonadiﬀerentlanguage:[ 3]suggestsatransforma-\ntion from Statecharts into SMV, in [10] Controller Speciﬁcation (CSL) models\naretransformedandmodel checkedbySVE,[ 12]equipsthemulti-languageen-\nvironmentSynchronie with aninterfacetotheVISmodelchecker,etc.\nClosertoourapproachfromthelanguagepointofview,[ 13]alsoinvestigates\nautomatic veriﬁcation of ASM. Spielmann represents an ASM model indepen-\ndently of its possible input by means of a logic for computation graphs (called\n14 Thisispossibleifweallowintra-nodecommunication.\n15 TheexperimentswerecarriedoutonanUltraSPARC-IIstationwith296MHzand\n2048Mbmemory,theoperatingsystemisSolaris2.6.\nModelCheckingSupportfortheASMHigh-LevelLanguage 345\nCGL*).TheresultingformulaiscombinedwithaCTL*-likeformulawhichspec-\niﬁespropertiesandcheckedbymeansofdecidingitsﬁnitevalidity.Thisapproach\naddressestheproblemofcheckingsystemswithinﬁnitelymanyinputs,butitis\nonlyapplicabletoASMwithonly0-arydynamicfunctions(i.e.ASM\n0 programs)\nandrelationalinput,whichisthesecondresultof[ 13].\n6 Conclusions\nWepresentedaninterfacefromtheASMWorkbenchtoSMV,basedonatrans-\nformationfromASMtotheSMVlanguageextendingtheonedeﬁnedin[ 14]by\nthetreatmentofdynamicfunctionsofarity n> 0.Thisisessential,asmostASM\nspeciﬁcationsbeneﬁtfromtheabundantuseofparametricdynamicfunctions.\nThe practicability of our approach is demonstrated by a non-trivial case\nstudy:theASMmodeloftheFLASHprotocol.Byexampleweshowthaterrors\ncan be found in the ASM model that will hardly be detected by pure mathe-\nmaticalproofs,anddeducemoregeneralconstraintsforthemodelathandfrom\nthecounterexamples.\nWesupporttheexploitationofthemodelcheckingfacilitybymeansofintro-\nducingﬁniteness constraintsintotheASMspeciﬁcationlanguageforeasycontrol\nofthefunctionrangesinordertorestrictthestatespaceofthemodel.Addition-\nally, the developer beneﬁts from the automatically generated proof obligations\nto becheckedbySMV:the no-conﬂict conditionsandthe range conditions.\nSome improvements of our tool, which are still to be implemented in order\nto make the transition between ASM and SMV smoother and thus ease the\nvalidation process, include the automatic translation of the counterexamples\ninto a form which can be immediately read and simulated by the Workbench\nandtheembedding ofCTLoperatorsintotheASM-SLlanguage.\nReferences\n1. E.B¨orger. Speciﬁcation and Validation Methods. OxfordUniversityPress,1995.\n331\n2. G.DelCastillo.TowardscomprehensivetoolsupportforAbstractStateMachines:\nTheASMWorkbenchtoolenvironmentandarchitecture.InD.Hutteretal.,eds.,\nApplied Formal Methods – FM-Trends 98,LNCS1641,pp.311–325.Springer,1999.\n331,335\n3. N.Day.AmodelcheckerforStatecharts(linkingcasetoolswithformalmethods).\nTR93-35,CSDept.,Univ.ofBritishColumbia,Vancouver,B.C.,Canada,1993.\n344\n4. A. Durand. Modeling cache coherence protocol -a case studywith FLASH. In\nU.Gl¨asserandP.Schmitt,editors, Procs. of the 5th International ASM Workshop,\npages111–126,MagdeburgUniversity,1998. 340,341,343\n5. T.Filkornet.al. SVE Users’ Guide.S i e me n sA G ,M ¨unchen,1996. 331\n6. TheVISGroup. Vis:Asystemforveriﬁcationandsynthesis.InT.Henzingerand\nR.Alur,editors, 8th Int. Conf. on Computer Aided Veriﬁcation, CAV’96,number\n1102inLNCS,pages428–432,July1996. 331\n346 GiuseppeDelCastilloandKirstenWinter\n7. Y.Gurevich. Evolving Algebras 1993: Lipari Guide. In E. B¨orger, editor,Spec-\niﬁcation and Validation Methods. Oxford UniversityPress, 1995.331,332,335,\n337\n8. J.K.Huggins.AbstractStateMachineshomepage.EECSDepartment,University\nofMichigan. http://www.eecs.umich.edu/gasm/. 331\n9. J. Kuskin et al. The Stanford FLASH multiprocessor. In21th Int. Symp. on\nComputer Architecture.Chicago,IL,1994. 340\n10. P.Liggesmeyer and M. Rothfelder. Towards automated proof offail-safe behav-\nior. InW.Ehrenberger,editor, Computer Safety, Reliablity and Security, SAFE-\nCOMP’98,LNCS1516,pages169–184,1998. 344\n11. K.McMillan. Symbolic Model Checking. KluwerAcademicPublishers,1993. 331\n12. A.Merceron,M.M¨ullerburg,andG.M.Pinna.Verifyingatime-triggeredprotocol\nin a multi-language environment. In W. Ehrenberger, editor,Computer Safety,\nReliablity and Security, SAFECOMP’98,LNCS1516,pages185–195,1998. 344\n13. M.Spielmann.AutomaticveriﬁcationofAbstractStateMachines.InN.Halbwachs\nand D. Peled, editors,Computer Aided Veriﬁcation, CAV ’99, number 1633 in\nLNCS,pages431–442,Trento,Italy,1999. 344,345\n14. K.Winter. Modelcheckingforabstractstatemachines. J.UCS Journal for Uni-\nversal Computer Science (special issue),3(5):689–702,1997. 332,336,345"
}