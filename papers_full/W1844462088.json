{
  "title": "UML-F: A Modeling Language for Object-Oriented Frameworks",
  "url": "https://openalex.org/W1844462088",
  "year": 2000,
  "authors": [
    {
      "id": "https://openalex.org/A5073768909",
      "name": "Marcus Fontoura",
      "affiliations": [
        "Princeton University"
      ]
    },
    {
      "id": "https://openalex.org/A5036973695",
      "name": "Wolfgang Pree",
      "affiliations": [
        null
      ]
    },
    {
      "id": "https://openalex.org/A5037823412",
      "name": "Bernhard Rumpe⋆",
      "affiliations": [
        "Munich University of Applied Sciences"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W4246047829",
    "https://openalex.org/W2121984483",
    "https://openalex.org/W1976110818",
    "https://openalex.org/W4233650756",
    "https://openalex.org/W2099067221",
    "https://openalex.org/W1603994548",
    "https://openalex.org/W2008250898",
    "https://openalex.org/W1967047275",
    "https://openalex.org/W2094282293",
    "https://openalex.org/W2086970510",
    "https://openalex.org/W4254691308",
    "https://openalex.org/W68605010",
    "https://openalex.org/W1996974848",
    "https://openalex.org/W86773816",
    "https://openalex.org/W3014640272",
    "https://openalex.org/W2132234187",
    "https://openalex.org/W2103574963",
    "https://openalex.org/W1649645444",
    "https://openalex.org/W1535838713",
    "https://openalex.org/W2079188997",
    "https://openalex.org/W1535654799",
    "https://openalex.org/W95087395",
    "https://openalex.org/W2029414465",
    "https://openalex.org/W2470501225",
    "https://openalex.org/W1998017916",
    "https://openalex.org/W2076637310",
    "https://openalex.org/W1572116564",
    "https://openalex.org/W1844961184",
    "https://openalex.org/W617329964",
    "https://openalex.org/W2914696409",
    "https://openalex.org/W2033868415",
    "https://openalex.org/W2130501155",
    "https://openalex.org/W1913755735",
    "https://openalex.org/W2143238865",
    "https://openalex.org/W91776631",
    "https://openalex.org/W1910673522",
    "https://openalex.org/W3095693182",
    "https://openalex.org/W1493439690",
    "https://openalex.org/W2099293367",
    "https://openalex.org/W2798957572",
    "https://openalex.org/W1527793496",
    "https://openalex.org/W1552795373"
  ],
  "abstract": null,
  "full_text": "UML-F: A Modeling Language for\nObject-Oriented Frameworks\nMarcus Fontoura1, Wolfgang Pree2, and Bernhard Rumpe3\n1 Department of Computer Science, Princeton University\n35 Olden Street, Princeton, NJ 08544-2087, U.S.A\nmfontoura@acm.org\n2 C. Doppler Lab for Software Research, University of Constance\nD-78457 Constance, Germany\npree@acm.org\n3 Software and Systems Engineering, Munich University of Technology,\nD-80290 Munich, Germany\nrumpe@acm.org\nAbstract. The paper presents the essential features of a new member of the\nUML language family that supports working with object-oriented frameworks.\nThis UML extension, called UML-F, allows the explicit representation of\nframework variation points. The paper discusses some of the relevant aspects of\nUML-F, which is based on standard UML extension mechanisms. A case study\nshows how it can be used to assist framework development. A discussion of\nadditional tools for automating framework implementation and instantiation\nrounds out the paper.\n1 Introduction\nObject-oriented (OO) frameworks and product line architectures have become\npopular in the software industry during the 1990s. Numerous frameworks have been\ndeveloped in industry and academia for various domains, including graphical user\ninterfaces (e.g. Java’ s Swing and other Java standard libraries, Microsoft’ s MFC),\ngraph-based editors (HotDraw, Stingray’ s  Objective Views), business applications\n(IBM’ s San Francisco), network servers (Java’ s Jeeves), just to mention a few. When\ncombined with components, frameworks provide the most promising current\ntechnology supporting large-scale reuse [16].\nA framework is a collection of several fu lly or partially implemented components\nwith largely predefined cooperation patterns between them. A framework implements\nthe software architecture for a family of applications with similar characteristics [26],\nwhich are derived by specialization through application-specific code. Hence, some\nof the framework components are designed to be replaceable. These components are\ncalled variation points or hot-spots [27] of  the framework. An application based on\nsuch a framework not only reuses its source code, but more important, its architecture\ndesign. This amounts to a standardization of  the application structure and allows a\nsignificant reduction of the size and complexity of the source code that has to be\nwritten by developers who adapt a framework.\n[FPR00] M. Fontoura, W. Pree, B. Rumpe. \nUML-F: A Modeling Language for Object-Oriented Frameworks. \nIn: Proceedings of ECOOP 2000-Object-Oriented Programming Conference, pp.63-83 \nElisa Bertino (eds.) \nLNCS 1850, Springer Verlag, 2000. \nwww.se-rwth.de/publications\nRecent standardization efforts of th e Unified Modeling Language (UML) [32]\noffer a chance to harness UML as nota tional basis for framework development\nprojects. UML is a multi-purpose language with many notational constructs, however,\nthe current standard UML does not provide appropriate cons tructs to model\nframeworks. The constructs provided by standard UML are not enough to assist\nframework development, as will be discussed during the rest of this paper. There is\nno indication in UML design diagrams what  are the variation points and what are\ntheir instantiation constraints. Fortunately, UML provides extension mechanisms that\nallow us to define appropriate labels and markings for the UML model elements.\nThis paper describes how to explicitly model framework variation points in UML\ndiagrams to describe the allowed structure and behavior of variation points. For this\npurpose, a number of extensions of standard UML are introduced. The extensions\nhave been defined mainly by applying the UML built-in extensibility mechanisms.\nThese extensions form a basis for a new UML profile [7, 33, 35], especially useful\nfor assisting framework development. This new profile is called UML-F.\nThe main goal of this paper is to introduce some key elements of UML-F and to\ndemonstrate their usefulness. It would be beyond the scope of this paper to introduce\nthe whole set of UML-F extensions. One of the main goals of defining UML-F was to\ntry to use a small set of extensions that capture the semantics of the most common\nkinds of variation points in OO frameworks.  In this way the designer can profit from\nhis or hers previous experience with UML and learn just a few new constructs to deal\nwith frameworks. This paper describes how the extensions have been defined\nallowing others extensions that deal with new kinds of variation points to be added to\nUML-F if needed. The current version of UML-F was refined based on the\nexperiences of a number of projects [11]. These experiences have shown how UML-F\ncan assist the framework development and instantiation activities to reduce\ndevelopment costs and at the same time increase the resulting quality of the delivered\nproducts. This paper presents a condensed version of a real-application case study to\nillustrate the benefits of UML-F and its supporting tools.\nThe rest of this paper is organized as follows: Section 2 outlines the UML\nextensions and discusses how they can be used to explicitly represent framework\nvariation points. It also shows how the extensions allow for the development of\nsupporting tools that can assist framework development and instantiation. Section 3\ndescribes a case study of real application of  UML-F, illustrating its benefits. Section\n4 discusses some related work. Section 5 c oncludes the paper and sketches our future\nresearch directions.\n2 The Proposed UML Extensions\nThis section introduces UML-F through an example. It summarizes the new\nextensions and presents a general descripti on of their semantics. It also presents a\ndescription of the UML extensibility mechanisms and how they have been applied in\nthe definition of UML-F. A description of tools that use UML-F design descriptions\nto automate framework development and instantiation is also presented.\n2.1 Motivating Example\nFigure 1 shows a student subsystem of a web-based education framework [12] in\nplain UML, where (a) represents a static view of the system (UML class diagram) and\n(b) provides a dynamic view (UML-like sequence diagram). The dynamic view\nillustrates the interaction between an instance of each of the two classes.\nThe showCourse() method is the one responsible for controlling the application\nflow: it calls selectCourse(), which allows the student to select the desired course,\ntipOfTheDay(), which shows a start-up tip, and finally showContent() to present the\ncontent of the selected course.\nMethod selectCourse() is the one responsible for selecting the course the student\nwants to attend. It is a variation point si nce it can have different implementations in\ndifferent web-based applications created within the framework. Different examples of\ncommon course selection mechanisms include: requiring a student login, showing the\nentire list of available courses or just the ones related to the student major, showing a\ncourse preview, and so on. There are numerous possibilities that depend on the\nframework use.\nShowCourse\n+showCourse()\n+selectCourse()\n+tipOfTheDay()\n +showContent()\nSelectCourse\n+selectCourse()\nselect\n1\nselect.selectCourse()\n(a)\naSelectCourseaShowCourse\n(b)\nshowCourse()\nselectCourse()\ntipOfTheDay()\nshowContent()\nselectCourse()\nFigure 1. UML representation of a framework web-based framework.\nFigure 1 shows selectCourse() as an abstract method of an abstract class\nSelectCourse. During framework instantiation, the framework users would have to\ncreate subclasses of SelectCourse and then provide a concre te implementation of the\nselectCourse() method. The problem with this representation is that there is no\nindication that selectCourse() is a variation point in the design diagrams. There is also\nno indication of how it should be instantia ted. Although the name of the abstract\nmethod selectCourse() is italicized this notation is not an indication of a variation\npoint, rather it indicates an abstract met hod which does not necessarily have to be a\nvariation point.\nMethod tipOfTheDay() is also a framework variation point. The reason is that\nsome applications created from the framework might want to show tips while others\nwill not do so. The framework should provide  only the methods and information that\nare useful for all the possible instantiated applications and the extra functionality\nshould be provided only in framework instances. Although this may seem a strong\nstatement, it is the ideal situation. The inclusion of methods like tipOfTheDay() could\nlead to a complex interface for ShowCourse, with many methods that would not be\nneeded by several framework instances. A good design principle in designing a\nframework its to try to keep it simple; extra functionality can always be placed in\ncomponent libraries.\nThe Actor class hierarchy is used to let ne w types of actors be defined depending\non the requirements of a given framework instance. The default actor types are\nstudents, teachers, and administrators, how ever, new types may be needed such as\nlibrarians, and secretaries. This means that applications created from the framework\nalways have at least three kinds of actors, students, teachers, and administrators, but\nseveral other actor types may be defi ned depending on the application specific\nrequirements. This design structure is presented in Figure 2.\nActor\n+getLogin()\n+getPassword()\nStudent Teacher Administrator\nFigure 2. Actor hierarchy.\nThe Actor class hierarchy also represents a variation point, since it allows the\ndefinition of new classes to fulfill the application specific requirements. However,\nthis is not properly indicated in the UML diagram presented in Figure 2. The\nframework developer should be able to indicate the variati on points in class\nhierarchies to facilitate the job of the framework user during the instantiation process.\nFortunately, UML provide s a constraint called Incomplete in its standard set of\nconstraints. Incomplete indicates that new classe s may be added to a given\ngeneralization relationship and was adopted as part of UML-F, as will be described in\nsubsection 2.3.\n2.2 UML Extensibility Mechanisms\nUML provides three language extension mech anisms: stereotypes, tagged values, and\nconstraints. Stereotypes allow the defin ition of extensions to the UML vocabulary,\ndenoted by «stereotype-name». Each model element (e.g. a class or a relationship)\ncan have a stereotype attached. In this case,  its meaning is specialized in a particular\nway suited for the target architecture or application domain. A number of possible\nuses of stereotypes have been classified in [2], but stereotypes are still a rather new\nconcept and still subject of ongoing research [7].\nTagged values are used to extend the properties of a modeling element with a\ncertain kind of information. For example, a version number or certain tool specific\ninformation may be attached to a modeling element. A tagged value is basically a pair\nconsisting of a name (the tag) and the associated value, written as “ {tag=value}”.\nBoth tag and value are usually strings only, although the value may have a special\ninterpretation, such as numbers or the Boolean values. In case of tags with Boolean\nvalues, UML 1.3 allows us to write “ {tag}” as shortcut for “ {tag=TRUE}”. This\nleads to the fancy situation that occasionally concepts a stereotype, e.g. «extensible»,\nand a tag, e.g. {extensible}, could be used for the same purpose. Since model\nelements can only have one stereotype, but an unlimited number of tagged values, it\nis often better to use tagged values in th is kind of situation. They provide more\nflexibility, e.g. freeing us of defining a new stereotype for each combination of tags\nthat may be attached to a model element.\nIn addition to the mentioned two UML extension mechanisms, there exist\nconstraints. Constraints may be used to  detail how a UML element may be treated.\nHowever, like the other two, constraints ha ve a rather weak semantics and therefore\ncan be used (and misused) in a powerful wa y. Constraints are today usually given\ninformally, or by a buzzword only. The {incomplete} constraint (Figure 3) could also\nbe defined as tagged value.\nWe expect that this mismatch among the extensibility mechanisms be improved in\nfuture UML versions. D’Souza, Sane, and Birchenough suggest that all three kinds of\nextensions should be stereotypes [7]. We argue in favor of this unification, but we\nwill retain the flexibility of tags and therefore will use tagged values for all purposes.\n2.3 UML-F Extensions\nThis subsection introduces UML-F illustrating its application to model the web-based\neducation framework [12]. Figure 3 models part of the framework representing and\nclassifying the variation points explicitly. The variation points are modeled by a\nnumber of tagged values with values of  Boolean type to extend the UML class\ndefinitions.\nIn this example the method selectCourse() is marked with the tagged value\n{variable} to indicate that its implementati on may vary depending on the framework\ninstantiation. The tagged value {variable} has the purpose to show the framework\nuser that selectCourse() must be implemented with a pplication specific behavior for\neach framework instance. Methods marked with {variable} are referred to as variable\nmethods.\nIn contrast to the previous tagged value, {extensible} is applied to classes. In this\nexample {extensible} is attached to the ShowCourse class, indicating that its interface\nmay be extended during the framework instantiation by adding new functionality, like\nmethods such as tipOfTheDay(). Please note that extension is optional, but not a must.\nAn important point here is that the diagram shown in Figure 3 is a result of a\ndesign activity, and therefore may implement ed in several different ways. The fact\nthat a class is marked as {extensible} tells us that its implementation will have to\nallow for the extension of its interface, since a given framework instance may want to\ndo so. However, it does not mean that the new methods have to be  added directly to\nthe class. The same holds for variable methods: the changes ma y be defined without\nchanging the method directly, but by the addition of new classes that provide\nappropriate impleme ntations for the method. Section 3 discusses some\nimplementation techniques th at may be applied to m odel variable methods and\nextensible classes.\nActor\n{static}\n+getLogin()\n+getPassword()Student Teacher Administrator\n{incomplete}\n{for all new methods}\nfSelectedCourse = \nfSelectedCourse@pre\nShowCourse\n{extensible, dynamic}\n+showCourse()\n+selectCourse() {variable,\n    dynamic}\n+showContent()\n{appl-class}\nLibrarian\nFigure 3. UML-F extended class diagram.\nFigure 3 uses the tag {incomplete} to indicate a third kind of variation point: an\nextensible interface. {Incomplete} is applied to a generali zation relationship, allowing\nnew subclasses to be defined by framework instances. In this example it indicates that\nnew subclasses of Actor may be provided to fulfill the requirements of applications\ncreated from the framework. Please note that {incomplete} is already provided by the\nUML as a constraint, with exactly the same meaning used here.\nThe tag {appl-class} is used to indicate a placeholder in the framework structure\nwhere application specific classes  may be or have already been added. It\ncomplements the definition of extensible interfaces: the generalization relationship\nbetween an extensible interface and an application class is always {incomplete}. Class\nLibrarian is an example of an application class . The {incomplete} tag allows the\nframework user to create as much application classes from a given extensible\ninterface during framework instantiation as needed. In contrast to the other two kinds\nof variation points, extensible interf aces have a direct mapping from design to\nimplementation since current OO progra mming languages provide  constructs for\nmodeling generalization relationships directly.\nTwo other Boolean value tags, called {dynamic} and {static}, complement the\nvariation point definition by indicating whether runtime instantiation is required.\nEach variation point can be marked either by the {dynamic} or by the {static} tag (but\nnot both). Variable methods are instantiated by providing the method implementation.\nExtensible classes are instantiated by the addition of new methods. Extensible\ninterfaces are instantiated by the creation of new application classes. Interpreted\nlanguages, such as Smalltalk and CL OS, give full support for runtime, or {dynamic},\ninstantiation. Java offers dynamic class loading and reflection that also can be used to\nallow dynamic instantiation of variation points. In the example shown in Figure 3 the\ntag {dynamic} is used because it is a user requirement to have dynamic\nreconfiguration for the variation points that deal with course exhibition. The tag\n{static} is used for the Actor extensible interface since new actor types do not need to\nbe defined during runtime. The tag {dynamic} implies that the implementation has\nsupport for runtime instantiation for the marked element. However, such a runtime\ninstantiation must not necessarily happen.\nThe note attached to the ShowCourse extensible class is an OCL [25, 33, 35]\nformula that defines that the class attribute fSelectedCourse shall not be changed by\nany of the new methods that may be added to the ShowCourse extensible class during\nframework instantiation. This kind of rest rictions over varia tion points is called\ninstantiation restrictions. To be able to describe certain OCL constraints for methods\nthat have neither been introduced nor named yet the tag {for all new methods} is used,\nindicating that this constraint is to hold for all new methods. This kind of tag strongly\nenhances the power of description of the design language, as it allows us to talk about\nmethods that have not even been named yet.\nAlthough it is beyond the scope of this pa per, Figure 4 shows a sequence diagram\nthat can be used to limit the possible behavior of a variation point. The sequence\ndiagram shows the main interaction pattern for a student selecting a course. As it may\nbe decided by actual implement ation, it is optional whether the student has to log in\nbefore he selects a course or whether the data is validated. This kind of option can be\nshown in sequence diagram by using {optional} tag, which indicates interactions that\nare not mandatory. In the area of sequence diagrams, there are many more\npossibilities to apply tags of this kind for similar purposes, such as determining\nalternatives, avoidance of interleaving, a nd so on. We expect useful and systematic\nsets of tags for sequence diagrams to come up in the near future. Figure 4 tells us that\na concrete method that instantiates selectCourse() must have the following behavior:\n1. It may display a login web page;\n2. It must show a web page for the selection of the desired course;\n3. It may validate the data by checking if th e login is valid, and whether the student\nis assigned to the course or not. This step is optional since there can be courses\nthat do not require student identification;\nThe extended class diagrams and the sequence diagrams complement each other\nproviding a rather useful specification of  variation points and their instantiation\nrestrictions. It is important that frame work developers provide documentation that\ndescribes what parts of the system shoul d be adapted to create a valid framework\ninstances. It is quite cumbersome that framework users today often need to browse\nthe framework code, which generally has complex and large class hierarchies to try to\nidentify the variation points. The diagrams and diagram extensions introduced in this\nexample address this problem. Section 3 will further discuss these ideas, showing\nhow UML-F can assist framework implementation and instantiation.\nstudentsaShowCourse courses\nselectCourse() loginPage()\nselectionPage()\nvalidateData()\n{optional}\n{optional}\nFigure 4. Sequence diagram for selectCourse().\n2.4 Language Description\nOnce the extensions are defined it is crucial to specify their exact meaning. As a side-\nnote, it is important to mention that in most languages (such as natural language, like\nEnglish), new vocabulary is explained through a definition using existing vocabulary.\nThis even holds for programming language s, like Java, where new classes and\nmethods are defined using existing cla sses, methods, and basic constructs.\nUnfortunately, UML 1.3 and high likely also UML 1.4 does not provide a clear path\nfor defining the precise semantics of new st ereotypes, tagged values, and constraints.\nTherefore, this section describes the m eanings of our newly introduced elements\nmainly informally. A formal approach to characterize a variant of these elements\nbased on set theory is presented in [11]. However, this formal definition of UML-F is\nnot presented here since its usefulness for the communication purposes is limited\n[33].\nThis paper demonstrates how UML-F deal s with three kinds of variation points:\nvariable methods, extensible classes, and extensible interfaces. Variable methods are\nmethods that have a well-defined signature, but whose implementation varies for each\ninstantiated application. In the example selectCourse() is a variable method.\nExtensible classes are classes that may have their interfaces extended during the\nframework instantiation. ShowCourse, for example, may require the addition of new\nmethods (like tipOfTheDay()) for each different  application. Extensible interfaces are\ninterfaces or abstract classes that allow the creation of concrete subclasses during the\nframework instantiation. The instantiation of this last kind of variation point takes\nplace through the creation of new classes, called application classes, which exist only\nin framework instances.\nIt should be clear that these three kinds of variation points have different purposes:\nin variable methods the method implementation varies, in ex tensible classes the class\ninterface varies, finally, in extensible interfaces the types in the system vary (new\napplication classes may be provided). All three kinds ma y either be static (do not\nrequire runtime instantiation) or dynamic (require runtime instantiation).\nThere are other kinds of variation points in  framework design, such as variation in\nstructure (attribute types for example). Coplien describes several kinds of variability\nproblems in his multi-paradigm design work [6]. They integrate well into UML-F\nusing similar principles to the ones described in this paper. To avoid the explosion of\nthe number of extensions and to keep the presented part of UML-F feasible this paper\nfocus on the most important kinds of variation points.\nUML diagrams are extended by the tags {variable}, {extensible}, {incomplete},\n{appl-class}, {static},  and {dynamic}. The first  two represent variable methods and\nextensible classes, respectively. {Static} and {dynamic} are used to classify them\nregarding to their runtime requirements. The {incomplete} tag (in UML 1.3 known as\nconstraint) has been adapted to iden tify extensible interfaces. The keywords\n{extensible}, {variable}, and {incomplete}, indicate what are the variation points and\ntheir exact meaning. The {appl-class} stereotype indicates placeholders for classes\nthat are part of instantiated applications only.\nOCL specifications [25, 33, 35] may be  written on notes as in standard UML,\nhowever, they have an enhanced meaning if the notes are attached to variation points.\nIn the case of variable methods, it means that all method implementations that may be\ndefined during instantiation should follow the specification. If an OCL constraint is\nattached to an extensible class, the special tag {for all new methods} is useful to\ndescribe the behavior of methods that do not  even have a name yet. This tag indicates\nthat the constraint applies to all methods  that might be added during instantiation.\nSimilarly, if attached to an extensible in terface, the OCL constraint applies to all\nmethods that can be overridden or added to each application class.\nLet us also mention the tag {optional}. Here, it extends sequence diagrams to\nindicate that certain interaction patterns are not obliged to occur. These sequence\ndiagrams have proven useful to  be applied to all kinds of  variation points. Generally,\nthey are used to describe a pattern behavior that should be followed by the variation\npoint instances, as shown in Figure 4. OCL specifications, on the other hand, are\ngenerally used to specify invariants that  should be satisfied by the variation point\ninstances, as shown in Figure 3. Thus, sequence diagrams and OCL constraints\ncomplement each other in constraining the possible instantiations of variation points,\nand may therefore be used together.\nTable 1 summarizes the new UML-F elements and informally defines their\nsemantics.\n2.5 Tool Support\nThis subsection shows how tools that be nefit from the UML-F design diagrams may\nbe defined to assist both framework de velopment and instantiation. The tools\nsuggested here have a prototypical imple mentation using PROLOG. However, many\ncurrently available UML case tools give support reasoning about tagged values and\ncould be adapted to work with UML-F. Th is subsection gives information to allow\nthe customization of UML case tools for working with OO frameworks.\nTable 1. Summary of the new elements and their meanings\nName of\nextension\nType of\nextension\nApplies to\nnotational\nelement of\nUML\nDescription\n{appl-class} Boolean\nTag\nClass Classes that exist only in\nframework instances. New\napplication classe s may be defined\nduring the framework instantiation.\n{variable} Boolean\nTag\nMethod The method must be implemented\nduring the framework instantiation.\n{extensible} Boolean\nTag\nClass The class interface depends on the\nframework instantiation: new\nmethods may be defined to extend\nthe class functionality.\n{static} Boolean\nTag\nExtensible\nInterface,\nVariable Method,\nand Extensible\nClass.\nThe variation point does not require\nruntime instantiation. The missing\ninformation must be provided at\ncompile time.\n{dynamic} Boolean\nTag\nExtensible\nInterface,\nVariable Method,\nand Extensible\nClass.\nThe variation point requires\nruntime instantiation. The missing\ninformation may be provided only\nduring runtime.\n{incomplete} Boolean\nTag\nGeneralization\nand Realization\nNew subclasses ma y be added in\nthis generalization or realization\nrelationship.\n{for all new\nmethods}\nBoolean\nTag\nOCL Constraint Indicates th at the OCL constraint is\nmeant to hold for all newly\nintroduced methods.\n{optional} Boolean\nTag\nEvents Indicates that a given event is\noptional. It is useful for specifying\na template behavior that should be\nfollowed by the instantited\nvariation point.\nAssisting Framework Development.  Standard OO design languages do not provide\nconstructs for representing flexibility and variability requirements. UML-F addresses\nthis problem representing variation points as first-class citizens thus making the\nframework intentions more explicit. The new language elements are not concerned\nwith how to implement the variability and extensibility aspects of the framework, but\nfocus on representation at design level. Consequently, the diagrams are more abstract\n(and more concise) than standard OO di agrams. Unfortunately some of the new\ndesign elements cannot be directly mapped into existing OO programming languages.\nExtensible interfaces can be directly implemented through standard inheritance.\nAlthough dynamic extensible interfaces are not supported in compiled languages such\nas C++, they may be simulated thr ough dynamic linking (Microsoft Windows DLLs,\nfor example). Variable methods and extens ible classes, on the other hand, cannot be\ndirectly implemented, since standard  OO programming languages do not provide\nappropriate constructs to model them.\nTo bridge this design-implementation gap, several techniques may be used. Design\npatterns are a possible solution, since several patterns provide solutions for flexibility\nand extensibility problems and are based onl y on extensible interfaces. Thus, design\npatterns may be used to transform variab le methods and exte nsible classes into\nextensible interface variation points. Figure 5 illustrates the use of the Strategy design\npattern [15] to implement this mapping. Classes ShowCourse and SelectStrategy are\nidentified with the tags {separation, template} and {separation, hook} to indicate the\nroles they play in the pattern. Strategy is based on the Separation meta-pattern [28],\nin which a template class is responsible  for invoking the variable method in the hook\nclass. The use of tags that indicate meta-pattern roles complement the UML-F\ndescription for variation points implemented  by design patterns, further clarifying the\ndesign. A similar solution for identifying design diagrams with pattern roles is\ndescribed in [30].\nShowCourse\n{separation, template}\n+showCourse()\n+selectCourse()\n+showContent()\nSelectStrategy\n{separation, hook}\n+select() {dynamic}\nselect\n1\nConcreteSelect\n{appl-class}\n+select()\nShowCourse\n+showCourse()\n+selectCourse()\n{variable,\ndynamic}\n+showContent()\nFramework\ndesign\nFramework\nimplementation\n{incomplete}\nFigure 5. Transforming variable methods into extension interface variation points.\nThe transformations used to map variab le methods and exte nsible classes into\nimplementation level constructs must be  behavior-preserving, since the system\nfunctionality is independent of the implementation technique used to model the\nvariation points.\nA code generation tool can be used to automate design to implementation trans-\nformations. It is responsible for mapping the new design elements of UML-F into\nappropriate implementa tion level structures. More specifically, it is responsible for\neliminating the variable methods and ex tensible classes from the design. This\nmapping is based on meta-artifacts that de scribe the transformations. These meta-\nartifacts are called implementation models. It is an imperative to allow the definition\nof new implementation models  for variation points, so that different styles of\ntranslation are possible.\nThe transformation illustrated in Figure 5 is an example of a mapping supported\nby the code generation  tool. The implementation model that supports this\ntransformation describes how dynamic variable methods are modeled by the Strategy\ndesign pattern. Figure 6 illustrates the code for this implementation model, which\nsearches for all variable methods in the design diagrams and applies Strategy to them.\nThe implementation transformations (illust rated in Figure 6) preserve the design\nstructure described in Project and create NewProject to store the generated\nframework. All the design elements that are not transformed, the kernel elements and\nthe extensible interfaces, are copied from Project to NewProject. The variable\nmethods and extensible classes are transf ormed in the way described by the selected\nimplementation model.\napplyStrategy(Project, NewProject) :-\n[...]\nforall(variableMethod(Project, Class, Method, _),\nstrategy(Project, NewProject, Class, Method)),\n[...]\nstrategy(Project, NewProject, Class, Method) :-\nconcat(Method, ’Strategy’, NewClass),\ncreateExtensibleInterface(NewProject, NewClass, dynamic),\ncreateMethod(NewProject, NewClass, Method, public, none, abstract),\ncreateAggregation(NewProject, Class, NewClass, strategy),\n[...]\nSearches for\nvariable\nmethods\nUses strategy\nto model them\nFigure 6. Strategy implementation model.\nEach valid implementation model artifact has to define at least four transformations:\n(static and dynamic) va riable methods and (static a nd dynamic) extensible classes.\nExamples of implementation models that have been successfully used to assist\nframework implementation include different combinations of design patterns, meta-\nprogramming [21], aspect-oriented programming (AOP) [20], and subject-oriented\nprogramming (SOP) [17], as described in [11]. The case study section also describes\nsome other mappings.\nThe selection of the most appropriate t echnique to be used model each variation\npoint is a creative task and cannot be completely automated. However, UML-F\ndiagrams and the set of implementation models available for each kind of variation\npoint may help the framework designer to narrow his or hers search for appropriate\nimplementations. Moreover, the code generation tool automatically applies the\ntransformation once the implementation model has been selected, making the\nmapping from design to implementation less error prone.\nSome UML case tools, such as Rational Rose (http://www.rational.com), allow the\ncustomization of how code is generated from the design diagrams. Therefore, it is\npossible to specify how code should be generated for the new UML-F elements.\nAssisting Framework Instantiation. During the framework instantiation, application\nclasses must be provided to complete the definition of the extensible interface\nvariation points (at this point this is the only kind of variation points in the system,\ngiven that the other two have already b een eliminated during implementation). Figure\n7 illustrates a framework instantiation. Afte r the instantiation all extensible interfaces\ndisappear from the design, since the {incomplete} generalizations become “complete.”\nIn this example the variation point was in stantiated by just one concrete application\nclass, SimpleSelect, which is marked by the {c-hook} tag to indicate that it plays the\nrole of a concrete hook. In a general case,  however, several application classes may\nbe provided for each extensible interface.\nAn instantiation tool can be used to a ssist the application developer to create\napplications from the framework. The tool  knows what are the exact procedures to\ninstantiate extensible interfaces: it has to create a new subclass, ask for the\nimplementation of each of the interface met hods, and ask for the definition (signature\nand implementation) for each new method that might be added, if any. The tool\nprompts the application devel oper about all the required in formation to complete the\nmissing information for each variation point in the framework structure.\nNote that the tags that indicate the meta pattern roles are useful just for enhancing\nthe design understating, and are not processed by the implementation and\ninstantiation tools.\nDepending on the implementation model selected, different instantiation tasks may\nbe required for the same variation point, as will be illustrated in Section 3. UML-F\ndescriptions can be seen as structured cookbooks [22] that precisely inform were\napplication specific code s hould be added. The instantiation tool is a wizard that\nassists the execution of these cookbooks. Once again the code generation part of\nstandard UML case tools may be adapted to  mark the points in which code should be\nadded by using the information provided by the extensible interface tags.\n3 Case Study\nThis section details the implementation and instantiation of the web-education\nframework modeled in Figure 3. It starts  from the UML-F specification, derives the\nfinal framework implementation, and shows how it may be instantiated. The benefits\nof UML-F and its supporting tools are discussed throughout the example.\n3.1 Framework Implementation\nLet us consider that the only variation poi nts of the framework are the ones presented\nin Figure 3. Since all the variation points have been identified and marked in the\nUML-F design diagrams, the next step is  to provide implementation solutions to\nmodel them. As discussed before, extensible interfaces and the framework kernel\n(modeled only by standard UM L constructs) have straightforward mappings into OO\nprogramming languages. Therefore the framework designer focus during the\nimplementation phase should be on how to model variab le methods and extensible\nclasses. In this example two varia tion points have to be examined: the selectCourse()\nvariable method and the ShowCourse extensible class.\nShowCourse\n{separation, template}\n+showCourse()\n+selectCourse()\n+showContent()\nSelectStrategy\n{separation, hook}\n+select() {dynamic}\nselect\n1\nConcreteSelect\n{appl-class}\n+select()\nFramework\nimplementation\n{incomplete}\nShowCourse\n{separation, template}\n+showCourse()\n+selectCourse()\n+showContent()\nSelectStrategy\n{separation, hook}\n+select()\nselect\n1\nSimpleSelect\n{separation, c-hook}\n+select()\nApplication\nFigure 7. Instantiation example.\nThe designer has to select an appropriate technique based on his or hers experience. If\na supporting tool with a set of implementati on models is available, the analysis of\nthese models may facilitate this task. One of the models available in the code\ngeneration tool is the use of the Strate gy design pattern [15]  to implement dynamic\nvariable methods and a slightly changed ve rsion of the Separati on meta-pattern [28],\nwhich allows the invocation zero or more hook methods, to implement dynamic\nextensible classes. Since the transformations are automatically applied by the tool let\nus try this solution and see what happens. The resulting design is shown in Figure 8.\nThis solution worked quite well. The solution for extending the ShowCourse\ninterface allows the addition of new met hods without directly changing the class\ninterface. It allows an instance application to define zero or more methods that will be\ninvoked before the actual content of the course is displayed, and that is the expected\nbehavior. An important point to make is that the instantiation restriction specified by\nthe OCL constraint in Figure 3 is automatically assured by this solution, since the\nnew methods do not have access to the fSelectCourse attribute that is private to\nShowCourse.\nIn the case of selectCourse(), however, the Strategy solution does not guarantee\nthat the behavior specified by the sequence diagram in Figure 4 will be followed.\nStrategy is a white-box pattern since it allows the definition of any behavior for the\nhook method. The verification of this kind of instantiation restrictions is not an easy\ntask (and is generally an undecidable one),  however there are some implementation\nsolutions that may be more restrictive, or more black-box.\nFigure 8. A pattern-based implementation.\nA solution that might be more appropriate for selectCourse() is the definition of a\nmeta-object protocol (MOP) [18]. MOPs allow meta-level concepts to be dynamically\ndefined in terms of base-level ones. Thus , the use of MOP may be a good alternative\nsince it is a more restrictive solution than the Strategy pattern: the possible\ninstantiations are just the ones defined by the protocol. Figure 9 illustrates the use of\nMOP for this example. Whenever instances of the SelectMOP class are created a set\nof Boolean parameters that complete th e variation point be havior have to be\nprovided: login (TRUE if login is required), major (TRUE if a student can attend\nonly the courses related to his or hers major), and validate (TRUE if it is required that\nthe student have to be assi gned to be able to attend th e course). The combination of\nthese parameters provides all the possible instantiations allowed by the MOP. Note\nthat this solution is much more restrictive than the Strategy solution, but it has the\nadvantage that it always preserves the instantiation restrictions specified in the\nsequence diagram.\nShowCourse\n{separation, template}\n-fSelectedCourse\n+void showCourse()\n+int selectCourse()\n+showContent(int)\nSelectStrategy\n{separation, hook}\n+int select()\n{dynamic}\nselect\n1\nConcreteSelect\n{appl-class}\n+int select()\nExtensionMethods\n{separation, hook}\n+void op() {dynamic}\nextend\n*\nConcreteExtension\n{appl-class}\n+void op()\nfSelectedCourse = selectCourse();\nforall (extend) { extend.op();}\nshowContent(fSelectedCourse);\n{incomplete}{incomplete}\nShowCourse\n{separation, template}\n-fSelectedCourse\n+void showCourse()\n+int selectCourse()\n+showContent(int)\nSelectMOP\n+ void selectMOP(Boolean\nlogin, Boolean major, Boolean\nvalidate)\n+int select()\nselect\n1\nExtensionMethods\n{separation, hook}\n+void op() {dynamic}\nextend\n*\nConcreteExtension\n{appl-class}\n+ void op()\nfSelectedCourse = selectCourse(l, m, v);\nforall (extend) { extend.op();}\nshowContent(fSelectedCourse);\n{incomplete}\nFigure 9. Using MOP to model selectCourse().\nThe implementation of MOPs cannot be auto mated by the code generation tool, since\neach MOP is specific for a given variation point. However, the UML-F instantiation\nrestrictions provide a good documentation th at can be used by the MOP developers.\nIn this example the parameters login and validate can be directly derived from Figure\n4. In general MOPs may require objets more complex than Boolean ones as\nparameters and reflection may be required in their implementation.\nNote that the runtime constraints {static} and {dynamic} play a crucial role during\nframework development. In this example,  if the variation points were defined as\n{static} a much simpler design solution based on the Unification meta-pattern [28]\ncould be used for both cases. In Unifi cation-based patterns the template and hook\nmethods belong to the same class, leadi ng to a less flexible but simpler design\nsolution.\n3.2 Framework Instantiation\nDuring instantiation the variation points missing information have to be filled with\napplication specific code. Since the variable methods and extensible classes have been\neliminated during implementation, only extensible classes are left to be instantiated\nby the application developers.\nTools such as the instantiation tool may facilitate this task by identifying all the\npoints in which code has to be written. However, even if no tools are available, the\nUML-F diagrams make this task very straightforward since all the extensible\ninterfaces and their corresponding instantiation restrictions are marked in the\ndiagrams.\nFigure 10 shows an example of applicati on created from the framework defined in\nFigure 8. Application classes are provided to complete the definition of the two\nvariation points. Note that if the MOP solution had been adopted the selectCourse()\nvariation point would not require new application classes, since MOPs are completely\ninstantiated during runtime by parametrization. This illustrates that different\nimplementation models applied to the sa me variation point may demand different\ninstantiation procedures.\nShowCourse\n{separation, template}\n-fSelectedCourse\n+void showCourse()\n+int selectCourse()\n+showContent(int)\nSelectStrategy\n{separation, hook}\n+int select()\nselect\n1\nSimpleSelect\n{separation, c-hook}\nExtensionMethods\n{separation, hook}\n+void op() {dynamic}\nextend\n* LoginSelect\n{separation, c-hook}\nTipOfDay\n{separation, c-hook}\nAnnouncement\n{separation, c-hook}\nFigure 10. An application created from the framework.\n4 Related Work\nThis section describes some of the cu rrent design techniques used to model\nframeworks, and relates them to UML-F. It  shows that currently proposed constructs\nused to represent framework variati on points have not adequately met our\nexpectations.\nEarly OO design methods, like OMT [31], as well as the current UML 1.3, provide\na number of diagrams for structure, beha vior, and interaction. Different OO design\nnotations include different artifacts, such as the representation of object\nresponsibilities as CRC cards [1, 37]. However none of  these artifacts has explicit\nsupport for the representation of the variation points of a framework.\nUML represents design patterns as collabor ations (or mechanisms) and provides a\nway of modeling framework adaptation through the binding stereotype [32].\nHowever, framework instantiation usually is more complex than simply assigning\nconcrete classes to roles: variation points might have interdependencies, might be\noptional, and so on. Catalysis uses th e UML notation and proposes a design method\nbased on frameworks and components [8]. Frameworks are treated in Catalysis as\ncollaborations that allow substitution. However, as discussed in the paper, OO\napplication frameworks may require different instantiation mechanisms. Therefore,\nCatalysis and standard UML only partly address the problem s identified in this paper\ndue to a lack of support for explicit marking variation points and their semantics.\nDesign patterns [4, 15, 36] are usually described using standard OO diagrams.\nSince various design patterns provide solutions to variability and extensibility\nproblems [15] they define a common vocabulary to talk about these concepts [36] and\nmay enhance the understanding of frame work designs. Some times design pattern\nnames are used as part of the class names allowing the framework user to identify\nvariation points through the used names. Ho wever, in a typical framework design a\nsingle variation point class can participat e in various design patterns. Then the\napproach of using design pattern names as class names becomes obfuscated. One\npossible solution for this problem is the use of role-based modeling technique, as\nshown in [30].\nMeta-level programming [21], which can be seen as an architectural pattern [4],\nprovides a good design solution for allowi ng runtime system reconfiguration.\nTherefore, the use of meta-level progra mming is a useful technique for modeling\nvariation points that require runtime instan tiation, and (with appr opriate conventions)\nit may facilitate the identification of variation points in the framework structure. The\ncase study shown in section 3 has shown that both design patterns and meta-level\nprogramming can be used in conjunction w ith UML-F, during the implementation of\nvariation points.\nThe use of role diagrams to represent object collaboration is a promising field in\nOO design research [5]. Riehle and Gross propose an extension of the OOram\nmethodology [29] to facilitate framework design and documentation [30]. His work\nproposes a solution for an explicit division of the design, highlighting the interaction\nof the framework with its clients. The use of roles does simplify the modeling of\npatterns that require several object co llaborations and provides a solution for\ndocumenting classes that participate in  several design patterns. However, no\ndistinction is made between the kernel a nd variation point elements. This problem is\nhandled using design patterns: if the frame work user knows what patterns were used\nto model each of the variation points he or she can have an intuition on how the\nframework should be instantiated. On the ot her hand, if the pattern selections are not\nexplicitly represented, the identification of the variation points becomes again\ndifficult. Another disadvantage of this approach is the solution for modeling\nunforeseen extensions proposed in [30], which may lead to a very tangled design.\nAlthough it can be a good solution it should ha ve a more concise representation at\ndesign level. This paper has shown how to use roles to complement the description of\nvariation points implemented by design patterns.\nContracts [18, 19] and adaptable plug-and-play components (APPCs) [24] provide\nlinguistic constructs for imp lementing collaboration-base d (or role-based) diagrams\nin a straightforward manner. They may be used to implement variation points since\nthey represent instantiation as first-class citizens. However, these concepts are still\nquite new and their use for implementing frameworks needs further investigation.\nAlso Lieberherr and the researchers of the Demeter Project [24] have developed a set\nof concepts and tools to help and evalua te OO design that can be used to enhance\nframework development.\nThe Hook tool [13, 14] uses an extended version of UML in which the variation\npoint classes are represented in gray. This differentiation between kernel and\nvariation points helps framework design a nd instantiation, but it does not solve the\nproblem completely. Framework designers still have to provide the solutions for\nmodeling each variation point without any tool support. A good point of this\napproach is that instantiation constraints are treated as first-class citizens in the\ndefinition of hooks.\nSeveral design pattern tools [3, 9, 10, 23]  have been proposed to facilitate the\ndefinition of design patterns, to allow th e incorporation of patterns into specific\nprojects, to instantiate design descriptions, and to generate code. However, they leave\nthe selection of the most adequate pattern to model each variation point in the hands\nof the framework designer. Although this is  obviously a creative task, if variation\npoints are modeled during design tools that a ssist the systematization of the selection\nof the best modeling technique for each  variation point ma y be constructed,\nsimplifying the job of the framework designer.\n5 Conclusions and Future Work\nThe standardization of the UML modeling language makes it attractive as a design\nnotation for modeling OO frameworks. This  paper shows that UML today lacks\nconstructs to explicitly represent and classify framework variation points and their\ninstantiation restrictions. The proposed ex tensions to the UML 1.3 design language\naddress this problem representing varia tion points through appropriate markings.\nThey make the framework design more e xplicit and therefore easier to understand\nand instantiate. The extensions have b een defined by applying the UML extension\nmechanisms.\nAlthough the extensions described in th is paper have been used to model\nframeworks successfully [11], they are neither complete nor the only ones that may\nbe applied to framework de velopment. This paper discusses how to improve UML-F\nto provide additional extensions and a syst ematic approach to apply these extensions\nto different kinds of UML diagrams. Furthermore, it is of interest to understand that\nrelationship of UML-F with similar kinds of  variability problems, such as presented\nin [6].\nThe new UML-F elements are not concerned with how to implement the\nvariability and extensibility aspects of the framework, but just with how to\nappropriately represent them at the desi gn level. Furthermore, through use of this\nkind of extensions it is more likely that the framework user will not have to go into\nthe detailed internals of a framework, being able to use it in a more black-box\nmanner. Consequently, the diagrams gi ve us a more abstract and concise\nrepresentation of a framework, when compared to standard OOADM diagrams.\nThe most important claims of this pape r is that frameworks should be modeled\nthrough appropriate design constructs that allow the representation of variation points\nand their intended behavior. The extended class diagrams and sequence diagrams\nfacilitate the definition of adequate documentation, which may be used to assist the\nframework developer in modeling the vari ation points and the framework user in\nidentifying these points during instantiation.\nThe extensions allow for the definiti on of supporting tools that may partially\nautomate the development and instantiation activities. Appropriate tool assistance\nshould also lead to a better time-to-mark et, reduced software costs, and higher\nsoftware quality.\nReferences\n1. D. Bellin and S. Simone, The CRC Card Book, Addison Wesley Longman, 1997.\n2. S. Berner, M. Glinz, S. Joos, “A Classification of Stereotypes for Object-Oriented\nModeling Languages”, UML’99, LNCS 1723, Springer-Verlag, 249-264, 1999.\n3. F. Budinsky, M. Finnie, J. Vlissides, and P. Yu, “Automatic Code Generation from Design\nPatterns”, Object Technology, 35(2), 1996.\n4. F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, Pattern-Oriented\nSoftware Architecture: A System of Patterns, John Wiley & Sons, 1996.\n5. J. Coplien, “Broadening beyond objects to patterns and other paradigms”, ACM Computing\nSurveys, 28(4es), 152, 1996.\n6. J. Coplien, Multi-Paradigm Design for C++, Addison-Wesley, 1999.\n7. D. D’Souza, A. Sane, and A. Birchenough, “First-class Extensibility for UML – Packaging\nof Profiles, Stereotypes, Patterns”, UML’99, LNCS 1723, Springer-Verlag, 265-277, 1999.\n8. D. D’Souza and A. Wills, Objects, Components, and Frameworks with UML: The\nCatalysis Approach, Addison-Wesley, 1997.\n9. A. Eden, J. Gil, and A. Yehudai, “Precise Specification and Automatic Applicat ion of\nDesign Patterns”, ASE’97, IEEE Press, 1997.\n10. G. Florijin, M. Meijers, P. van Winsen, “Tool S upport for Object-Oriented Patterns”,\nECOOP’97, LNCS 1241, Springer-Verlag, 472-495, 1997.\n11. M. Fontoura, “A Systematic Approach for Framework Development“, Ph.D. Thesis,\nComputer Science Department, Pontifical Catholic University of Rio de Janeiro,  Brazil\n(PUC-Rio), 1999.\n12. M. Fontoura, L. Moura, S. Crespo, and C. Lucena, “ALADIN: An Architecture for\nLearningware Applications Design and Instantiation”, Technical Report MCC34/98,\nComputer Science Department, Computer Science Department, Pontifical Cat holic\nUniversity of Rio de Janeiro, Brazil (PUC-Rio), 1998.\n13. G. Froehlich, H. Hoover, L. Liu, and P. Sorenson, “Hooking into Object-Oriented\nApplication Frameworks”, ICSE’97, IEEE Press, 491-501, 1997.\n14. G. Froehlich, H. Hoover, L. Liu, and P. Sorenson, “Requirements for a Hooks Tool”,\n(http://www.cs.ualberta.ca/~softeng/papers/papers.htm).\n15. E. Gamma, R. Helm, R. E. Johnson, and J. Vlissides, Design Patterns, Elements of\nReusable Object-Oriented Software, Addison-Wesley, 1995.\n16. D. Hamu and M. Fayad, ”Achieving Bottom-Line Improvements with Enterprise\nFrameworks“, Communications of ACM, 41(8), 110-113, 1998.\n17. W. Harrison and H. Ossher, “Subject-Oriented Programming (A Critique of Pure\nObjects)”, OOPSLA’93, ACM Press, 411-428, 1993.\n18. R. Helm, I. Holland, and D. Gangopadhyay, “Contracts: Specifying Behavioral\nComposition in Object-Oriented Systems”, OOPSLA/ECOOP’98, Norman Meyrowitz (ed.),\nACM Press, 169-180, 1990.\n19. I. Holland, “The Design and Representation of Object-Oriented Components”, Ph.D.\nDissertation, Computer Science Department, Northeastern University, 1993.\n20. G. Kiczales, J. Lamping, A. Me ndhekar, C. Maeda, C. Lopes, J. Loingtier, and J. Irwin,\n“Aspect-Oriented Programming”, ECOOP’96, LNCS 1241, 220-242, 1997.\n21. G. Kiczales, J. des Rivieres, and D. Bobrow, The Art of Meta-object Protocol , MIT Press,\n1991.\n22. G. Krasner and S. Pope, “A Cookbook for Using the Model-View-Controller User\nInterface Paradigm in Smalltalk-80”, Journal of Object-Oriented Programming, 1(3), 26-49,\n1988.\n23. T. Meijler, S. Demeyer, and R. Engel, “Making Design Patterns Explicit in FACE – A\nFramework Adaptative Composition Environment”, ESEC’97, LNCS 1301, Springer-Verlag,\n94-111, 1997.\n24. M. Mezini and K. Lieberherr, “Adaptative Plug-and-Play Components for Evolutionary\nSoftware Development”, OOPSLA’98, ACM Press, 97-116, 1998.\n25. OMG, “OMG Unified Modeling Language Specification V.1.3”, 1999\n(http://www.rational.com/uml).\n26. D. Parnas, P. Clements, and D. Weiss, “The Modular Structure of Complex S ystems”,\nIEEE Transactions on Software Engineering, SE-11, 259-266, 1985.\n27. W. Pree, Design Patterns for Object-Oriented Software Development , Addison-Wesley,\n1995.\n28. W. Pree, Framework Patterns, Sigs Management Briefings, 1996.\n29. T. Reenskaug, P. Wold, and O. Lehne, Working with objects, Manning, 1996.\n30. D. Riehle and T. Gross, “Role Model Based Framework Design and Integration”,\nOOPSLA’98, ACM Press, 117-133, 1998.\n31. J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, Object-Oriented\nModeling and Design, Prentice Hall, Englewood Clifs, 1994.\n32. J. Rumbaugh, I. Jacobson, and G. Booch, The Unified Modeling L anguage Reference\nManual, Addison-Wesley, 1998.\n33. B. Rumpe, A Note on Semantics , Proceedings of Sec ond ECOOP Workshop on Precise\nBehavioral Semantics, 1998.\n34. S. Cook, A. Kleppe, R. Mitchell, B. Rumpe, J. Warmer, and A. W ills, The Amsterdam\nManifesto on OCL, Technical Report,  Institute for Software Engineering, Technische\nUniversität München, 1999.\n35. S. Cook, A. Kleppe, R. Mitchell, B. Rumpe, J. Warmer, A. W ills, Defining UML Family\nMembers with Prefaces, TOOLS Pacific’99, IEEE Press, 1999.\n36. J. Vlissides, Pattern Hatching: Design Patterns Applied , Software Patterns Series,\nAddison-Wesley, 1998.\n37. R. Wirfs-Brock, B. Wilkerson, and L. Wiener, Designing Object-Oriented Software ,\nPrentice Hall, 1990.",
  "topic": "Unified Modeling Language",
  "concepts": [
    {
      "name": "Unified Modeling Language",
      "score": 0.8538951873779297
    },
    {
      "name": "Applications of UML",
      "score": 0.7356231212615967
    },
    {
      "name": "Object Constraint Language",
      "score": 0.7344908714294434
    },
    {
      "name": "Computer science",
      "score": 0.679479718208313
    },
    {
      "name": "UML tool",
      "score": 0.6712603569030762
    },
    {
      "name": "Programming language",
      "score": 0.5890874266624451
    },
    {
      "name": "Object-oriented programming",
      "score": 0.4960967004299164
    },
    {
      "name": "Software engineering",
      "score": 0.40564507246017456
    },
    {
      "name": "Software",
      "score": 0.08999469876289368
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I20089843",
      "name": "Princeton University",
      "country": "US"
    },
    {
      "id": "https://openalex.org/I174004417",
      "name": "Munich University of Applied Sciences",
      "country": "DE"
    }
  ],
  "cited_by": 74
}