{
  "title": "L-Py: An L-System Simulation Framework for Modeling Plant Architecture Development Based on a Dynamic Language",
  "url": "https://openalex.org/W1974837692",
  "year": 2012,
  "authors": [
    {
      "id": "https://openalex.org/A1903835757",
      "name": "Frédéric Boudon",
      "affiliations": [
        "Centre de Coopération Internationale en Recherche Agronomique pour le Développement",
        "Centre Occitanie-Montpellier",
        "Institut national de recherche en informatique et en automatique"
      ]
    },
    {
      "id": "https://openalex.org/A1242223925",
      "name": "Christophe Pradal",
      "affiliations": [
        "Institut national de recherche en informatique et en automatique",
        "Centre Occitanie-Montpellier",
        "Centre de Coopération Internationale en Recherche Agronomique pour le Développement"
      ]
    },
    {
      "id": "https://openalex.org/A3174964184",
      "name": "Thomas Cokelaer",
      "affiliations": [
        "Institut national de recherche en informatique et en automatique"
      ]
    },
    {
      "id": "https://openalex.org/A106782339",
      "name": "Przemyslaw Prusinkiewicz",
      "affiliations": [
        "University of Calgary"
      ]
    },
    {
      "id": "https://openalex.org/A1906547112",
      "name": "Christophe Godin",
      "affiliations": [
        "Institut national de recherche en informatique et en automatique"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2026132111",
    "https://openalex.org/W2104101784",
    "https://openalex.org/W6683004204",
    "https://openalex.org/W1560255182",
    "https://openalex.org/W1987513978",
    "https://openalex.org/W1975350739",
    "https://openalex.org/W1994455767",
    "https://openalex.org/W3149368675",
    "https://openalex.org/W2160734993",
    "https://openalex.org/W6843712861",
    "https://openalex.org/W6669710031",
    "https://openalex.org/W1974687455",
    "https://openalex.org/W2122138255",
    "https://openalex.org/W2230729400",
    "https://openalex.org/W6674746544",
    "https://openalex.org/W2102416538",
    "https://openalex.org/W7055776285",
    "https://openalex.org/W2096612760",
    "https://openalex.org/W2179604594",
    "https://openalex.org/W6659784011",
    "https://openalex.org/W6601748281",
    "https://openalex.org/W2016050712",
    "https://openalex.org/W2110001365",
    "https://openalex.org/W2095380991",
    "https://openalex.org/W2168775768",
    "https://openalex.org/W6632393774",
    "https://openalex.org/W1516264462",
    "https://openalex.org/W2591220581",
    "https://openalex.org/W6635399820",
    "https://openalex.org/W1504295561",
    "https://openalex.org/W6697230275",
    "https://openalex.org/W6650761972",
    "https://openalex.org/W2077723429",
    "https://openalex.org/W1968889139",
    "https://openalex.org/W7037478155",
    "https://openalex.org/W2122000245",
    "https://openalex.org/W2097696574",
    "https://openalex.org/W4298271096",
    "https://openalex.org/W1593304353",
    "https://openalex.org/W1999187555",
    "https://openalex.org/W2000690667",
    "https://openalex.org/W1966818077",
    "https://openalex.org/W1483318950",
    "https://openalex.org/W4298859750",
    "https://openalex.org/W2093205068",
    "https://openalex.org/W4300474370",
    "https://openalex.org/W43923756",
    "https://openalex.org/W2155196493",
    "https://openalex.org/W2611752027",
    "https://openalex.org/W1580895306",
    "https://openalex.org/W2177486224",
    "https://openalex.org/W2070386655",
    "https://openalex.org/W2103055948",
    "https://openalex.org/W72920030",
    "https://openalex.org/W2075957961",
    "https://openalex.org/W2222534196",
    "https://openalex.org/W2010769244",
    "https://openalex.org/W4298840152",
    "https://openalex.org/W2296148643",
    "https://openalex.org/W1968427680",
    "https://openalex.org/W2036697911",
    "https://openalex.org/W1539916920"
  ],
  "abstract": "The study of plant development requires increasingly powerful modeling tools to help understand and simulate the growth and functioning of plants. In the last decade, the formalism of L-systems has emerged as a major paradigm for modeling plant development. Previous implementations of this formalism were made based on static languages, i.e., languages that require explicit definition of variable types before using them. These languages are often efficient but involve quite a lot of syntactic overhead, thus restricting the flexibility of use for modelers. In this work, we present an adaptation of L-systems to the Python language, a popular and powerful open-license dynamic language. We show that the use of dynamic language properties makes it possible to enhance the development of plant growth models: (i) by keeping a simple syntax while allowing for high-level programming constructs, (ii) by making code execution easy and avoiding compilation overhead, (iii) by allowing a high-level of model reusability and the building of complex modular models, and (iv) by providing powerful solutions to integrate MTG data-structures (that are a common way to represent plants at several scales) into L-systems and thus enabling to use a wide spectrum of computer tools based on MTGs developed for plant architecture. We then illustrate the use of L-Py in real applications to build complex models or to teach plant modeling in the classroom.",
  "full_text": "METHODS ARTICLE\npublished: 30 May 2012\ndoi: 10.3389/fpls.2012.00076\nL -Py: an L -system simulation framework for modeling plant\narchitecture development based on a dynamic language\nFrédéric Boudon1*, Christophe Pradal1, Thomas Cokelaer2, Przemyslaw Prusinkiewicz3 and\nChristophe Godin2*\n1 CIRAD, Virtual Plants INRIA T eam, Montpellier, France\n2 INRIA, Virtual Plants INRIA T eam, Montpellier, France\n3 Department of Computer Science, University of Calgary, Calgary, AB, Canada\nEdited by:\nBasil Nikolau, Iowa State University,\nUSA\nReviewed by:\nRoeland Merks, Centrum Wiskunde &\nInformatica, Netherlands\nHaiquan Li, National University of\nSingapore, Singapore\n*Correspondence:\nFrédéric Boudon and\nChristophe Godin, INRIA T eam Virtual\nPlants, UMR AGAP , TA A-108/02,\nAvenue Agropolis, 34398 Montpellier\nCedex 5, France.\ne-mail: frederic.boudon@cirad.fr;\nchristophe.godin@inria.fr\nThe study of plant development requires increasingly powerful modeling tools to help under -\nstand and simulate the growth and functioning of plants. In the last decade, the formalism\nof L -systems has emerged as a major paradigm for modeling plant development. Previous\nimplementations of this formalism were made based on static languages, i.e., languages\nthat require explicit deﬁnition of variable types before using them. These languages are\noften efﬁcient but involve quite a lot of syntactic overhead, thus restricting the ﬂexibility\nof use for modelers. In this work, we present an adaptation of L -systems to the Python\nlanguage, a popular and powerful open-license dynamic language. We show that the use\nof dynamic language properties makes it possible to enhance the development of plant\ngrowth models: (i) by keeping a simple syntax while allowing for high-level programming\nconstructs, (ii) by making code execution easy and avoiding compilation overhead, (iii) by\nallowing a high-level of model reusability and the building of complex modular models, and\n(iv) by providing powerful solutions to integrate MTG data-structures (that are a common\nway to represent plants at several scales) into L -systems and thus enabling to use a wide\nspectrum of computer tools based on MTGs developed for plant architecture. We then\nillustrate the use of L -Py in real applications to build complex models or to teach plant\nmodeling in the classroom.\nKeywords: L -system, Python language, plant modeling, MTG, development, environment, FSPM\nINTRODUCTION\nIn the last two decades, the study of plant functioning and develop-\nment has been accompanied and supported by the development\nof a new family of models called functional–structural models\n(FSPMs, Sievänen et al., 1997;Godin and Sinoquet, 2005;Hanan\nand Prusinkiewicz, 2008). These computational models use 3D\nrepresentations of plant architecture to simulate different types\nof physical, physiological, or ecophysiological processes in plants,\nand make it possible to assess the effects of these processes on plant\nfunctioning, development, and form.\nThe formalism of L-systems has emerged as the major par-\nadigm for constructing FSPMs (c.f. FSPM Special Issue, 2005,\n2008, 2011). Introduced in the late 1960s by A. Lindenmayer as\na formalism for describing developmental processes in biology\n(Lindenmayer, 1968), L-systems proved well suited to describe\nmodels of plant development (Prusinkiewicz and Lindenmayer,\n1990; Prusinkiewicz, 1998, 1999). In L-systems, the plant is rep-\nresented by a bracketed string, whose elements, called modules,\nrepresent the plant’s components (metamers, meristems, ﬂowers,\netc.). Modules consist of a symbolic name and an optional set\nof parameters. Modules with the same name represent the same\ntype of component (e.g., I for internode, M for meristem, etc.).\nA set of rules (also called productions) then deﬁnes how each\nmodule transforms over time. In particular, a module can pro-\nduce one or more new modules, thus giving a possibility of adding\nnew components to the structure. Brackets are used to delimit\nthe branches. When using L-systems, the modeler designs a set of\nL-system rules which, when applied step after step to the initial\nstring (representing the initial state of the plant), will simulate its\ndevelopment.\nDuring the past 20 years, several implementations of L-systems\nhave been designed. The main ones used in plant modeling\nhave been cpfg (Prusinkiewicz and Lindenmayer, 1990; Hanan,\n1992; Prusinkiewicz et al., 1999a ), lpfg (Prusinkiewicz et al.,\n2007; Karwowski and Prusinkiewicz, 2003), and XL (Kniemeyer\nand Kurth, 2008). Cpfg introduced a dedicated modeling lan-\nguage, in which L-system rules are written using a mathemati-\ncal notation based on formal language theory. This notation is\nextended with C-like statements for specifying changes in para-\nmeters values. In the early 2000s, cpfg was completely reengi-\nneered to address the needs of building more complex functional–\nstructural models. This gave rise to a new modeling program\nlpfg and the modeling language L + C. L + C extends C++\nwith the notion of L-system productions. XL relies on a simi-\nlar approach, but is based on a different support language, Java,\nusually considered as a bit less efﬁcient than C ++ but which\noffers at no cost portability between the different operating sys-\ntems on which it runs.XL manipulates dynamic structures made\nof modules that fully support obj ect-oriented deﬁnition and\nextends the L-systems paradigm by making it possible to deﬁne\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |1\nBoudon et al. L -Py, L -systems in Python\nproduction rules on structures more general than trees, such as\ngraphs.\nDespite the language difference, bothL + C and XL, share the\ncommon feature of being based on languages that are statically\ntyped. By making it mandatory to deﬁne the exact type of variables\nthat are manipulated in every part of the programs, statically typed\nlanguages can optimize the handling of data-structures, efﬁciency\nof computation, and early detection of errors (at compilation\ntime, before execution). On the other hand, they constrain the\nuser to strictly respect typing rules during programming, which\ninvolves high-level of programming expertize for users and, as a\nconsequence, requires a steep learning curve (Ousterhout, 1998;\nPrechelt, 2000; T ratt, 2009). In contrast, dynamic languages are\nless exigent and do not require the speciﬁcation of variable types\nin the code. They do manipulate types, but the correctness of\nvariable types in expressions is mainly checked during execution.\nThis involves an extra burden in program execution, resulting in\na loss of overall efﬁciency with r espect to statically typed lan-\nguages, as many optimization schemes cannot be applied. On\nthe positive side, the programming is more intuitive, the syn-\ntax is less austere, and the learning curve is much more shallow\nthan for static languages (T ratt, 2009). Ousterhout (1998) illus-\ntrates this difference by pointing out that a typical statement in a\ndynamic language is equivalent to 100–1000 elementary instruc-\ntions of the target machine while, in similar conditions, a typical\nstatement in a static language corresponds to 1–10 elementary\ninstructions. A higher level of abstraction is thus enabled by\ndynamic languages. Consequently, dynamic languages are fre-\nquently used as scripting languages, i.e., languages that allow\nfast prototyping both by fostering interactivity between program-\nmers and their programs during development and by making\nit possible to glue together macroscopic software components\neasily.\nThe difference between static and dynamic languages can\nappear at ﬁrst sight to be of a technical nature and of lit-\ntle interest to biologists. However, we suggest here that the\nuse of dynamic languages is particularly well adapted to the\nbuilding of simulation systems in developmental biology. In\nmany modeling applications, the advantages of dynamic lan-\nguages over static ones make the former an attractive choice\ndespite their relative lower computational efﬁciency. They are\nmore intuitive for users with a limited background in com-\nputer science, while offering recent, powerful object-oriented\nprogramming constructs for more computationally oriented\nusers.\nIn this work, we explored the adaptation of dynamic lan-\nguages to the modeling of plant growth. For this, we designed a\nnew open-source L-system-based modeling environment based on\nPython, a popular and powerful dynamic language. An overview\nof the resulting language, L-Py, and its programming environ-\nment is presented in Section “L-Py Overview.” Then we describe\nhow L-Py can be used to model plant development at sev-\neral scales. For topology, we extend classical L-strings to rep-\nresent MTGs (formalism to represent the multiscale nature of\nplants), which makes it possible to seamlessly integrate a wide\nset of model components and tools already designed for MTGs\ninto L-Py programs. For geometry, new primitives have been\nintroduced in the language to describe plant components in a\nhigh-level manner and at different scales. Finally, we illustrate the\nuse of L-Py in real modeling applications, composed of multi-\nple modeling components and for developing training programs\non modeling in the classroom (see Example of FSPM Appli-\ncations in L-Py). All the code excerpts given in the paper are\nactual L-Py code. The corresponding example ﬁles can be down-\nloaded together with the L-Py software through the OpenAlea\ndistribution (http://openalea.gforge.inria.fr).\nL-Py OVERVIEW\nEmbedding L-systems into a dynamic language such as Python has\na number of consequences on the language syntax, its interpreter,\nthe programming environment, and the openness of the system\n(i.e., its ability to interact with external components).\nA SIMPLE SYNTAX OWING TO DYNAMIC TYPING\nT o integrate L-systems into Python, we followed a methodology\nsimilar to that used by Karwowski and Prusinkiewicz (2003) to\ndesign and implementL + C. L-system constructs were thus added\nto the syntax of Python, following the syntax of cpfg and L + C\nas closely as possible for compatibility between L + C and L-Py.\nHowever, some constructs inherit speciﬁcally from the Python lan-\nguage syntax. Compared toL + C, the L-Py syntax is simpliﬁed by\navoiding type declaration of parameters and variables. A simple\nexample of L-Py code is given below.\nLsystem1:\n1 module Apex(age), Internode(length, radius)\n2 MAX_AGE, dr = 10, 0.02 # constants\n3 Axiom: Apex(0)\n4 production:\n5 Internode(l,r) --> Internode(l,r + dr)\n6 Apex(age):\n7 if age < MAX_AGE:\n8 produce Internode(1,0.05)/(137.5)[+(40)Apex(age+1)]\nApex(age+1)\nThe main components of this code are as follows.\nModules\nIn L-systems, plant structures are decomposed into physical units\ncalled modules. The set of modules forms a branching structure\nthat is represented by a bracketed string of modules ( Linden-\nmayer, 1968; Prusinkiewicz and Lindenmayer, 1990; Hanan, 1992),\nhere that we call here L-string. By default, any character can be a\nvalid module name. Modules containing more than one charac-\nter must be declared. Module parameters may also be declared\nto make explicit their role (although this is not mandatory), e.g.,\nApex(age) may represent an apex characterized by its age, as\nin line 1 of the above example. In this case, ifApex is found in a\nstring, it will be interpreted as one module instead of four differ-\nent modules, namely A, p, e, and x. Module parameters (such as\nage) are Python objects and can be of any type.\nAxiom\nA speciﬁc string of modules, called the axiom, deﬁnes the ini-\ntial state of the simulation. This string is declared by using the\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |2\nBoudon et al. L -Py, L -systems in Python\nkeyword Axiom. In the example, the axiom is a string made of a\nsingle module Apex(0), representing the initial structure of the\nplant.\nRules\nThe keyword production indicates the beginning of rule\ndeclarations. As incpfg, rules may have the syntax:\nPredecessor --> Successor\nor, more generally\nLeftContext < Predecessor > RightContext --> Successor\nwhere Predecessor and Successor are strings of modules,\nand both LeftContext and RightContext are optional\nstrings of modules. The rules can be expressed using two conven-\ntions. Simple rules can be written in a compact mathematical style\nsimilar to cpfg (Prusinkiewicz and Lindenmayer, 1990 ; Hanan,\n1992), e.g., line 5. Alternatively, for more complex rules, succes-\nsor speciﬁcations are declared as in L + C using the produce\nstatement (instead of the arrow -->) embedded into regular\nPython code, e.g., line 8. In this case, predecessors are separated\nfrom the right-hand side of the rules by a colon (line 6) con-\nsistently with the syntax of Python functions. For example, the\nrule of lines (6–8) replaces every Apex with parameterage infe-\nrior toMAX_AGE (line 7) with anInternode module followed\nby a lateral Apex and the main Apex. Lateral Apex is included\nin brackets. T wo geometric symbols, / and +, make it possible\nto specify phyllotactic and insert ion angles for the interpreta-\ntion, respectively. The strings generated by this simple L-system\nin the ﬁrst three simulation steps (starting with the axiom w\n0)\nwill be:\nw0:Apex(0)\nw1:Internode(1,0.05)/(137.5)[+(40)Apex(1)]Apex(1)\nw2:Internode(1,0.07)/(137.5)[+(40)Internode(1,0.05)/\n(137.5)[+(40)Apex(2)]Apex(2)]Internode(1,0.05)/\n(137.5)[+(40)Apex(2)]Apex(2)\nA visual representation of these strings is given in Figure 1.I n\nsummary, the syntax of L-Py is largely compatible with bothcpfg\nand L + C to facilitate code porting between these languages. See\nAppendix for additional description of L-Py syntax.\nA FLEXIBLE INTERPRETER BASED ON DYNAMIC EVALUATION\nThe L-Py interpreter makes it possible to execute L-Py expres-\nsions. The ﬁrst phase consists of compiling the code of a model\ninto bytecode that can be executed by Python (more precisely by\nthe Python virtual machine). For this, L-Py code is ﬁrst trans-\nlated into pure Python code by the L-Py language parser which\nalso generates some internal structures for the interpreter. During\nthis process, the predecessor of each rule is stored in a dedicated\ndata-structure, and the rule is transformed into a corresponding\nPython function. Due to the runtime evaluation ability of dynamic\nlanguages (T ratt, 2009), evaluation of the Python code was easy to\nimplement in L-Py.\nFIGURE 1 | Visual representation of the ﬁve ﬁrst step of L -system 1.The\nApex modules are represented by green spheres and Internodes by brown\ncylinders.\nFollowing the deﬁnition of L-systems, the L-Py interpreter\napplies productions to the current string of modules (called L-\nstring) as many times as speciﬁed by the user. In each derivation\nstep, a new L-string is computed by transforming the L-string\nresulting from the previous step (or the axiom in the ﬁrst step). T o\nthis end, the interpreter parses the L-string and looks for modules\nmatching production predecessors. In L-Py, modules may have\na dynamic number of parameters, therefore both the name of a\nmodule and its actual number of parameters are taken into account\nwhile matching a module in the string to a production predecessor,\nas in cpfg (Prusinkiewicz and Lindenmayer, 1990; Hanan, 1992).\nIf a match is found, a Python function corresponding to the iden-\ntiﬁed production is called and the string of modules returned\nby this function (typically found after aproduce statement) is\nappended to the currently constructed L-string. If several matches\nare found, the ﬁrst one is used.\nIn addition to applying productions, L-Py can perform a geo-\nmetric interpretation of the new L-string in each derivation step\nupon request. The blocks of rules used for this purpose are pre-\nceded by the keyword interpretation. Interpretation rules\nthat match the new L-string modules transform modules of the\nnew L-string into predeﬁned symbols that can be geometrically\ninterpreted by a Logo-style turtle (Prusinkiewicz, 1986). T o this\nend, L-Py was strongly coupled with PlantGL, a Python-based\ngraphic library for plant modeling ( Pradal et al., 2009 ), which\nprovides many high-level graphic and turtle geometry primitives\n(see also High-Level Constructs for the Control of T urtle Geome-\ntry). Given an L-string, the turtle builds a graphic scene that can\nbe displayed with the PlantGL 3D viewer (Pradal et al., 2009).\nA POWERFUL OPEN SYSTEM ENABLED BY LANGUAGE INTROSPECTION\nThanks to the embedding in a dynamic language, L-Py function-\nalities can be easily accessed either through a graphical interface\nor directly using Python commands. This enables users to control\nL-Py programs in three different manners.\nA complete integrated development environment\nThe cpfg and lpfg simulators are embedded in modeling pack-\nages vlab (Mercer et al., 1990; Federl and Prusinkiewicz, 1999) and\nL-studio (Prusinkiewicz et al., 1999b; Prusinkiewicz, 2004), which\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |3\nBoudon et al. L -Py, L -systems in Python\nprovide graphical editors of model attributes such as colors, optical\nproperties of materials and graphically deﬁned functions, curves,\nand surfaces. Likewise, the L-Py interpreter has been embedded\ninto an integrated development environment (IDE) that includes\ncode and visual parameter editors. The code editor incorpo-\nrates dedicated syntax highlighting. When an error occurs, the\ncorresponding line is automatically highlighted, facilitating the\ndebugging of the model. Visual editors make it possible to inter-\nactively edit scalars, curves, patches, materials, and graphically\ndeﬁned functions. Names of these objects can be deﬁned in the\neditors and are used to manipulate the objects in the L-Py code\nof the models. Similarly to L-studio, L-Py also contains acontin-\nuous modeling mode in which interactions with parameters are\nimmediately propagated and visualization of the model automat-\nically updated. This facilitates interaction with the model during\nsimulations.\nIn addition to the visualization of the graphical interpretation\nof the model, an interactive exploration of the computed L-string\nis of great help to characterize and validate a model. T o achieve this,\na standard Python shell has been integrated in the development\nenvironment with primitives to access the computed L-strings and\nother variables. This allows inspection anda posteriori processing\nof the structure. A similar approach can be found in the GroImp\nplatform, which includes a home-made interactive interpreter,XL\n(Kniemeyer and Kurth, 2008).\nThe L-Py IDE is also inspired by programming environments\nsuch as Visual Studio (Microsoft Corporation, 2011). Its conﬁg-\nurable interface usingdockable panel widgets (see Figure 2) makes\nit possible to easily customize the working environment and its\nadvanced development tools (proﬁler and debugger, etc.). The L-\nPy IDE incorporates two tools that help optimize models. First, a\ndebugger shows the user the successive rule applications that occur\nduring a derivation step with actual parameters and global variable\nvalues. The debugging can be constrained to detect the applica-\ntion of particular rules only. Second, aproﬁler provides the user\nwith a detailed report of the time spent in each rule and function,\nand makes it possible to identify bottlenecks in the execution. The\ncreation of these tools was facilitated by theintrospection property\nof dynamic languages (introspection is the ability of a program to\nexplore and possibly modify its own code). For instance, access at\nFIGURE 2 | The L -Py IDE with its utility windows for parameter edition.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |4\nBoudon et al. L -Py, L -systems in Python\nruntime to the names and values of the different variables involved\nin a procedure is simple in a dynamic language and facilitates, for\ninstance, the creation of the debugger.\nL-Py as a component library: controlling L-systems execution from\nPython\nL-Py has been developed as a C++ library embedded in Python\nthat can thus be integrated into any Python-compatible appli-\ncation. For this, the L-Py library deﬁnes a number of structures\n(module, L-string, rule, L-system, etc.) that can be accessed from\nPython in an object-oriented manner. As a result, an L-system\nmodel can easily be manipulated by an external process. Such a\nprocess typically creates an L-system object, executes it for a num-\nber of speciﬁed steps, possibly changes its parameters, resumes\nthe execution, and ﬁnally gets the computed L-string. In this way,\nL-Py can be encapsulated as a simple component of a more com-\nplex modeling pipeline that integrates other components, possibly\nusing formalisms different from L-systems.\nThe central issue of such an encapsulation strategy is to control\nthe execution of L-Py models. An L-Py program contains global\nvariables, functions, rules, and conﬁguration/execution variables\nsuch as the number of derivation steps. From an external process, a\nuser may want to access and change any of these elements. In L-Py,\nthis can be done by using the Python/L-Py introspection mecha-\nnism or by using dedicated primitives implemented in L-Py. For\ninstance, to explore a large parameter space for a given L-system,\na user may want to vary parameters (e.g., global variables) of an\nL-system model after each execution. Such exploration cannot be\nmade easily manually. The use of theintrospection property of L-Py\nmakes it possible to resolve this issue elegantly: a process that uses\nL-Py as a component can inquire about the internal variables of\nthe L-Py model (global and conﬁguration/execution variable) and\ndirectly access and modify them in memory. Global variables of\nthe model become automatically and dynamically attributes of the\nL-system structure that contains the model, and can be modiﬁed as\neasily as any attribute of a Python object. Execution variables can\nalso be modiﬁed with predeﬁned L-Py functions. For example, to\noverwrite the axiom of an existing L-system object, an L-string can\nbe built from a speciﬁed string of characters with theLstring\nconstruct and then used to overwrite the contents of the L-system\naxiom. More generally, L-strings can be built from modules con-\ntaining objects of any complex type as parameter values. Thanks\nto the dynamic typing of the language, parameters of any type\ncan be introduced into the L-string and passed to an L-system.\nFor example, the following program creates and runs iteratively\nLsystem1 using an increasing value of the global variabledr,\nincremented externally in each step.\nCode2:\n1 lsys = Lsystem(‘Lsystem1.lpy’)\n2 print lsys.dr # This would print 0.02\n3 axiom = Lstring(‘Apex(2)’,lsys)\n4 for i in range (10):\n5 lsys.dr += 0.02\n6 lstring = lsys. derive(axiom,5)\n7 interpretedstring = lsys. interpret(lstring)\n8 scene = lsys. turtle_interpretation(interpretedstring)\n9 Viewer. display(scene)\nLine 1 reads in and creates an L-system structure from the\nLsystem1 code. The second line requests and prints the value\nof the internal variable dr from the model lsys. Note that the\nglobal variables such asdr are automatically considered as attrib-\nutes of the L-system object. Line 3 creates an L-system string from\na text string, usinglsys module deﬁnition to interpret correctly\nthe module names. This L-string will be used subsequently as the\nL-system axiom. Line 4 initiates a loop that will perform parame-\nter space exploration for ten values of thedr parameter. At each\niteration step, Line 5 changes the value ofdr before performing\n5 Lsystem derivation steps starting from the axiom (line 6) and\nassigns the resulting string to lstring. Note that in this case,\nonly the production rules and the global variables of the L-system\nare used in the object, while the initial string (axiom) can be con-\nsidered as a variable (notion of L-system scheme, Herman and\nRozenberg, 1975). The function derive can also be called with\nno argument and will use in this case the values of the axiom and\nthe number of derivation to perform declared in the L-system.\nFinally, lines 7–9 interpret the resulting string geometrically using\nthe turtle interpretation, and display the result in the viewer. These\nlines can also be summarized into one (more efﬁcient) com-\nmand lsys.plot (lstring).H o w e v e r ,t h e ya r eg i v e nh e r et o\nshow that a user can ﬁnely control the execution of an L-system.\nImportantly, entire functions and productions of complex models\ncan be changed similarly to the simple variable dr in the above\nexample.\nCreation and manipulation of an L-system object have also\nbeen encapsulated into OpenAlea (Pradal et al., 2008) as compu-\ntational nodes. Similarly to the example provided here, these nodes\ncan be created with L-Py code and parameterized with a dictionary\ncontaining the names and new values of the variables. Examples\nof such use are given in Section “L-Py as Growth Component for\nSimulating an FSPM.”\nThe L-Py introspection mechanism: controlling L-system execution\nfrom L-Py programs\nL-Py makes it also possible to control its execution, vari-\nables, and rules from within L-Py models. For instance,\nthe ExecutionContext object is accessible through the\nexecContext() function and makes it possible to ask and\nmodify the values of the L-Py model conﬁguration/execution vari-\nables. These variables control the number of derivation steps, the\ncurrently used group, etc. (a complete list is given in the online\nhelp; see also Standard L-Systems Features of L-Py in Appen-\ndix). After each iteration modelers also have access, through the\nEndEach function, to the resulting L-string and the correspond-\ning scene graph. This enables global post-processing of the mod-\neled structure using regular Python code and external modules\nfrom within a model. In this way, an L-Py model can also act\nas an integrative framework for different modeling components\n(see for instance section “Minimizing Measurements in 3D Plant\nArchitecture Reconstruction”). For example,\nLsystem3:\n1 Axiom: A\n2 production:\n3A --> B\n4B --> AB\nproduces a sequence of strings whose lengths follow the Fibonacci\nseries. It can also be shown that the string produced in stept is the\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |5\nBoudon et al. L -Py, L -systems in Python\nconcatenation of the strings produced in stepst-2 and t-1. Check-\ning visually these properties with L-Py is easy and requires only\nadding two lines of code:\nLsystem3 (continued):\n5 def EndEach(lstring):\n6 print len (lstring), lstring\nThese lines print the length and the value of the current L-string\nand are called after each derivation step. The output exhibits the\nFibonacci properties of the model:\nLsystem3 (output):\n1A\n1B\n2A B\n3 BAB\n5 ABBAB\n8 BABABBAB\nModiﬁcation to the string can be made in a similar way from within\na L-Py model. Likewise, thanks to the dynamic language evalua-\ntion, it is possible to add or remove a rule during the execution of\nan L-system.\nMODULAR L-SYSTEMS IN L-Py\nCode modularity is the key to build complex and reusable mod-\nels. In our context, this raises the question of building reusable\nblocks based on L-systems that can subsequently be assembled.\nModularity of the model may result from the decomposition of\nthe structure into components such as internodes or leaves, which\ncan be processed and deﬁned independently (Hanan, 1992; Godin\net al., 1998; Prusinkiewicz et al., 1999a) or from the decomposition\nof the model into of component aspects such as growth, photo-\nsynthesis, and hormone transport ( Cieslak et al., 2011). In this\nsection, we discuss the support for decomposition into aspects,\noffered by L-Py.\nOne technique supporting such decomposition was proposed\nby Federl and Prusinkiewicz (2004), based on the concept of con-\ntrolled derivations in L-systems. Different groups of production\nrules are identiﬁed by group Ids. Only one group is active in\nany derivation step. However, another group may be activated in\nthe next derivation step, and so on. The selection of the appro-\npriate group can be conveniently made before each derivation\nstep using the StartEach statement. Within a static language,\nhowever, parameters of the modules are declared at the begin-\nning of the model and their declaration should take into account\nall parameters required for all groups. This limits the indepen-\ndence of the groups and thus the modularity of the composite\nL-system.\nMore recently,Cieslak et al. (2011) proposed another strategy\nto develop modular L-systems, based on the use of separate mod-\nules to represent different aspects of the model. These modules\ncan be combined such that one organ of the plant is represented\nby a list of modules, each reﬂecting a different aspect of the model.\nThe rules related to the different aspects are described in different\ngroups and are invoked sequentially. While this makes it possible\nto have separate deﬁnition of each group with their own modules\nand rules, a given element is modeled in this approach with several\nmodules, which blurs its identity.\nIn L-Py, we elaborated on the approach of Federl and\nPrusinkiewicz (2004) and extended it with the use of a dynamic\nlanguage to reinforce the decoupling of the different L-systems to\nassemble. The goal is to combine several independent L-systems,\ntypically written by different persons, in different ﬁles (say for\nexample ﬁlesA.lpy, B.lpy, C.lpy). Each L-system can be\nconsidered as a processing unit dealing with an aspect of sim-\nulation, for example substance transport, branch mechanics, or\ngrowth. An order may have to be respected in the application of\nthe corresponding L-systems, as some of them may update L-string\nparameters subsequently used by other L-systems. W e assume that\nthe different L-systems operate on the same or closely related sets\nof plant components, e.g., apices, growth units, or internodes. As\nsimilar components in different L-systems may be identiﬁed by dif-\nferent module names, a mapping between these names is deﬁned\nin the third “translation” L-system. For instance, if the module\nrepresenting an internode is namedI in L-system A and S in L-\nsystem B, a ruleI --> Swill be created in the translation L-system\nA2B. Module parameters must also be translated. Detailed exam-\nples of how this is done are given in Section “Managing L-System\nModularity” in Appendix.\nDifferent L-systems and their translations can be chained\nby the programmer to make up a unique compound L-\nsystem. T o easily handle such chaining, a generic Python class\nComposedLsystem is provided in L-Py. It takes two arguments:\na list of L-systems to be chained (including translation schemes)\nand a list of interpretation schemes to be chained. A sketch of a\ntypical code that must be deﬁned to combine different L-systems\nfollows.\nCode4:\n1 a,b,c = Lsystem(‘A.lpy’),Lsystem(‘B.lpy’),\nLsystem(‘C.lpy’)\n2 a2b, b2a, a2c = Lsystem(‘A2B.lpy’),Lsystem(‘B2A.lpy’),\nLsystem(‘A2C.lpy’)\n3 clsystem = ComposedLsystem([a,a2b,b,b2a],[a2c,c])\n4 lstring = clsystem.axiom\n5 for i in xrange(K):\n6 lstring = clsystem.derive(lstring)\n7 clsystem.plot(lstring)\nThe ﬁrst two lines create the different L-systems required for the\nmodel. The third line gathers them into a ComposedLsystem struc-\nture. As arguments, two lists of L-systems are given. The ﬁrst list\ncontains the set of L-systems responsible for the production rules\nand the second list for the interpretation, given in the order in\nwhich they should be called. In the ﬁrst list, the target L-system of\nthe last translation (the “a”i n b2a in the example below) must\nbe identical to the ﬁrst L-system of this list, while in the second\nlist, the source L-system of the ﬁrst translation (“a”i na2c) must\nbe identical to the last L-system of the ﬁrst list (i.e., “a” also). The\nnext four lines simply run and plot the ComposedLsystem for a\nnumber K of iterations as if it were a simple L-system. In this case\nthe chaining of L-systems is controlled by the ComposedLsystem\nprimitive, but the modeler still has the possibility to write code\nthat calls each Lsystem one after another a number of times (for\ninstance to handle different time units in the different L-systems).\nThis approach shows a great ﬂexibility in assembling com-\nponents by transforming L-strings expressed in the alphabet of\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |6\nBoudon et al. L -Py, L -systems in Python\none L-system to that of another one. This approach may be com-\nbined with sub-Lsystems or other aspect-oriented approaches into\na completely ﬂexible and modular L-system framework.\nMODELING PLANT GROWTH AT DIFFERENT SCALES IN L-Py\nThe embedding of L-Py in a dynamic language has a number of\nconsequences on the modeling possibilities themselves. Due to the\nnon-strict typing system, connection with external modules and\nmodels is much simpler than with static languages. Here, we inves-\ntigate the consequences of this language speciﬁcity to key aspects\nof plant modeling.\nSEAMLESSLY COMBINING L-SYSTEMS AND MTGs\nIn the late 1990s,Godin and Caraglio (1998)introduced a formal\nmodel called Multiscale T ree Graph (MTG) to represent a wide\nrange of plant architectures, at varying scales of description, in a\nﬂexible and uniﬁed way. Since then, MTGs have been used widely\nto encode various types of plant architectures at varying scales\n(e.g., Godin et al., 1999 ; Mündermann et al., 2005 ; T eobaldelli\net al., 2008) and to analyze the resulting data with dedicated soft-\nware such as AMAPmod (Godin and Guédon, 1997) and OpenAlea\n(Pradal et al., 2008). T oday, in OpenAlea, MTG is the central data-\nstructure that different modeling packages use as a standardized\nway to represent plants.\nIn order to exploit the large library of algorithms and mod-\nels built for MTGs in L-Py, we designed bidirectional translation\nand mapping mechanisms between L-strings and MTGs. Conver-\nsion between these structures is possible as they both represent\na particular type of labeled tree graphs. L-strings represent axial\ntree graphs (Prusinkiewicz and Lindenmayer, 1990) while MTGs\nmay integrate tree graph descriptions at several scales (Godin and\nCaraglio, 1998). Fortunately, it has been shown that, similarly\nto simple tree graphs, multiscale tree graphs can be encoded as\nstrings (Godin et al., 1999). L-strings corresponding to MTGs can\nbe deﬁned using this property ( Godin et al., 1999; Ferraro and\nGodin, 2000).\nIn brief, let us ﬁrst consider an L-string representing the tree\ngraph at the most microscopic scale of the MTG (e.g., at the scale\nof internodes I), ofFigure 3 (left) e.g.,\nIII[ II ] I...\nwhere each I represent a plant module (here an internode), and\nopening brackets indicate branching points. Modules representing\nmore macroscopic nodes of the MTG, corresponding for example\nto growth units U or to branching systems S, are inserted before\nthe ﬁrst microscopic module that composes them (Godin et al.,\n2005). The resulting string mixes modules at different scales. A\nsmall branching systemS composed of growth unitU that can be\ndecomposed as internodesI is thus encoded as:\nSUIII[ UII ]U I...\nThis deﬁnes amultiscale L-string associated with the MTG (see\nFigure 3). For the L-Py interpreter to recognize that modules in\nthe string belong to different scales, the user must explicitly asso-\nciate each module type with a scale using the keyword “scale”\nin the module type declaration of the L-Py program:\nFIGURE 3 | Comparison of MTG and an L -string.A branching system S is\ncomposed of three growth units, which are in turn composed of two or\nthree internodes. Left: a detailed representation of S at the scale of the\ninternode. Middle: representation of the MTG on the top and the\ncorresponding multiscale L -string on the bottom. Right: A geometric\nrepresentation of the multiscale L -string.\nmodule S: scale = 0\nmodule U: scale = 1\nmodule I: scale = 2\nAs in classical L-strings, modules in multiscale L-strings can have\nparameters of any type, including complex types and objects. The\nuse of a dynamic language makes it possible to seamlessly con-\nvert L-strings into MTGs and, reciprocally, MTGs into L-strings.\nIndeed, in the conversion, L-string module parameters are auto-\nmatically transformed into MTG node parameters (or vice versa)\nwithout the burden of duplicating parameters in memory or\nwriting/reading data through exchange ﬁles.\nPrimitives to read/write and convert MTGs into L-strings\n(and reciprocally) have been designed and make it possible to\nmanipulate MTGs directly within L-Py rules. These can be used\nfor instance to initialize a simulation with a plant architecture\nmeasured experimentally:\nLsystem5:\n1 from openalea.mtg import *\n2 intialmtg = MTG(‘walnut.mtg’)\n3 Axiom:\n4 PlantFrame(intialmtg, scale = 3)\n5 parameters = [’tipposition’,’bottomdiameter’,\n’topdiameter’]\n6 lstring = mtg2lstring(initialmtg,{‘S’: parameters,\n‘U’: parameters, ‘V’: parameters})\n7 sproduce(lstring)\n8 interpretation:\n9 S(tippos,bottomdiam,topdiam) --> _(bottomdiam)\nLineTo(tippos,topdiam)\n10 U(tippos,bottomdiam,topdiam) --> _(bottomdiam)\nLineTo(tippos,topdiam)\n11 V(tippos,bottomdiam,topdiam) --> _(bottomdiam)\nLineTo(tippos,topdiam)\nAxiom is now deﬁned as a rule (lines 3–7) that produces a string\n(line 7). The MTG of a measured walnut tree ( Juglans regia L.;\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |7\nBoudon et al. L -Py, L -systems in Python\nSinoquet et al., 1997) is ﬁrst loaded (line 2, note that the func-\ntions for manipulating MTGs, such as MTG and PlantFrame\nused here, are independently provided by the MTG package of\nOpenAlea). This ﬁle contains the information related to the topol-\nogy of the plant at three different scales (axis segments, axes,\nand plant). In addition, for some plant segments, it contains\nkey information about their geometry, called “frame” informa-\ntion (this information was not systematically measured for all\nplant segments in the ﬁeld). The frame information consists of\nthe spatial location of the segment tip in a reference coordinate\nsystem originating at the basis of the plant, together with their\nbottom and top diameters. Based on the frame information avail-\nable for some segments in the MTG, thePlantFrame function\nmakes it possible to compute the frame information for all the\nplant segments where it is missing, using predeﬁned inference\nrules (Godin et al., 1999). As a result, the frame attributes (’tip\nposition’,’bottomdiameter’,’topdiameter’)o f\nthe segments of the MTG are updated with the computed infor-\nmation. The MTG is then transformed into a multiscale L-string\n(lines 5–6), where the different modules corresponding to the\nplant segments (here labeled S, U, V) are given parameters\ncorresponding to their frame information in the MTG. Finally,\nthe sproduce statement of line 7 produces the multiscale L-\nstring corresponding to the MTG (one can note the difference\nbetween produce and sproduce: produce creates a suc-\ncessor L-string from a list of modules, whilesproduce creates\na successor L-string from an already built L-string structure). The\naxiom deﬁned by this string has thus been procedurally evaluated.\nFinally, to plot a graphical representation of the axiom, a simple\ninterpretation rule is deﬁned for each type of module (line 9–11)\nthat uses the turtle to draw the complete plant structure by exploit-\ning the frame data of the successive plant segments along the plant\naxes (Figure 9, left).\nHIGH-LEVEL CONSTRUCTS FOR THE CONTROL OF TURTLE GEOMETRY\nAs illustrated in the previous sections, the use of a dynamic lan-\nguage such as Python favors the openness of the modeling language\n(i.e., its ability to be extended) and its simplicity of use by pro-\nviding high-level constructs in the language. Both characteristics\nwere considered as key guiding principles throughout the design\nof L-Py. In this section, we show how these principles were used\nto simplify the modeling of plant geometry by introducing new\nconstructs to manipulate turtle geometry at high abstraction level.\nCustom geometric primitives for plant representation at different\nscales\nWhen representing plant architecture, most simulation systems\nuse an explicit geometric representation of plant organs: intern-\nodes are represented by cylinders, leaves by small parametric\nsurfaces, fruits by volumetric models, roots by generalized cylin-\nders, etc. In recent years, however, abstract geometric models of\nplant organs have been introduced to represent plant architectures\nat more macroscopic scales in simulation models (e.g., Cescatti,\n1997; Boudon, 2004; Pradal et al., 2009; Livny et al., 2011). These\napproaches are based on the use of either volume or envelope\nmodels that represent groups of organs instead of individual\norgans. Such models can be readily designed in L-Py thanks to\nthe tight coupling with the PlantGL library (Pradal et al., 2009). A\ngeneric primitive, @g(geometry), allows the modeler to posi-\ntion any PlantGL model in space using the current turtle location\nand orientation. In this way, coarse geometric representations of\nplant architecture can be deﬁned where parts of the tree crown are\nrepresented by parametric envelopes. The resulting architecture\nmay then be used in conjunction with ecophysiological models\nthat take a 3D scene as an input. Here we illustrate this possibility\nby computing the direct illumination of each crownlet in the plant\nusing theFractalysis library (Da Silva et al., 2008) from OpenAlea:\nLsystem6:\n1 from openalea.plantgl.all import AsymmetricHull\n2 from openalea.fractalysis.ligth import\ndiffuseInterception\n3 def EndEach(lstring,lscene):\n4 lighting = diffuseInterception(lscene)\n5 for id, light in lighting.iteritems():\n6 if lstring[id].name == ‘Crownlet’:\n7 lstring[id].light = light\n8\n9 module Crownlet(height,radii,light)\n10 production:\n11 ... # generation of the tree containing Crownlet\n12 interpretation:\n13 Crownlet(height,radii,light)-->; (colormap(light))\n@g(AsymmetricHull(height,radii))\nThis L-system produces in each derivation step an L-string that\nis composed of modules Crownlet which are characterized by\ntheir height, maximum radii in four directions in the plane perpen-\ndicular to their main axis, and the total amount of light that they\nreceive (deﬁned in line 9). As explained in Section “The L-Py Intro-\nspection Mechanism: Controlling L-System Execution from L-Py\nPrograms, ” the L-string produced at each step and the correspond-\ning L-scene can be post-processed in theEndEach function. The\nL-scene is a set of PlantGL objects that were derived from the L-\nstring modules by the application of the interpretation rules (line\n13). Each L-scene object thus contains an id corresponding to its\nassociated module in the L-string (in L-Py, the L-scene ids sim-\nply correspond to the position of their associated module in the\nL-string). In the EndEach function, the amount of diffuse light\nintercepted by every module of the plant is evaluated by a call to\nthe Fractalysis library (line 4). The diffuseInterception\nprimitive is passed a PlantGL scene and returns a dictionary con-\ntaining pairs composed of module ids and of the amount of light\nintercepted by that module. T o import this information back into\nthe string, an iteration over the dictionary is made in lines 5–7. For\neach module id, the module name is checked (line 6) to select only\ncrownlet modules and their light parameter is updated (line 7).\nFigure 4 shows a representation of the L-scene after construction\nof a tree made of a branching system bearing crownlets represented\nby asymmetric hulls and colored according to the total amount of\nlight intercepted by each crownlet.\nSeamless control of differential turtle geometry\nIn particular modeling situations, one needs to instruct the tur-\ntle to follow a predeﬁned curve in 3D space. This is required for\nexample when one wants to control the shape of a branch using\na predeﬁned template shape. For this, we assume that a curve of\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |8\nBoudon et al. L -Py, L -systems in Python\nlength L is deﬁned that represents the shape of a particular branch.\nIn the 3D scene, at the position of the branch insertion on the par-\nent branch, we then need to instruct the turtle to move along this\ncurve from its current position. T o achieve this,Prusinkiewicz et al.\n(2001) designed an algorithm to move the turtle in the 3D space\nbased on differential geometry and using quantities such as local\ntangent, curvature, and step size. The following L-Py code gives a\nsimple 2D version inspired from this algorithm.\nLsystem7:\n1 length = 12.4\n2 dl = 0.01\n3 Axiom: FFF [+M(0)] FF\n4 production:\n5 M(l):\n6 if l < length:\n7 u, nextu = l/length, (l + dl)/length\n8 tgt = curve.getTangent(u)\n9 nexttgt = curve.getTangent(nextu)\n10 rotangle = degrees(atan2(cross(tgt,nexttgt),\ndot(tgt,nexttg)))\n11 produce +(rotangle) F(dl) M(l + dl)\nThe axiom deﬁnes a parent branch made of ﬁve segments\nand bearing a branch on the third one (line 3). The branch\nis produced by incremental application of rule M(i) until\nlength length is reached (lines 5–6). First, normalized lin-\near abscissa of current and next points are computed (line\n7), assuming that the turtle will make steps of constant size\ndl. This makes it possible to compute the angle by which\nthe turtle should turn (lines 8–10) according to the reorien-\ntation of the tangent between these points before making the\nmove (line 11). The recursive application of this rule produces\nthe branch shape as speciﬁed by the PlantGL Curve2D object\ncurve, deﬁned elsewhere either graphically or procedurally (see\nsection “ A Complete Integrated Development Environment” and\nFigure 5B).\nHowever, one can note that the corresponding code contains\nlow-level instructions related to the computation of the local\nFIGURE 4 | Representation of a tree at the scale of crownlet using of\nthe asymmetric hull primitive of PlantGL and with light interception\ncomputation usingFractalysis (Da Silva et al., 2008).\ncurvature on the template curve (lines 7–10). This may obscure\nthe overall code with instructions related to differential geom-\netry management, which are not essential to the expression of\nthe model itself. T o alleviate this difﬁculty, we abstracted this\ndifferential geometry management by introducing the primitive\nSetGuide(curve,length), which instructs the turtle to fol-\nlow the given curve until the total length of its moves reaches\nthe prescribed value length. The algorithm used to control the\nturtle frame movement from the curve deﬁnition is inspired from\nBloomenthal (1990) to control branch shape in a global to local\nmanner (details of the SetGuide primitive are depicted in section\n“The SetGuide Primitive” in Appendix). Using this primitive, we\ncan deﬁne the shape of a branch and keep clear the main L-system\ncode:\nLsystem8:\n1 Axiom: FFF [&(90) SetGuide(curve,length) M(0)] FF\n2 production:\n3 M(l):\n4 if l < length:\n5 produce F(dl) M(l + dl)\nIn the axiom (line 1), as soon as the turtle has been rotated\nto draw the branch, it is instructed to follow the curvature\nspeciﬁed by the template curve curve (SetGuide primitive).\nThe turtle is moved recursively forward following at each step\nthe bends deﬁned by curve, leading to the result depicted in\nFigure 5B . Note that if the SetGuide primitive is removed,\nthe code is still valid L-Py code, where the turtle goes straight\ninstead of following any curved trajectory ( Figure 5A). In fact,\nSetGuide made it possible to completely separate the spec-\niﬁcation of the branch geometry from the speciﬁcation of the\ntopology.\nThis design pattern can be applied to a more complex branch-\ning system to control the shape of branches in a global to local\nmanner. The following code illustrates the use ofSetGuide to\ncontrol the bending of a complete branching system recursively\nwith a unique template curve.\nFIGURE 5 | Construction of the geometry without (A) and with (B) the\nSetGuide primitive.It takes as input a user -deﬁned template curve\n(represented in the inserted window) and control curvature of turtle path.\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |9\nBoudon et al. L -Py, L -systems in Python\nLsystem9:\n1 Axiom: M(0,0)\n2 production:\n3 M(l,order):\n4 if order < MAXORDER an d l < length:\n5 produce F(dl) iRoll(phi)[ˆ(60)SetGuide(curve,\nlength-l)M(l,order+1)]M(l+dl, order)\n6 else: produce\nThe apex M now has an additional parameter “order” to con-\ntrol the order of the branch. Apices whose order is greater than\nMAXORDER abort (line 4). The apex of order 0 is not preﬁxed by\nany SetGuide (line 1) and thus assumes a Euclidean space and\ndevelops a straight vertical trunk. By contrast, the branches built by\nlateral apices at order 1 and 2 are all preﬁxed by aSetGuide (line\n5) and will then follow the speciﬁed template curvecurve for the\nremaining length length-l. The resulting branching structure\nis illustrated inFigure 6.\nModeling shape variation\nPlants architectures frequently show gradients in the shape of their\norgans. At different scales smooth variations of form and ori-\nentation may be observed: in petal shapes in ﬂowers, in branch\nbending along a trunk, or in crownlet shapes and volumes in\na tree crown (e.g., Bell, 1991; Barthélémy and Caraglio, 2007 ).\nContinuous variations in shapes may also arise throughout time\ndue to growth and aging: leaves may unfold out of the bud for\ninstance or fold due to a change in their water status, branches may\nchange their shape due to interaction between gravity and growth,\nwhile trees may undergo deep shape metamorphosis throughout\ntheir lifespan ( Hallé, 1978). Common to all these processes is\nthe notion that a shape changes seamlessly (or “continuously”)\neither in space or in time. Describing such changes is critical\nin models of plant architecture. In the context of L-systems, the\nimportance of this phenomenon was recognized byPrusinkiewicz\net al. (2001) who proposed to model attributes of plant architec-\nture as functions of their location along the main axis (positional\ninformation).\nHere again, the tight coupling between L-Py and PlantGL\nprovides a powerful solution to address this issue. The\nProfileInterpolation object of PlantGL makes it possible\nFIGURE 6 | Left: simple recursive structure with straight branches,\nRight: use of a template curve shown in the inset to deﬁne branch\ngeometry. S-shaped branches produce a more realistic appearance and can\nbe easily speciﬁed in L -Py.\nto smoothly interpolate between user-deﬁned curves. The user\nspeciﬁes a set of keyframe curves at given index values. Then the\nProfileInterpolation uses an interpolation scheme (e.g.,\nthe BSpline interpolation scheme;Piegl and Tiller, 1997)t oc o m -\npute intermediate curve values for any index between the extreme\nindex values.\nThis function can be used for instance in combination with\nSetGuide to control the shape of axes in a branching system in a\nhigh-level manner. Using positional information (Prusinkiewicz\net al., 2001) and ProfileInterpolation, we can compute\nfor every position on the trunk of the plant a branch shape deﬁned\nas a smoothly interpolated value between user-deﬁned curves at\ndifferent key altitudes on the trunk.\nLet us modify for instance the previous L-system to control the\nshape of branches on the trunk according to a gradient of template\ncurves.\nLsystem10:\n1 axisfunc = ProfileInterpolation([axis1,axis2,axis3],\nindex = [0,0.6,1],degree = 2)\n2 Axiom: M(0,0)\n3 production:\n4 M(l,order):\n5 if order < MAXORDER and l < length:\n6 produce F(dl) iRollR(phyllotaxy)[ˆ(60) SetGuide\n(axisfunc(l/length),length-l) M(l,order+1)]\nM(l + dl, order)\n7 else: produce\nAn interpolation scheme, using these reference curves is set up by\nspecifying the normalized indexes corresponding to these curves,\nand the degree of interpolation (line 1). Then theSetGuide is\nset up to move on the axis curve deﬁned for the normalized index\nl/length by the interpolation scheme. Figure 7 illustrates the\nresult of this scheme applied to different sets of key curves.\nThis interpolation procedure can also be used to animate plant\ndevelopment in a ﬂexible manner as illustrated by the example\ncode below (Figure 8).\nLsystem11:\n1 axisfunc = ProfileInterpolation([axis1,...,axis4],\ntimes = [0,0.25,0.5,0.75,1],degree = 3)\n2 length, dl, dt = 10, 1, 0.01 # constants\n3 Axiom: Leaf(0,length)\n4 production:\n5 Leaf(t,l) --> Leaf (t+dt,l)\n6 interpretation:\n7 Leaf (t,l)--> Sweep(axisfunc(t), profile,l, dl,leafwidth)\nFIGURE 7 | Examples of structures whose branches shapes are deﬁned\nas interpolation of three curves (shown on the right of each tree).\nLengths of lateral branches are also dependant of the position of the\nbranches on the trunk and is controlled with an extra graphical function.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |10\nBoudon et al. L -Py, L -systems in Python\nFIGURE 8 | Animating a rolling leaf (bottom) using graphically speciﬁed curves and functions (top).The ﬁrst curve speciﬁes the cross section of the leaf,\nthe second speciﬁes leaf width along the main axis of the leaf, and the remaining four curves specify the key shapes of the main axis of the leaf over time.\nA sequence of keyframe curves deﬁning the midrib of a leaf\ngradually rolling down were deﬁned graphically by the user\n(Figure 8 , top right). An interpolation scheme is set up using\nthese reference curves by specifying their time points and the\ndegree of interpolation (line 1). The L-system production sim-\nply advances the “age”t of a module representing the leaf (line\n5). Each application of this production is followed by an inter-\npretation step (line 7). Theproduce statement in line 7 creates\nthe leaf blade geometry. The leaf midrib is speciﬁed by the L-\nPy built-in Sweep primitive that corresponds to an extension of\ngeneralized cylinders (Bloomenthal, 1985) to arbitrary contours,\nincluding non-closed contours. This primitive is itself deﬁned on\nthe basis of the SetGuide primitive. In the example code, the\ncontour is speciﬁed by the SetSection primitive and deﬁnes\nthe transversal section of the leaf blade. The axis of this general\ncylinder is deﬁned as the interpolated curve at time pointt.T h e\nresulting sample frames of the animation are depicted onFigure 8.\nEXAMPLE OF FSPM APPLICATIONS IN L-Py\nIn this section, we show how L-Py can be used to create complex\nFSPM scenarios. A ﬁrst example illustrates how advanced analysis\ntools can be used to parameterize a L-system that reconstructs trees\nfrom observed data. The second example illustrates how modu-\nlarity can be used to decompose an existing FSPM into reusable\ncomponents. A last example reports the use of L-Py as a training\ntool for high school students to reconstruct a virtual ecosystem.\nMINIMIZING MEASUREMENTS IN 3D PLANT ARCHITECTURE\nRECONSTRUCTION\nThe compatibility between L-Py and MTGs opens powerful new\npossibilities to manipulate plant simulations. Let us consider for\nexample the problem of digitizing complex tree architectures. Dif-\nferent techniques to address this problem have been proposed in\nthe literature and only manual techniques, such as magnetic 3D\ndigitizing (Sinoquet et al., 1997), can currently precisely record\nboth the 3D spatial coordinates and the topological structure of\na plant in terms of annual shoots or growth units. Unfortunately,\nmanual digitizing techniques are extremely time consuming and\nmethods to simplify them are much needed. An intuitive idea is to\nexploit the redundancy of tree structures and only digitize the main\nbranches of the tree. Smaller branchlets, which are highly repeti-\ntive, are then generated procedurally. Assuming that such a scheme\nhas been implemented, the question is how to assess the resulting\nsemi-automatic reconstruction method. The seamless combina-\ntion of plant architecture simulation and analysis provided in L-Py\nmakes it possible to simply address this issue.\nLet us illustrate how such an approach would be implemented\nusing L-Py. W e assume that a reference plant has been digitized.\nHere, for sake of simplicity, we reuse the digitized walnut tree\nintroduced previously. W e also assume that a simple L-Py proba-\nbilistic model has been designed to generate small branches from\nbud modules. W e want to assess the ability of this model to recon-\nstruct faithfully the digitized small branches of the tree, and thus\nto avoid the overhead of digitizing small branches in similar trees.\nFor this, we ﬁrst remove the small branching systems from the\ndigitized tree. Modules of the digitized tree have three different\ntypes: modules of type V (resp. U) represent growth unit segments\nfrom the last year (resp. from the second last year). All other mod-\nules are of type S and represent branch segments from previous\nyears (Figure 9 , left). In our example, we chose to remove the\nbranching systems made up by growth units from the last 2 years,\ni.e., of type V and U. This can be done by deﬁning a simple L-Py\nrule in the previous L-system ﬁle (lsystem5.lpy) that replaces every\nbranching system starting with a U and following a segment S by\na bud:\nLsystem5 (sequel):\n1 production:\n2 S(tip0,dbot0, dtop0) < U(tip,dbot,dtop) --> Bud%\nThis rule removes in a single derivation step all the branch extrem-\nities starting withaUf r o mt h em u l tiscale L-string representing the\ndigitized plant and replaces them by Bud modules (Figure 9, right).\nIn a subsequent derivation step, the bud modules are then used\nto produce new branching systems using a probabilistic model.\nThis model is deﬁned by an L-Py rule:\nLsystem12:\n1 production:\n1 Bud:\n2 nbelem = gauss(AVG_NBELEM,STDEV_NBELEM) # Gaussian\ndistribution\n3 for i in xrange (nbelem):\n4 nproduce U # generates the growth units of the\nmain axis\n5 ramif = random()\n6 if ramif < BRANCHINGPROB: # create a branch on U\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |11\nBoudon et al. L -Py, L -systems in Python\n(with fixed probability)\n7 nproduce [V]\n8 nproduce V\nThis rule speciﬁes that a bud is replaced by a shoot made of a ran-\ndomly chosen number of segments U that can each bear (or not) a\nsegment V and that terminate by a segment V . Note that we omit-\nted to show the computation of the branch geometry to keep the\nexample simple. As a result, all the removed digitized branches are\nreplaced by artiﬁcially generated small branches, thus providing a\npartially digitized and partially simulated tree.\nThen, to assess the quality of the resulting semi-simulated tree,\nwe make use of the plant structural comparison primitive avail-\nable in the VPlants package of OpenAlea ( Ferraro and Godin,\n2000). This function compares the structures of two plants (here\nthe digitized and semi-simulated trees) and returns a list of pairs\nFIGURE 9 | Use of a digitized 20-year-old walnut tree (Juglans regia L.)\nas the axiom of a simulation.Right, shoots produced during the last\n2 years are removed. Simulation process will use this structure as new\naxiom and produce algorithmically new shoots. Generated shoots will be\ncompared with measured ones. Bottom, a detail view of the process: from\ntop to bottom, original branching system, pruned system with insertion of\nBud represented as red sphere, and example of regenerated structure.\nof plant segments from both plants that were found to match each\nother. The more matching segments are found in both trees, the\nbetter the reconstruction. The normalized length of the returned\nlist, Q = 2 × L/(L\n1 + L2), L being the size of the returned list and\nL1 and L2 respectively the sizes of the compared trees, can thus\nbe used as an indicator of the faithfulness of the model. If Q is\ngreater than a speciﬁed threshold, the simulated tree is considered\nas a faithful reconstruction and the list contains pairs referring to\nmost of the components of both plants. In the opposite case, the\nlist is close to being empty and the reconstruction is considered\npoor. The following function illustrates how such a comparison\ncan be carried out in L-Py:\nCode13:\n1 from openalea.treematching import *\n2 def compare(lstring, initialmtg):\n3 reconsmtg = lstring2mtg(lstring)\n4m = Matching(reconsmtg,initialmtg)\n5 return 2* len(m.getMatchingList())/(len(reconsmtg)+\nlen(initialmtg))\nThe compare function takes as arguments the current L-string\nrepresenting the reconstructed plant and an MTG representing the\ninitial digitized tree. It ﬁrst transforms the L-string into an MTG\nand then compares the two MTG structures using a primitive from\nthe treematching module of OpenAlea. As a result, it returns\nthe estimated value ofQ for this comparison.\nThis function can then be used to explore the parameter space\nof the probabilistic branching model (here through varying the\nbranching probability) so as to ﬁnd those parameters that make it\npossible to reconstruct trees faithfully with respect to the original\ndigitized tree. This is done in the following function that assembles\nthe different components of this pipeline:\nCode13 (sequel):\n6 def optimize_reconstruction (minv,maxv,vstep):\n7 l = Lsystem(‘lsystem5.lpy’)\nFIGURE 10 | Result of the comparison between regenerated structures\nand the measured one.The scores of the different branching systems are\ngiven by the colored curves and the average value by the black curve.\nMaximum average score is reached with a probability of 0.77 and gives a\nscore of 0.8.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |12\nBoudon et al. L -Py, L -systems in Python\n8 initialmtg = l.initialmtg\n9 prunedstring = l. derive()\n10 Q = zeros((maxv-minv)/vstep)\n11 for i, branchingprob in enumerate (arange (minv,\nmaxv,vstep)):\n12 l = Lsystem(‘lsystem12.lpy’)\n13 l.BRANCHINGPROB = branchingprob\n14 lstring = l. derive(prunedstring,1)\n15 Q[i] = compare(lstring,initialmtg)\n16 plot(arange(minv,maxv,vstep),Q)\nIn our example, Q varies non-monotonically between 0.65 and\n0.85 when varying the probability parameter between 0 and 1 (see\nFigure 10), showing that best reconstructions are reached for a\nbranching probability close to 0.77 in our stochastic model. Three\nexamples of evaluated reconstruction are given inFigure 11 with\nbranching probability of 0.4, 0.6, and 0.77 respectively. Red color\nrepresents parts of the structure whose Q coefﬁcient is greater\nthan 0.8.\nL-Py AS GROWTH COMPONENT FOR SIMULATING AN FSPM\nW e now illustrate the use of the above modular approach on\na real complex FSPM, MAppleT , simulating the growth of an\napple tree (Costes et al., 2008) and originally developed usingL-\nstudio/lpfg. This model mixes stochastic topological construction\nwith a bio-mechanical model for the geometry (see Figure 12).\nThanks to syntax compatibility between L-Py and L + C, the\ncode port mainly consisted in translating and simplifying the\nC++ instructions into Python. Additionally, scientiﬁc tools from\nPython and OpenAlea were readily accessible from within the\nmodel (for instance, 2D plot withMatplotlib).\nAn L-system model, such as MAppleT , is composed of sev-\neral processes that simulate the growth and internal processes of\na plant. In the original model, groups of rules were deﬁned to\nmodel different processes: (a) updating state of organs accord-\ning to a calendar (bud break, ﬂowering, etc.), (b) computa-\ntion of growth units lateral productions according to stochastic\nFIGURE 11 | Comparison between regenerated structure and measured\none. Reconstructions showed here are built with ramiﬁcation probability of\n0.4, 0.6, and 0.8 respectively. The six main branching systems of the tree are\ncompared to the original ones using a structural comparison method (Ferraro\nand Godin, 2000). Red and blue color means that structural difference is more\nor less than 20% respectively.\nFIGURE 12 | The MAppleT model on L -Py: with (left) and without (right) computation of branch bending using mechanical simulation.\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |13\nBoudon et al. L -Py, L -systems in Python\nmodels, (c) growth process, (d) biomechanics. During refactor-\ning, the code was divided into distinct L-systems correspond-\ning to these different groups of rule to achieve modularity.\nBecause they came from a single original L-system code, these\nL-systems components used similar module naming convention\nand thus were readily compatible with each other (see Modular\nL-Systems in L-Py). The parameters of the modules were stored\nin a generic container object whose contents can be updated\nby each L-system component. Parameters used by different L-\nsystem components were given a unique name in all of these.\nFor instance, the growth process component (c) requires infor-\nmation on the number and types of components to create at\neach time step. This information is provided by the stochastic\nprocess component (b) using a consistent naming convention in\nboth components.\nUsually the different processes also rely on a number of global\nvariables. T o change their values, a dictionary containing the\nnames and values of global variables can be passed to the L-systems\nand can be applied using the introspection mechanism presented\nin Section “L-Py as a Component Library: Controlling L-Systems\nExecution from Python.” In this way, the global variables can be\npassed from one process to the next one. Each process can thus\nupdate these settings to inform the other processes if needed.\nT o better demonstrate the modularity of the code resulting\nfrom this decomposition of MAppleT , the L-system compo-\nnents were assembled graphically using a dataﬂow in OpenAlea\n(Figure 13). As opposed to code representation, dataﬂows give a\nvisual representation of the logical dependency structure of the\nFSPM. The composition of the components can be made graphi-\ncally by the modeler by linking input and output of the different\nL-systems components and making it possible for the system to\npass on the L-string and the dictionary of global parameters. The\nresulting graph (dataﬂow) can be executed and runs the pipeline\nthroughout.\nFIGURE 13 | Data ﬂow of the MAppleT simulation.The model has been decomposed into several independent processes that can be combined and\nparameterized by user to drive the simulation graphically.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |14\nBoudon et al. L -Py, L -systems in Python\nThanks to this modular decomposition, interesting manipula-\ntion of the assembled models can be made. For example, the user\nhas the possibility to enable/disable some of them upon request.\nFigure 12 right illustrates for example the result of the model in\nwhich the Biomechanics component has been disabled.\nBased on this implementation of a real-size FSPM, we could\ncarry out a comparative analysis of the computational perfor-\nmances of L-Py and that of static language implementations. L-Py\nwas able to generate an entire architecture (10,000 components\ngenerated over 4 years) in reasonable time (5–10 min). In gen-\neral, simulation with L-Py can be faster than withlpfg for small\nmodels (since it avoids compilation), but is ﬁve to six time slower\nthan lpfg for more complex models of a 4-year-old apple tree (see\nFIGURE 14 | Computation time comparison with between L -Py and\nlpfg for MAppleT .The horizontal axis represents age of the simulated tree\nwith estimated number of elements of the tree.\nFigure 14 ). This is due to Python code interpretation of rules\nwhich is relatively slow compared to a compiled language like C\nor C++ (Prechelt, 2000). However, the L-Py interpreter written in\nC++ maintains acceptable performances.\nL-Py AS A TRAINING TOOL FOR THE CLASSROOM\nDuring French school year 2009–2010, we tested the use of L-\nPy as a tool for teaching scientiﬁc method in the context of a\nmulti-disciplinary class on botany and computer science at high-\nschool level (15- to 16-years-old pupils, 3 h per week during\n35 weeks). The program of the class included both botanical and\ncomputer science/mathematics courses. The aim of the class was\nto reconstruct in 3D the vegetal structure of a 10 m× 10 m plot of\nplants typical from the local ﬂora. The pupils measured the plants\nin the ﬁeld, made diagrams and drawings of the plant architectures\n(see Figure 15), and registered the spatial distribution of observed\nplants. In the classroom, they were working hands on the computer\nand using L-Py as a modeling platform. They ﬁrst learnt how to\ngenerate simple fractal and plant structures. They could create\nsoon ﬁrst simple models of plant structures. Then, using more\nsophisticated and generic models prepared for the occasion, they\neasily used their knowledge of L-Py to extend and customize these\nmodels according to the measured plants. Modiﬁcations ranged\nfrom simple parameter modiﬁcation to addition of new rules in\nthe L-systems. A number of individual plant models were thus\ndesigned by different groups of pupils in L-Py and were assembled\ninto a single scene according to the measured distribution. Finally\nthe scene was exported and rendered withBlender (2011) and a\nﬁlm corresponding to a virtual exploration of the 3D scene was\nproduced. This experience gave us important feedback on L-Py\nduring its testing phase. It ﬁrst showed that the software can be\nused with success for training students in a multi-disciplinary con-\ntext. L-Py turned out to be robust enough to support intensive use\n(and misuse) by pupils. The feedback from the classroom led us\nto adapt L-Py in various ways: simplify the visual interface, intro-\nduce debugging tools, and design new language features (such as\nthe SetGuide and the curve interpolation primitives).\nFIGURE 15 | Illustration of an application of L -Py in teaching.Students were in the ﬁeld to map some botanical drawing ofEuphorbia. Some virtual models\nwere then build with L -Py and gathered in a complex botanical scene rendered with Blender.\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |15\nBoudon et al. L -Py, L -systems in Python\nCONCLUSION\nIn this paper, we presented L-Py, an open-source software platform\nfor L-system simulation based on Python. Compared to previous\nL-system simulation software packages, L-Py makes intensive use\nof Python’s property of being a dynamic language to achieve ﬂex-\nibility in modeling and high-level programming. Inherited from\nPython, the L-Py language syntax remains simple, with no or min-\nimal bracketing of expressions, and very clear block structures.\nL-Py was designed as both an integrative framework and a library\nof L-system constructs that can be called from Python. Owing to\nits dynamic language structure, L-Py facilitates the design of mod-\nular models by assembling elementary models without modifying\ntheir code, provided they respect minimal speciﬁcations. For the\ndesign of plant models, special language constructs were intro-\nduced for compliance with MTG data-structures, for which large\nlibraries of computational models and tools already exist (e.g.,\nOpenAlea software platform and its packages). Likewise, for geom-\netry, constructs were introduced to reuse any model from PlantGL,\na library of geometric primitives dedicated to plant representation\nat different scales, and to simplify the speciﬁcation of complex geo-\nmetric models with the L-system turtle. T o illustrate the ﬂexibility\nand power of L-Py, we presented its application to real modeling\nsituations. The problem of optimizing plant digitizing strategy\nillustrated the beneﬁt of using jointly L-systems and MTGs in a\nmodeling application. MappleT was used to illustrate the possi-\nbility to design complex simulation systems in a modular way.\nThe last example illustrated the pedagogic value of L-Py based\non a real experiment carried out with high-school students in\nFrance.\nACKNOWLEDGMENTS\nThe authors are grateful to M. Beziz, E. Farcot, Y . Caraglio, D.\nLacour, L. Comte, and J. Chopard who were involved in the\nhigh-school classes. This project ispartially supported by Agropo-\nlis Foundation and the INRIA VPlants-BMV associated team\nproject.\nREFERENCES\nBarthélémy, D., and Caraglio, Y . (2007).\nPlant architecture: a dynamic, mul-\ntilevel and comprehensive appro-\nach to plant form, structure and\nontogeny. Ann. Bot. 99, 375–407.\nBell, A. D. (1991).Plant Form: An Illus-\ntrated Guide to Flowering Plant Mor-\nphology. Oxford: Oxford University\nPress.\nBlender. (2011). The Blender Foun-\ndation. Amsterdam. Available at:\nhttp://www.blender.org\nBloomenthal, J. (1985). “Modeling the\nmighty maple, ” inProceedings of the\n12th Annual Conference on Computer\nGraphics and Interactive T echniques,\nSIGGRAPH ‘85 (New Y ork: ACM).\nBloomenthal, J. (1990). “Calculation\nof reference frames along a space\ncurve, ” inGraphics Gems,e dA .S .\nGlassner (Boston: Academic Press),\n567–571.\nBoudon, F . (2004). Représentation\nGéométrique de L ’architecture des\nPlantes. Ph.D. thesis, University of\nMontpellier II, Montpellier.\nCescatti, A. (1997). Modelling the\nradiative transfer in discontinuous\ncanopies of asymmetric crowns. I.\nModel structure and algorithms.\nEcol. Modell. 101, 263–274.\nCieslak, M., Seleznyova, A. N., Prusin-\nkiewicz, P ., and Hanan, J. (2011).\nT owards aspect-oriented functional-\nstructural plant modelling.Ann. Bot.\n108, 1025–1041.\nCostes, E., Smith, C., Renton, M.,\nGuédon, Y ., Prusinkiewicz, P ., and\nGodin, C. (2008). MAppleT: simula-\ntion of apple tree development using\nmixed stochastic and biomechani-\ncal models. Funct. Plant Biol. 35,\n936–950.\nDa Silva, D., Boudon, F ., Godin, C.,\nand Sinoquet, H. (2008). Multiscale\nframework for modeling and ana-\nlyzing light interception by trees.\nMultiscale Model. Simul.7, 910–933.\nFederl, P ., and Prusinkiewicz, P . (1999).\n“Virtual laboratory: an interactive\nsoftware environment for computer\ngraphics, ” in Proceedings of Com-\nputer Graphics International, Can-\nmore: Alberta. ’99, 93–100.\nFederl, P ., and Prusinkiewicz, P . (2004).\n“Solving differential equations in\ndevelopmental models of mul-\nticellular structures expressed\nusing L-systems, ” in Proceedings\nof Computational Science. ICCS\n2004 (Krakow, Poland, June 6–9,\n2004), Part II, Lecture Notes in\nComputer Science 3037 , eds M.\nBubak, G. van Albada, P . Sloot,\nand J. Dongarra (Berlin: Springer),\n65–72.\nFerraro, P ., and Godin, C. (2000). A dis-\ntance measure between plant archi-\ntecture. Ann. For. Sci.57, 445–461.\nFSPM Special Issue. (2005). New Phy-\ntologist. Blackwell Publishing. 166,\n771–894.\nFSPM Special Issue. (2008). Functional\nPlant Biology. Eds J. Hanan and\nP . Prusinkiewicz, CSIRO Publishing,\n35, 739–1090.\nFSPM Special Issue. (2011). Annals of\nBotany. Eds T . de Jong and D. Da\nSilva (Oxford: Oxford University),\n108, 987–1223,\nGodin, C., and Caraglio, Y . (1998). A\nmultiscale model of plant topolog-\nical structures. J. Theor. Biol. 191,\n1–46.\nGodin, C., Costes, C., and Caraglio,\nY . (1998). Exploring plant topolog-\nical structure with the AMAPmod\nsoftware; an outline. Silva Fennica\n31, 357–368.\nGodin, C., Costes, E., and Sinoquet,\nH. (1999). A method for describing\nplant architecture which integrates\ntopology and geometry.Ann. Bot.84,\n343–357.\nGodin, C., Costes, E., and Sinoquet,\nH. (2005). “Plant architecture mod-\nelling – virtual plants and com-\nplex systems, ” inPlant Architecture\nand its Manipulation, V ol. 17, ed C.\nG. N. T urnbull (Oxford: Blackwell)\n238–287.\nGodin, C., and Guédon, Y . (1997).\nAMAPmod v1.8. Introduction and\nReference Manual\n. CIRAD Report,\nMontpellier.\nGodin, C., and Sinoquet, H. (2005).\nFunctional–structural plant model-\nling. New Phytol. 166, 705–708.\nHallé, F . (1978). “ Architectural vari-\nation at speciﬁc level of tropi-\ncal trees, ” in T ropical T rees as Liv-\ning Systems , eds P . B. T omlinson\nand M. H. Zimmermann (Cam-\nbridge: Cambridge University Press),\n209–221.\nHanan, J. (1992). Parametric L-Systems\nand their Application to the Model-\ning and Visualization of Plants. Ph.D.\ndissertation, University of Regina,\nRegina, Saskatchewan.\nHanan, J., and Prusinkiewicz, P . (2008).\nForeword: studying plants with\nfunctional–structural models.\nFunct. Plant Biol.35, vi–viii.\nHerman, G. T ., and Rozenberg, G.\n(1975). Developmental systems and\nlanguages. North-Holland: Amster-\ndam.\nKarwowski, R., and Prusinkiewicz, P .\n(2003). Design and implementa-\ntion of the L+C modeling language.\nElectron. Notes Theor. Comput. Sci.\n86, 134–152.\nKniemeyer, O., and Kurth, W . (2008).\n“The modelling platform GroIMP\nand the programming language XL, ”\nin Applications of Graph T rans-\nformations with Industrial Rele-\nvance: Third International Sympo-\nsium, AGTIVE 2007, Kassel, Ger-\nmany, October 10-12, 2007, Revised\nSelected and Invited Papers, Lecture\nNotes In Computer Science, 5088 ,\neds A. Schürr, M. Nagl, and A.\nZündorf (Kassel: Springer-V erlag),\n570–572.\nLindenmayer, A. (1968). Mathematical\nmodels for cellular interaction in\ndevelopment, Parts I and II.J. Theor.\nBiol. 18, 280–315.\nLivny, Y ., Pirk, S., Cheng, Z., Y an,\nF ., Deussen, O., Cohen-Or, D., and\nChen, B. (2011). T exture-lobes for\ntree modelling. ACM T rans. Graph.\n30, 53.\nMercer, L., Prusinkiewicz, P ., and\nHanan, J. (1990). “The concept and\ndesign of a virtual laboratory, ” in\nProceedings of Graphics Interface.\nHalifax, Nova Scotia. ‘90, 149–155.\nMicrosoft Corporation. (2011). The\nVisual Studio . Available at: http://\nwww.microsoft.com/visualstudio/\nMündermann, L., Erasmus, Y ., Lane,\nB., Coen, E., and Prusinkiewicz,\nP . (2005). Quantitative modeling\nof Arabidopsis development. Plant\nPhysiol. 139, 960–968.\nOusterhout, J. K. (1998). Scripting:\nhigher-level programming for the\n21st century. IEEE Comput. 31,\n23–30.\nPiegl, L. A., and Tiller, W . (1997).\nThe Nurbs Book , 2nd Edn. Berlin:\nSpringer.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |16\nBoudon et al. L -Py, L -systems in Python\nPradal, C., Boudon, F ., Nouguier, C.,\nChopard, J., and Godin, C. (2009).\nPlantGL: a Python-based geometric\nlibrary for 3D plant modelling at\ndifferent scales. Graph. Models 71,\n1–21.\nPradal, C., Dufour-Kowalski, S.,\nBoudon, F ., Fournier, C., and Godin,\nC. (2008). OpenAlea: a visual\nprogramming and component-\nbased software platform for plant\nmodeling. Funct. Plant Biol. 35,\n751–760.\nPrechelt, L. (2000). An empirical com-\nparison of seven programming lan-\nguages. IEEE Comput. 33, 23–29.\nPrusinkiewicz, P . (1986). “Graphical\napplications of L-systems, ” in Pro-\nceedings of Graphics Interface ‘86 ,\n247–253.\nPrusinkiewicz, P . (1998). Modeling of\nspatial structure and development of\nplants. Sci. Hortic. 74, 113–149.\nPrusinkiewicz, P . (1999). A look at the\nvisual modeling of plants using L-\nsystems. Agron. Agric. Environ. 19,\n211–224.\nPrusinkiewicz, P . (2004). “ Art and sci-\nence for life: designing and grow-\ning virtual plants with L-systems, ” in\nNursery Crops: Development, Evalu-\nation, Production and Use: Proceed-\nings of the XXVI International Horti-\ncultural Congress, Acta Horticulturae\n630, eds C. Davidson and T . Fernan-\ndez, (ISHS: T oronto), 15–28.\nPrusinkiewicz, P ., Hanan, J., and Mech,\nR. (1999a). “ An L-system-based\nplant modeling language, ” inAppli-\ncations of Graph T ransformations\nwith Industrial Relevance. Proceed-\nings of the International W orkshop\nAGTIVE ‘99, Lecture Notes in Com-\nputer Science 1779, eds M. Nagl, A.\nSchuerr, and M. Muench (Berlin:\nSpringer), 395–410.\nPrusinkiewicz, P ., Karwowski, R., Mech,\nR., and Hanan, J. (1999b). “L-\nstudio/cpfg: A software system for\nmodeling plants, ” inApplications of\nGraph T ransformations with Indus-\ntrial Relevance. Proceedings of the\nInternational W orkshop AGTIVE ’99,\nLecture Notes in Computer Science\n1779, eds M. Nagl, A. Schuerr, and M.\nMuench (Berlin: Springer), 457–464.\nPrusinkiewicz, P ., James, M., and Mech,\nR. (1994). “Synthetic topiary, ” in\nProceedings of SIGGRAPH Orlando,\nFlorida. ‘94, 351–358.\nPrusinkiewicz, P ., Karwowski, R., and\nLane, B. (2007). “The L+C plant\nmodeling language, ” inFunctional-\nStructural Plant Modeling in Crop\nProduction, eds. J. V os, L. F . M.\nMarcelis, P . H. B. de Visser, P . C.\nStruik, J. B. Evers and R. J. Bogers,\n(W ageningen: Springer), 27–42.\nPrusinkiewicz, P ., and Lindenmayer, A.\n(1990). The Algorithmic Beauty of\nPlants. New Y ork: Springer.\nPrusinkiewicz, P ., Lindenmayer, A., and\nHanan, J. (1988). Developmental\nmodels of herbaceous plants for\ncomputer imagery purposes. Com-\nput. Graph. 22, 141–150.\nPrusinkiewicz, P ., Mündermann, L.,\nKarwowski, R., and Lane, B. (2001).\n“The use of positional information\nin the modeling of plants, ” inPro-\nceedings of SIGGRAPH ‘2001 ,L o s\nAngeles, 289–300.\nSievänen, R., Mäkelä, A., Nikinmaa,\nE., and Korpilahti, E. (1997), Spe-\ncial issue on functional-structural\ntree models. Silva Fennica 31,\n237–238.\nSinoquet, H., Rivet, P ., and Godin, C.\n(1997). Assessment of the three-\ndimensional architecture of walnut\ntrees using digitising. Silva Fennica\n31, 265–273.\nT eobaldelli, M., Puig, A. D., Zenone,\nT ., Matteucci, M., Seufert, G., and\nSequeira, V . (2008). Building a\ntopological and geometrical model\nof poplar tree using portable on-\nground scanning LIDAR. Funct.\nPlant Biol. 35, 1080–1090.\nT ratt, L. (2009). Dynamically typed\nlanguages. Adv. Comput. 77,\n149–184.\nW ang, W ., Jüttler, B., Zheng, D., and\nLiu, Y . (2008). Computation of rota-\ntion minimizing frame.ACM T rans.\nGraph. 27, 18.\nConﬂict of Interest Statement: The\nauthors declare that the research was\nconducted in the absence of any com-\nmercial or ﬁnancial relationships that\ncould be construed as a potential con-\nﬂict of interest.\nReceived: 16 December 2011; accepted:\n04 April 2012; published online: 30 May\n2012.\nCitation: Boudon F, Pradal C, Coke-\nlaer T, Prusinkiewicz P and Godin C\n(2012) L-Py: an L-system simulation\nframework for modeling plant architec-\nture development based on a dynamic\nlanguage. Front. Plant Sci. 3:76. doi:\n10.3389/fpls.2012.00076\nThis article was submitted to Frontiers\nin T echnical Advances in Plant Science,\na specialty of Frontiers in Plant Science.\nCopyright © 2012 Boudon, Pradal, Coke-\nlaer , Prusinkiewicz and Godin. This is an\nopen-access article distributed under the\nterms of the Creative Commons Attribu-\ntion Non Commercial License, which per-\nmits non-commercial use, distribution,\nand reproduction in other forums, pro-\nvided the original authors and source are\ncredited.\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |17\nBoudon et al. L -Py, L -systems in Python\nAPPENDIX\nSTANDARD L-SYSTEMS FEATURES OF L-Py\nL-Py supports a number of standard features introduced in other\nL-system-based programming languages. As illustrated by the ﬁrst\nexample of this paper, L-Py supports parametric L-systems with\nﬂexible parameter types. Conditional rule application is thus pos-\nsible. By default, rules are deterministic. However, stochastic rules\nare quite natural to build using functions from statistical packages\nprovided by Python. A typical example would be\nLsystem18:\n1 from random import *\n2p 0=0 . 5 # constants\n3 Axiom: Apex(0)\n4 production:\n5 Apex(age):\n6 nproduce Internode(1,0.1)/(180)\n7 if uniform() < p0: nproduce[+(20)Apex(age+1)]\n8 produce Apex(age+1)\nThe ﬁrst line imports the Python package random for random\nnumber generation. This package includes the uniform function\nused at line 8. Line 2 deﬁnes branching probability p0. The rule in\nlines 5–8 uses the nproduce statement to assemble the succes-\nsor in several steps. In particular, the production of a lateral apex\n(line 8) depends on the value returned by the uniform random\nfunction, which is compared to p0.\nProduction rules make it possible to insert new module. Like-\nwise, the disappearance of a moduleis speciﬁed using productions\nwith an empty successor. An entire sub-tree can be removed\nby inserting the module %, which prunes out all the following\nsub-structure in the string until the end of the enclosing branch.\nSeveral aspects of a derivation step can be controlled by the\nuser. First, a rule can be applied by scanning the string from left\nto right ( forward), which corresponds to an acropetal progres-\nsion from the root of the structure to the leaves, or from right to\nleft (backward), i.e., basipetally from the leaves to the root (Kar-\nwowski and Prusinkiewicz, 2003). The functions Forward and\nBackward can be called to parameterize the direction of the next\niteration. This is usually set up using the control functionsStart,\nEnd, StartEach, and EndEach, which are deﬁned by the user\nand called by the system at the beginning, end, before, and after\na derivation step, respectively (Hanan, 1992). Second, it is possi-\nble to select a subset of rules at a given step. For this, a group of\nrules can be deﬁned and activated during execution of the model\nto simulate separately different aspects of the behavior of a model\n(Prusinkiewicz et al., 2007).\nApplication of a rule may depend on the context of the pre-\ndecessor using context-sensitive rules. L-Py also supports four\ntypes of context, namely left, right, new left, and new right con-\ntexts (Karwowski and Prusinkiewicz, 2003). Notation follows the\nL + C syntax, i.e., the predecessor may have the following form for\nforward and backward derivation, respectively\n1 left_context < new_left_context << strict_predecessor\n> right_context\n2 left_context < strict_predecessor << new_right_context\n> right_context\nThe context search takes into account the branching structure of\ntrees. For instance the following patternA<C supposes a father–\nchild relationship between moduleA and C, but does not exclude\nother children of A. In particular, the string w=A[B][C] repre-\nsents a topology where a module A has two children B and C.\nThe previous pattern thus applies to C. Some modules within\nbranches may thus be skipped during a linear scan of the tree.\nContexts are particularly useful to simulate signals and communi-\ncation between organs (Prusinkiewicz et al., 1988; Prusinkiewicz\nand Lindenmayer, 1990).\nL-Py models may also be sensitive to their spatial location. For\nthis, query modules, such as?P, make it possible to get position\nand orientation of the geometrical interpretation of the model in\nthe rewriting process (Prusinkiewicz et al., 1994).\nMANAGING L-SYSTEM MODULARITY\nT o design modular simulation systems in L-Py, the user must com-\nply with three simple rules when breaking down the system into\ndifferent L-systems.\nRule 1. Model consistency\nAssume that, at a given timet, all the L-systems will be applied to\nidentical plant topological structures. Only names and attributes\nof plant components can be different.\nRule 2. Single generic module parameter\nIf different attributes must be attached to a particular module\n(e.g., age, diameter, etc.), they must be encapsulated within a\nsingle parameter that consists of an object of the built-in type\nParameterSet. The plant components attributes are then\nrepresented as attributes of this object.\nFor example, let us consider a model A that uses two types of\nmodules namely Apex and Internode:\nLsystem S2.1: A\n1 module Apex(p), Internode(p),\n2 Axiom: Apex(ParameterSet(age=0))\n3 production:\n4 Apex(p): ...\nIn the L-string, the modules have one parameter p, which is a\npredeﬁned generic container of typeParameterSet. Each L-\nsystem rule can then dynamically add or modify attributes to this\ngeneric parameter p. Here, we again take advantage of the ﬂex-\nibility of dynamic language, in which a Python structure can be\ncomplemented with new attributes at any moment by any L-system\nwithout any explicit pre-declaration. This makes it possible for\neach L-system to add its own attributes to the generic parame-\nter p, without requiring that these attributes are know to other\nL-systems. This mechanism is clearly more ﬂexible that of static\nlanguages in which parameter declaration is mandatory at the ini-\ntialization and should be conform to this declaration in every part\nof the code, thus contaminating all the L-systems components.\nRule 3. T ranslation schemes. Each L-system may have different\nmodule naming convention and attributes. For a given L-system B\nto be able to process the L-string of L-system A, it is necessary that\na mapping from A modules to B modules be deﬁned, thus acting\nas a translation from the language of A to the language of B. Our\napproach consists of transforming A modules into B modules and\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |18\nBoudon et al. L -Py, L -systems in Python\nback using L-system rules. Module name translation can easily be\nexpressed with L-system rules as illustrated by the Lsystem A2B\nbelow that transforms A modules into corresponding B ones.\nLsystem S2.2: B\n1 module A(param), I(param),\n2 production:\n3 A(param): ...\nLsystem S2.3: A2B\n1 module Apex(p), A(p), Internode(p), I(p)\n2\n3 production:\n4 Apex(p) --> A(p)\n5 Internode(p) --> I(p)\nSymmetric rules may be required to translate back from the lan-\nguage of B into the language of A, in particular if one wants to\niteratively apply L-systems A, B several times consecutively. Such a\nbidirectional translation requires that mapping from the alphabet\nof A to the alphabet of B is one to one. This is done by deﬁning a\nnew L-system:\nLsystem S2.4: B2A\n1 module Apex(p), A(p), Internode(p), I(p)\n2\n3 production:\n4 A(p) --> Apex(p)\n5 I(p) --> Internode(p)\nSimilarly, attribute names used in the parameter container should\nbe consistent between different L-systems. If, for instance, two\nprocesses rely on similar attributes but use different naming con-\nvention, attributes will also have to be renamed during translation\nstep. Conversely, if two processes use the same attribute name for\ndifferent things, attributes will also have to be renamed to avoid a\nconﬂict.\nThen, at a given time step, starting from an A L-string, the user\napplies L-system A which computes a new A L-string. Then this A\nL-string is translated intoaBL - s t r i n gw i t hL - s y s t e mB 2 As othat\nthe L-system B can be applied. Then B is applied and ﬁnally, the\nresulting B string is translated back into A L-string to come back\nto the initial A L-system and continue the simulation. The proce-\ndure can be readily extended to the combination of any number\nof L-systems.\nThe L-systems can then be assembled into a super-L-system\nusing the built-in ComposedLsystem primitive described in the\nmain text.\nTHE SetGuide PRIMITIVE\nA turtle is associated with a position P and frame F T composed\nof three orientation vectors mutually perpendicular that indicates\nits heading H,u p U, and left directions L (Prusinkiewicz et al.,\n2001). The turtle can perform a number of geometric operations.\nIn particular, it can step forward in its heading direction or can\nrotate along its three orientation axis. Following a predeﬁned path\nwith turtle geometry was described inPrusinkiewicz et al. (2001)\nand consists of adjusting orientation of the turtle before each step\nto ﬁt the heading vector to the local path tangentT.\nSimilarly, theSetGuide makes it possible that steps of a turtle\nfollow the path of a user-deﬁned curveC, scaled to reach a length\nL also speciﬁed by the user. The turtle steps are not supposed in\nthis case to be small. The curve is supposed to be positioned and\noriented in the initial location of the turtle. It is also supposed to\nbe parameterized with curvilinear abscissau.\nT o compute orientations along a curve, a frame can be com-\np u t e da te a c hp o i n to fC. A frame is made of three vector (r, s,\nt ) with t representing the tangent to the curve. Classical solu-\ntion relies on the Frenet frame. However, it produces important\ntwist of the frame at inﬂection point of the curve. Some meth-\nods make it possible to compute frame with minimized rotation\n(Bloomenthal, 1990; W ang et al., 2008). In our approach, we adapt\nthe method described inPrusinkiewicz et al. (2001). It starts from\na frame F (r, s, t )a t C (u). T o computeF\n′(r ′, s′, t ′)a t C (u + du),\nthe tangent t ′ of the curve is ﬁrst estimated. Then the rotationR\nthat mapst to t ′ is computed. This rotation can then be applied to\ns and r of F to haver ′ and s′ values. The advantage of this method\nis that it is consistent (no twist) and iterative with only the value\nof the previous step needed to compute the next one.\nT o follow the path of the curve, rotations of the turtle will be\nperformed before and after each step to orient it in a direction\ngiven by the curveC. The step forward command (F ) with a para-\nmeter du representing step length is thus decomposed into three\nsteps: adjust orientation to reachC (u + du), move the turtle for-\nward, and adjust the orientation of the turtle to ﬁt tangent ofC\nat u + du (see Figure A1). The ﬁrst and last operations are turtle\norientation performed using the method presented previously. In\nthe ﬁrst case, the new tangent direction is approximated with the\nvector d = C (u + du) − C (u).\nOne problem comes from the fact that the rotation is com-\nputed in the coordinate system of the curve. T o adapt it for\nthe turtle frame, the axis A of rotation R is translated from the\nreference frame F (u) of the curve to the frame F\nT of the turtle:\nA′ = F T × F (u)−1 ×A. The transformation R′(A′, α) can then be\napplied to the vectors H, L, and U of the turtle frame to express\nthe reorientation of the turtle. Note that R(A, α)i ss t i l lu s e dt o\ncomputed the new frame of the curve atC (u + du). Finally when\nmoving the turtle forward, the length of the step has to be adapted.\nFIGURE A1 | A step with the SetGuide command.On the left,\ncomputation on the guide curve. On the right, the application of the\ncommand for the turtle. Three steps are made for the step forward: ﬁrst a\nreorientation R(A\n1 , α1 ) in the direction ofC (u + du), a move forward of\nlength ||C (u + du) − C (u)||, and a reorientationR(A2 , α2 ) in the direction of\nthe tangent atC (u + du). A1 and A2 have to be translated ﬁrst in the local\ncoordinate system of the turtle to be applied on the turtle.\nwww.frontiersin.org May 2012 | Volume 3 | Article 76 |19\nBoudon et al. L -Py, L -systems in Python\nIndeed, the length of the curve between C (u) and C (u + du) is\ndu but the curve between this two points is approximated with a\nstraight segment by the turtle. Thus the length of turtle step should\nbe changed for ||C (u + du) − C (u)||.\nThe turtle will thus produce a path with curvature similar to the\ncurve C when moving forward. Additionally, some rotations can\nalso be explicitly asked by the user to the turtle between each step.\nBy default, these rotations will provide additional curvature to the\nturtle path. For instance, trunk and main branches can be built\nusing the same SetGuide command except that at the begin-\nning of branches an additional rotation is made to have lateral\ndirection. In this case, guide and turtle are rigidly linked since the\nrotation of the turtle will also change the guide curve reference\nframe.\nIt is also possible to apply similar rotations of the turtle to the\nframe along the guide. For instance, the Roll operation consists\nin turning around the heading H of the turtle. Its counterpart\nconsists in turning the reference frame F (r, s, t ) of the curve C\nat C (u) around its tangentt. Both operations can be made at the\nsame time when turtle is requested to turn. In this case, guide and\nturtle are non-rigidly linked since a turtle rotation will change the\ncorresponding position and orientation on the curveC.S u c ho p e r -\nations are made possible in L-Py with special commandiRollR\nand iRollL.\nFrontiers in Plant Science| T echnical Advances in Plant Science May 2012 | Volume 3 | Article 76 |20",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.5476126670837402
    },
    {
      "name": "Plant system",
      "score": 0.45528823137283325
    },
    {
      "name": "Engineering",
      "score": 0.18141737580299377
    },
    {
      "name": "Agricultural engineering",
      "score": 0.17590898275375366
    }
  ]
}