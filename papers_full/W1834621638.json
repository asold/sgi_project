{
    "title": "Variability within Modeling Language Definitions",
    "url": "https://openalex.org/W1834621638",
    "year": 2009,
    "authors": [
        {
            "id": "https://openalex.org/A5033159888",
            "name": "Marı́a Victoria Cengarle",
            "affiliations": [
                "Technical University of Munich"
            ]
        },
        {
            "id": "https://openalex.org/A5042106606",
            "name": "Hans Grönniger",
            "affiliations": [
                "RWTH Aachen University"
            ]
        },
        {
            "id": "https://openalex.org/A5037823412",
            "name": "Bernhard Rumpe⋆",
            "affiliations": [
                "RWTH Aachen University"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W2016914525",
        "https://openalex.org/W1569208917",
        "https://openalex.org/W6630288668",
        "https://openalex.org/W1600872613",
        "https://openalex.org/W86236309",
        "https://openalex.org/W1549521321",
        "https://openalex.org/W2162354236",
        "https://openalex.org/W2131878172",
        "https://openalex.org/W1985364899",
        "https://openalex.org/W1565927860",
        "https://openalex.org/W1498279542",
        "https://openalex.org/W1578564352",
        "https://openalex.org/W2028920271",
        "https://openalex.org/W2144055181",
        "https://openalex.org/W2106192381",
        "https://openalex.org/W4285719527",
        "https://openalex.org/W124986576",
        "https://openalex.org/W2031721611",
        "https://openalex.org/W1913755735",
        "https://openalex.org/W1649645444",
        "https://openalex.org/W1500250067",
        "https://openalex.org/W1486228385",
        "https://openalex.org/W2470729518",
        "https://openalex.org/W2010039742"
    ],
    "abstract": null,
    "full_text": "Variability within\nModeling Language Deﬁnitions\nMar ´ıa Victoria Cengarle 1,H a n sG r ¨onniger2, and Bernhard Rumpe 2\n1 Software and Systems Engineering, T echnische Universit¨ at M¨unchen, Germany\n2 Lehrstuhl Software Engineering, R WTH Aachen, Germany\nAbstract. We present a taxonomy of the variability mechanisms of-\nfered by modeling languages. The deﬁnition of a formal language en-\ncompasses a syntax and a semantic domain as well as the mappin g that\nrelates them, thus language variabilities are classiﬁed accord ing to which\nof those three pillars they address. This work furthermore proposes a\nframework to explicitly document and manage the variation point s and\ntheir corresponding variants of a variable modeling language. T he frame-\nwork enables the systematic study of various kinds of variabili ties and\ntheir interdependencies. Moreover, it allows a methodical customiza tion\nof a language, for example, to a given application domain. Th e taxon-\nomy of variability is explicitly of interest for the UML to provid e a more\nprecise understanding of its variation points.\nKeywords: Modeling languages, variability, formal semantics, UML.\n1 Introduction\nA complete deﬁnition of a formal modeling language consists of the descr ip-\ntion of its syntax and its semantics (m eaning) [1]. It is widely accepted that a\ncommonly agreed formal deﬁnition (especially semantics) of a language h elps to\navoid misunderstandings and lack of interoperability betw een tools.\nIn [2], we presented a tool-based approach to deﬁne textual mo deling lan-\nguages and to formalize their semantics in a ﬂexible way usin g a theorem prover.\nWhile one of our main targets is the formalization of the Uniﬁe d Modeling Lan-\nguage (UML 2) [3,4], the approach is more general and applies to any mode ling\nlanguage based on objects.\nIn this paper, we investigate how variability in a language d eﬁnition can be\nformally speciﬁed. This work is inspired by the introductio n of semantic vari-\nation points in UML where portions of the language have been deliber ately\nincompletely speciﬁed. The beneﬁts of systematically desc ribing UML’s vari-\nability have been noted early [5]. The treatment of semantic variation points in\nthe UML, however, is rather disappointi ng. It was not systema tically carried out,\nsemantic variation points are dispersed across the documen tation. Moreover, the\nstandard fails to tag them completely: it suﬃces to look for u nderspeciﬁed se-\nmantic deﬁnitions in order to realize that there are far more sema ntic variation\npoints than those explicitly labeled as such.\n[CGR09] M. V. Cengarle, H. Grönniger, B. Rumpe \nVariability within Modeling Language Definitions \nIn: Model Driven Engineering Languages and Systems. Proceedings of MODELS 2009, LNCS 5795. \nDenver, Colorado, USA, October 2009 \nwww.se-rwth.de/publications\nVariability within Modeling Language Deﬁnitions 671\nBeyond UML, we are interested in a general treatment of variabi lity in model-\ning languages which may be of semantic and also of syntactic nature. Hen ce, one\ngoal of this work is to classify the kinds of variability that a modeling language\nmay oﬀer and their interdependencies. Additionally , we exte nd our approach\nfrom [2] and present a tool-based solution to deﬁne and conﬁg ure variability\nwithin a language deﬁnition.\nA systematic approach to variability should make it possibl e to explicitly state\nall (possibly implicit) assumptions and previously chosen variants. This allows a\nsystematic customization of a language for a given application domain . F urther-\nmore, tool builders can refer to particu lar variants in order to document design\ndecisions. V ariation points of modeling languages, unlike those of p roduct lines,\nare not associated with a binding time [6]. That is, tool build ers may delay the\nbinding of a variation point to a variant and leave the decision to pr oject man-\nagers. Moreover, these may even forward the disambiguation to mode lers. As for\nUML, currently implementors may provide [...] informal feature support state-\nments [...] for less precisely deﬁned dimensions such as presentation options and\nsemantic variation points” [3, Sect. 2.3]. W e improve this situation by making\nprecise the deﬁnition of the variability mechanisms oﬀered by a language.\nThe rest of this paper is organized as follows. Sect. 2 describes th e constituents\nof a modeling language deﬁnition. Sect. 3 presents our class iﬁcation of variability\nin a language deﬁnition. Sect. 4 introduces our tool-supported solut ion using\nfeature diagrams. The approach is illustrated with a simple example of UML-\nlike class diagrams. Sect. 5 discusses rel ated work and Sect. 6 draws conclusions\nand sketches future work.\n2 Constituents of a Modeling Language Deﬁnition\nAs shown in Fig. 1, a complete deﬁnition of a modeling language consist s of the\nfollowing basic parts:\n– the concrete syntax of the language, which may be a graphical or textual\nsyntax or a combination of both,\n– the abstract syntax to which the concrete syntax is mapped. F or a textual\nsyntax this may be given as abstract syntax trees. In case of graphical mod-\neling, metamodels are typically used. A dditionally , a set of well-formedness\nrules or context conditions are deﬁned,\n– some minimal abstract syntax that can be derived from the abs tract syntax\nby expressing more complex constructs of the language by pri mitive ones.\nThereby the number of constructs but not the expressive powe r of the lan-\nguage is reduced. This eases the deﬁnition of the semantics of the language .\nThis step may not be required for some languages,\n– a semantic domain, a domain well-known and understood, typi cally based\non a well-deﬁned mathematical theory , and\n– the semantic mapping that relates elements of the (minimal) abstract syntax\nto elements of the semantic domain.\n672 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\n\u0001\u0002\u0003\u0001\u0004\u0005\u0006\u0005\u0007\b\t\u0003\u0006\n\u000b\n\f\r\u000e\u000f\u0005\u0010\n\u0011\u0012\u000b\u0013\u0007\u0014\n\u0007\u0007\n\u0015\u0015\u0016\n\u0017\n\n\u0018\b\u0006\u0004\n\u0001\u0006\u0007\b\t\u0003\u0006\n\u000b \u0019\u000e\u0003\u000e\u0019\n\u000f\u0007\n\u0018\b\u0006\u0004\n\u0001\u0006\n\b\t\u0003\u0006\n\u000b\n\b\u0005\u0019\n\u0003\u0006\u000e\u0001\u0007\u001a\u0002\u0019\n\u000e\u0003\b\u0005\u0019\n\u0003\u0006\u000e\u0001\u0007\u0019\n\u001b\u001b\u000e\u0003\u001c\n\r\n\b \u000e\b\u0007\u0006\u0004\n\u0003\b\u001d\u0002\u0004\u0019\u0005\u001a\n\u0004\u0005\u000f\n\u0006\u0005\b\n\b\t\u0003\u0006\n\u000b\nFig. 1. Basic parts of a modeling language deﬁnition\n\u0001\u0002\u0003\u0002\u0004\u0005\u0006\n\u0007\b\u0002\b\t\n\u000b\u0002\f\r\u000e\n\u000f\u0010\u000f\n\u000f\n\u0011\n\u0002\n\u0012\u0011\n\u0011 \u0013\f\u0004\n\r\f\u0014 \u0015\u0016\u0002\u0004\n\b\n\u0017\u0018\u0019\u0002\u001a\n\u0010\u000e\u001b\u0002\n\u000f\u000e\b\n\u0002\u001c\u001d\f\u0005\u0002\u0014\nFig. 2. Theories that constitute the system model\nCharacteristic for our approach to deﬁne the semantics of a modeling language\nis a set-valued or predicative semantic mapping of the form sem(.): L→ ℘ (S).\nThe semantics of a model as an elemen t of the (minimal) abstract syntax m ∈L\nis therefore the set sem(m) of elements in the semantic domain S.\nW e deﬁned a single semantic domain S used as a target for the semantic\nmapping of various kinds of object-oriented modeling languages [7]. Th is do-\nmain, called system model, captures and in tegrates all aspects of object-oriented\nsystems using basic mathematical theories. It is rather det ailed as it deﬁnes var-\nious structural, behavioral, and interaction aspects, and is built in a modular\nfashion as depicted in Fig. 2. Systems in the system model are state transition\nsystems (theory STS). They operate on a global system state w hich is com-\nposed of object individual states (theory State). States co nstitute a data store\nfor attribute values of objects (theory Data), a control sto re (theory Control) for\nactive threads and computational states of methods, and an e vent store for un-\nprocessed events (theory Events). States evolve dynamical ly . Static information\n(e.g., which classes, methods, etc., exist) is deﬁned throu gh underspeciﬁed uni-\nverses containing abstract id entiﬁers only . F or example, UTYPE is the universe of\ntype names (deﬁned in theory Type). Classes are elements of t he universe UCLASS\n(theory Object) and are only described by functions that yield information about\nVariability within Modeling Language Deﬁnitions 673\ntheir attributes or methods, i.e., they are not constructed from records. Thus,\nthe deﬁnition of the system model is predicative and not cons tructive. F or a\ncomplete picture of the system model fea tures, the reader is referred to [7].\nThe system model as a single semantic domain and the set-valued seman tic\nmapping enable a straightforward treatment of composition and reﬁne ment of\npossibly incomplete and underspeciﬁed models of various mo deling languages [8].\nF or example, the integrated semantics of models m1,...,m n from possibly dif-\nferent languages L1,..., Ln is given as semL1 (m1) ∩ ... ∩ semLn (mn ). In the\nsame way , m′ ∈L is a reﬁnement of m ∈L , exactly if sem(m′) ⊆ sem(m).\n3 Classiﬁcation of Variability\nIn this section, we develop a classiﬁcation of variability t hat a modeling language\nmay oﬀer. W e do not restrict our attention to semantic variab ility (in UML\nterms, semantic variation points) but also consider syntac tic variability .\nIn a very abstract view, the syntax of a formal language is deﬁ ned by a set\nof words over some alphabet A, i.e., L⊆ A∗. Syntactic variability allows for\ndeﬁning more than one syntax, say L1 and L2, which normally contain many\ncommon words but are diﬀerent. That is, there is at least one m odel (i.e., word)\nm ∈ (L1 ∪L 2)\\(L1 ∩L 2) that is in one but not both languages. The semantics\nof a syntax L over some semantic domain S c a nb ed e ﬁ n e da s sem ⊆L×S\n(in a relational style). Semantic variability means more than one semantics,\nsay sem1 and sem2, for a given syntax L. These mappings may have diﬀerent\ncodomains S1 ̸= S2 or not. As with the syntax, sem1 and sem2 are mostly the\nsame but there is at least one model m a n da ne l e m e n t s for which ( m, s ) ∈\n(sem1 ∪sem2)\\(sem1 ∩sem2). So the meaning of the model diﬀers according to\nwhich semantics is chosen.\nThere naturally may be languages containing both kinds of va riability , and\nrelationships between both exist. In the f ollowing, we concretize this abstract\nview by analyzing how variants and their interdependencies can be classiﬁed.\n3.1 Syntactic V ariability\nRegarding concrete syntax (see Fig. 1), d iﬀerences can be given by , e.g., alterna-\ntive keywords such as “public” or “+” in case of modiﬁers, or t he font size, line\nthickness, and color of some graphical element. In UML, these are called pre-\nsentation options and can be classiﬁed as presentation variability.T h e yi m p r o v e\nthe readability of models. Nevertheless, presentation opti ons are so deﬁned that\nthe abstract syntax of models remains the same even if the options a re changed. 1\n1 This is an important assumption we make on presentation optio ns, namely that\nthey do not alter abstract syntax and hence the intended semantics of the presented\nmodel element. Font size, for instance, may have a meaning in c artography, where\ncities with bigger labels have more inhabitants. In the case o f cartography, therefore,\nfont size does matter and is not a presentation option.\n674 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\nW e do not classify presentation options as syntactic variab ility since they\ndo not make it possible to deﬁne diﬀerent languages. Their eﬀ ect exclusively\nconcerns the concrete syntax. They must , nevertheless, be registered and docu-\nmented.\nThe syntax of a language may allow the use of stereotypes. The term stereo-\ntype, borrowed from UML, is used here t o designate a general principle of ex-\ntending the syntax of a language. The concrete set of deﬁned s tereotypes (e.g.,\nas part of a proﬁle in case of UML) is classiﬁed as syntactic var iability .\nAnother kind of syntactic variability also found in the synta x is given by so-\ncalled language parameters. Concerning for instance UML, the language of state\nmachines deﬁnes transition systems whose transitions are t riggered by a stimulus\nsubject to a condition on the stimulus and/or the internal st ate of the object.\nThe language in which conditions (or guards) are expressed is not speciﬁ ed. This\nconstitutes a syntactic variability .\nIn the abstract syntax, optional context conditions may exist. Examples\nthereof, for instance for a particular cod e generator to operate, are the enforce-\nment of types of attributes of a class to be deﬁned, and the res triction to single\ninheritance only . Context conditions rule out certain mode ls based on syntactic\ncriteria. Only if the context c onditions are met, the model is well-formed and it\nmakes sense to give the model a semantics.\nThe syntax also may oﬀer constructs that enhance readabilit y and are seman-\ntically equivalent to other, usually more involved, expres sions of the language.\nSuch constructs are often referred to as “syntactic sugar” and may be safely\nomitted, since models of the language obtained by the use of those con structs\ncan be replaced by equivalent models that do not use the abbreviations.W ec l a s -\nsify this as presentation variability . In particular, the l anguage can be reduced\nto a minimal one, which not necessarily is unique. Note that a m inimal language\nderived this way may still allow synonyms, i.e., syntactica lly diﬀerent models m1\nand m2 that denote the same semantics sem(m1)= sem(m2).\nSummarizing, we classify any variability as syntactic vari ability that still may\nbe present in the minimal abstract syntax of a modeling language and hence in-\nteracts with the semantics. This variability originates fr om stereotypes, language\nparameters, and optional context conditions.\n3.2 Semantic V ariability\nWhile UML only uses the term semantic variation point, we furt her subdivide se-\nmantic variability into semantic mapping variability and semantic domain vari-\nability; cf. Fig. 1. A helpful analogy might be to see the variability of the semantic\nmapping similar to conﬁguration options of a code generator while variability of\nthe semantic domain has its analogy with properties of an und erlying run-time\nsystem or target platform.\nRegarding semantic domain variability , the system model de ﬁned in [7] already\ncontains explicit variability in form of extensions throug h optional deﬁnitions.\nIn general, semantic domain variants may provide alternati ve realizations of\nfunctions, additional constraints to properties of existing deﬁni tions, or optional\nVariability within Modeling Language Deﬁnitions 675\nstructures and deﬁnitions. Alternative r ealizations are, for example, diﬀerent\nnotions of type-safe method overriding. Additional constr aints are, for example,\nthe restriction to single inheritance onl y , or the requirement of certain predeﬁned\ntypes like, e.g., “String.”\nSimilarly , in the semantic mapping, the same mechanisms to i ntroduce vari-\nants apply . Semantic mapping variability often manifests a s alternative choices\nfor speciﬁc mapping functions while the target domain remai ns the same. F or in-\nstance, one mapping of super-classes of classes in a UML class diagram assumes\nmultiple inheritance in the semantic domain, while an alter native mapping uses\nsome delegation mechanism for a domain that may lack multipl e inheritance.\nAs this example shows, there are also various relationships betw een variants on\nthe diﬀerent levels which will be discussed in more detail in th e following. As\nanother example, consider the representation of states of a state mac hine in an\nimplementation as, e.g., a simple enumeration or using the s tate pattern [9].\nNote that semantic variability is transparent to the modeler . But it may be\nnecessary to allow the modeler to select on e or the other interpretation of a con-\nstruct. W e propose to model these interpretation choices as syntactic variability\nby providing corresponding stereotypes. F or instance, con sider the example of\na semantic mapping for a class which states that only a single instanc e of that\nclass may exist at run-time. One possibility would be to enco de this syntactically\nas a stereotype “singleton” which can be used by the modeler a nd which is used\nby the semantic mapping to associate exactly this meaning to the give n class.\nT able 1 provides a comprehensive summary of our modeling language va ri-\nability classiﬁcation.\nTable 1. Variability classiﬁcation summary\npresentation variability variability not present in a minimal abstract syntax\npresentation options aﬀect concrete syntax only\nabbreviations can be omitted without losing expressiveness\nsyntactic variability variability aﬀecting a minimal abstract syntax\nstereotypes syntactic encoding of semantic variability\nlanguage parameters usable with diﬀerent independent languages\ncontext conditions constrain the set of well-formed models\nsemantic variability variability in the semantics\nsemantic domain variability variability in the underlying target domain\nsemantic mapping variability diﬀerent choices for mapping functions\n3.3 Interdependency and Consistency\nDependencies between variants exist. These are characterized with the help of\nexamples. Consider the integration of multiple languages: One language m ight\nbe parameter to another, e.g., a constraint or action language. Addi tionally , lan-\nguages may be mainly orthogonal and used to describe diﬀerent views of th e\nsame system such a class and state machin e diagrams. In any of these cases, dif-\nferent assumption on the underlying domain may be made, i.e. , diﬀerent variants\n676 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\nof the semantic domain may be assumed. Moreover, a language that is par ameter\nto another is equipped with a semantics that has to ﬁt the assumpt ions made\nby the parametric language.\nContext conditions may inﬂuence the selection of a speciﬁc s emantic map-\nping. F or instance, if the context conditions for UML class diagrams gu arantee\nthat multiple inheritance is syntactically excluded, then one can safely select a\nsemantic mapping that only handles single inheritance. Sim ilarly , if a semantic\ndomain only allows for single inherita nce, then a delegate mechanism must be\nresorted to by the semantic mapping of UML class diagrams in case multi ple\ninheritance is allowed syntactically .\nF rom these examples we conclude that it is important to capture all pos sible\nvariants and their interdependencies. W e propose to model t hem using feature\ndiagrams including constraints that state inclusion or exc lusion between vari-\nants [10]. 2 As a supplement, informal descriptions of the variabilities can be\ngiven to explain their raison d’ˆ etre. The proposed approach is completely sup-\nported by tools and will be described in the next section.\nUnfortunately , capturing variants as feature diagrams and constrain ts does\nnot guarantee that a concrete conﬁguration of variants that conforms to the\ngiven feature diagrams is consistent. Since we have many con ﬁguration options,\nwe might have not captured all constraints to rule out inconsistent, u nwanted,\nor simply uninteresting conﬁgurations. Especially when in tegrating multiple lan-\nguages, there is a possible risk of contradicting mapping fu nctions. One way to\nobtain a consistent set of theories is to actually prove consistency . That is, given\ntwo languages L1 and L2 with semantic mappings sem1 and sem2,t os h o w\nsem1(m1) ∩ sem2(m2) ̸= ∅\nfor some witnesses m1 ∈L 1 and m2 ∈L 2.\n4 Deﬁnition and Conﬁguration of Variability\nW e now describe the actual deﬁnition and conﬁguration of var iability in a mod-\neling language with respect to the conﬁgurable semantic mapping and the like-\nwise conﬁgurable semantic domain. Syntactic variability s uch as optional context\nconditions and language parameters can be handled similarl y and are therefore\nomitted here. The presentation is accompanied by a simple ru nning example.\nThe whole approach of deﬁning a language and its variabiliti es is supported by\ntwo tools. The basic tool-based approach (neglecting varia bility) has been pre-\nsented in [2] and is summarized below. It fe atures a complete, formal, ﬂexible,\nand machine-readable deﬁnition of modeling languages using the tools Monti-\nCore and Isabelle/HOL.\n2 There is an inclusion relation between two or more variants if the choice of one makes\nit mandatory to choose the other(s). There is an exclusion relation be tween two or\nmore variants if the choice of one forbids the choice of the other(s).\nVariability within Modeling Language Deﬁnitions 677\n\u0001\u0002\u0003\u0004\u0005\u0006\u0002\u0007\b\n\t\u0007\n\u000b\u000b\n\u0007\n\t\b\u0003\b\u0007\n\u0004\b\f \n\r\f\u0004\u0007\n\u000e\u0004\u000f\f\u0010\u0003\u0004\n\u0011\u000f\n\u0012\u0013\f\n\r\b\u0014\u0014\b\u0015\u0016\u0017\u0018\u000f\n\u0004\u0019\b\u0002\u0007\u0010\u001a\n\f\b\u000b\n\u0003\u0004\u0005\u000e\n\u000b\n\u001b\u001b\u0005\u0003\t\n\u0012\u0013\f\n\r\b\u0014\u0014\b\u0015\u0016\u0017\u0018\u000f\u0004\u0019\b\u0002\u0007\u0005\b\f\u001a\n\u001c\f\b\f\n\f\u0010\f\u0004\b\u000b\u000f\u000b\u0002\u001d\b\u0014\u000f\n\u0012\u0013\f\n\r\b\u0014\u0014\b\u0015\u0016\u0017\u0018\u000f\n\u0004\u0019\b\u0002\u0007\u0005\b\f\u001a\nFig. 3. Approach with tool support\n4.1 Prerequisites\nThe basic approach is depicted in Fig. 3. MontiCore [11] is a framewo rk for\nthe textual deﬁnition of languages based on an extended context-free g rammar\nformat. W e use MontiCore to deﬁne the concrete syntax of a language because\nit provides enhanced modularity concepts like language inh eritance and embed-\nding (not used in the simple running example, though). Sophi sticated framework\nfunctionality allows, for example, an easy development of generator s. Note that\nthe general idea can similarly be imple mented using, e.g., metamodeling.\nT o provide a semantics developer with maximum ﬂexibility an d also with some\nmachine checking (e.g., type checking) as well as the potential for veriﬁcation\napplications, we use the theorem prover Isabelle/HOL [12] for\n– the formalization of the system model as a hierarchy of theor ies,\n– the representation of the abstract syntax of the language as a deep embed -\nding [13], and\n– the actual semantic mapping that uses the generated abst ract syntax and\nmaps each language construct to predicates over systems of t he formalized\nsystem model.\nConcrete Syntax. The example grammar CDSimp in Fig. 4 deﬁnes UML-like\nclass diagrams with classes that can have super-classes. MontiCore grammars\n1 grammar CDSimp {\n2 CDDefinition = \"classdiagram\" Name:IDENT \"{\" (CDClass)* \"}\";\n3\n4 CDClass =\n5 \"class\" Name:IDENT (\"extends\" scl:IDENT (\",\" scl:IDENT)*)?\";\";\n6 }\nFig. 4. MontiCore grammar of class diagrams\nhave terminal symbols enclosed in quotes (see, e.g., Fig. 4, line 2) and support\nKleene closure ( *) and option ( ?), among other constructs. The two rules of\nCDSimp use the built-in identiﬁer rule IDENT. Nonterminals may be preﬁxed by\ndescriptive names followed by a colon (like IDENT,l .2 ) .A c c o r d i n gt oF i g .4 ,a\nclass diagram deﬁnition (l. 2) has a name and a set of classes. Classes (l. 4) have\na name and a comma separated list of names that refer to super-class es.\n678 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\nAbstract Syntax. A MontiCore generator produces the Isabelle/HOL data\ntype deﬁnition in theory CDSimpAS (see Fig. 5) from the grammar in Fig. 4.\n1 theory CDSimpAS imports GeneralAS\n2 begin\n3 datatype CDClass =\n4 CDClass IDENT \"IDENT list\"\n5\n6 datatype CDDefinition =\n7 CDDefinition IDENT \"CDClass list\"\n8 end\nFig. 5. Generated abstract syntax data type in Isabelle/HOL\nIsabelle/HOL data types have a name (e.g., CDClass in Fig. 5, l. 3), a construc-\ntor (also CDClass, l. 4), and a list of arguments. Data type IDENT is deﬁned in the\nimported, re-usable theory GeneralAS and iteration in a grammar is translated\nto the built-in data type list (e.g., l. 4). A complete account on the mapping\nof MontiCore grammars to Isabelle/HOL can be found in [2].\nSystem Model. W e have formalized the system model, introduced in Sect. 2,\nin Isabelle/HOL as a hierarchy of theories.\n1 theory Object imports Type\n2 begin\n3 datatype iCLASS = Class \"char list\"\n4\n5 consts\n6 UCLASS :: \"SystemModel ⇒ iCLASS set\"\n7 sub :: \"SystemModel ⇒ iCLASS ⇒ iCLASS ⇒ bool\"\n8\n9 fun psubRefl :: \"SystemModel ⇒ bool\"\n10 where \"psubRefl sm = (∀ C ∈ UCLASS sm . sub sm C C)\"\n11 end\nFig. 6. Isabelle/HOL theory Object (excerpt)\nFig. 6 shows a small excerpt from the theory Object which introduces the\nuniverse of classes UCLASS (line 6) as a function that yields a set of class names (of\ntype iCLASS). consts is Isabelle’s way of declaring a constant without deﬁning\nit. Additionally , a subclassing relation sub is declared. The boolean function\ndeﬁnition psubRefl is a simple example of a predicate that must hold in all\nvalid systems and requires reﬂexivity of the subclassing re lation.\nThe top-level theory SystemModel-base (Fig. 7) imports all basic deﬁnitions\nand deﬁnes a predicate valid-base. In our abbreviated example, only theory\nObject is imported. The full theory would import all other theories from Fig. 2\nand combine all predicates (like psubRefl)i n t o valid-base, describing all prop-\nerties of a valid system in the system model.\nVariability within Modeling Language Deﬁnitions 679\n1 theory SystemModel-base imports Object\n2 begin\n3 fun valid-base :: \"SystemModel ⇒ bool\"\n4 where \"valid-base sm = (psubRefl sm ∧ ... )\"\n5 end\nFig. 7. Isabelle/HOL theory SystemModel-base (excerpt)\nSemantic Mapping. The semantic mapping of our simpliﬁed class diagrams is\nlikewise formalized in Isabelle/HOL. The theory in Fig. 8 im ports the abstract\nsyntax and the system model theory and deﬁnes the mapping. W e only state\nthe signatures of the mapping functions, which are built in a modular fashion\nalong the abstract syntax. Note that the mapping functions for classes and class\ndiagrams, mCDClass and mCDDefinition, are function deﬁnitions (using the key-\nword fun) while the mapping of super-classes of a class, consts mSuperClasses,\nagain is just a function declaration whose body has not yet been deﬁne d.\n1 theory CDSimpSem-base imports CDSimpAS SystemModel\n2 begin\n3 consts mSuperClasses :: \"iCLASS ⇒ IDENT list ⇒ SystemModel ⇒ bool\"\n4\n5 fun mCDClass :: \"CDClass ⇒ SystemModel ⇒ bool\"\n6 where ...\n7\n8 fun mCDDefinition :: \"CDDefinition ⇒ SystemModel set\"\n9 where ...\n10 end\nFig. 8. Semantic mapping of the simpliﬁed class diagram in Isabelle/ HOL\n4.2 Deﬁnition of V ariants\nW e start by introducing a variant for the system model. Fig. 9 cont ains a theory\nwith an additional constraint for the transitive subclassi ng relation, restricting\nit to single inheritance. That is, for all classes C1, C2, C3,i f C1 is a sub class of\nC2 and C3,t h e n C2 and C3 have to be in a subclass relationship (or equal due to\nreﬂexivity of sub).\nAs explained before, we model variants of theories as feature diagram s like\nthe one in Fig. 10 3. Ignoring the check mark for a moment, the feature dia-\ngram therein states that SingleInheritance is an optional feature of the the-\nory Object. Other variants may be associated with other theories as the other\nvariation point vType indicates.\n3 In our tool suite, we use a textual version of feature diagrams and conﬁgura tion ﬁles\nbut we stick to the standard graphical form for the sake of clarity of the presentation.\n680 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\n1 theory SingleInheritance imports Object\n2 begin\n3 fun valid-SingleInheritance :: \"SystemModel ⇒ bool\"\n4 where \"valid-SingleInheritance sm = (∀ C1 C2 C3.\n5 sub sm C1 C2 ∧ sub sm C1 C3 −→ (sub sm C2 C3 ∨ sub sm C3 C2))\"\n6 end\nFig. 9. Deﬁnition of an Isabelle/HOL predicate about single inheritance\n\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\u0005\n\u000b\f\u0002\r\u0005 \u000b\u000e\u000f\u0010\u0005\u0011\u0004 \u0012\u0012\u0012\n\u0001\u0013\u0014\u0015\n\u0005\u0016\u0014\u0017\u0005\u0018\u0013\u0004\u0019\u0014\u0011\u0005\u0012\u0012\u0012\n\u001a\u0005\u0015\u0005\u0014\t\u001b\n\b\r\u0004\u0013\b\u0014\u0019\n\u001c\u001d\u0005\u0019\u0004\u001e\u0018\u0005\u0001\n\u0001 \u0003\u0005\n\u0005\u0011\u0004\u0005\t\u001c\b\r\u0004\u0013\b\u0014\u0019\n\u001c\u001d\u0005\u0019\u0004\u001e\u0018\u0005\n\u001d\u0005\u0019\u0004\u001e\u0018\u0005\u001c\t\u0013\u0019\u0015\u0018\u0019\u0006\nFig. 10. Semantic domain feature diagram (fragment)\nAdditionally , the feature diagram for the variants of the semantic mapp ing\ncan be found in Fig. 11. The class diagram semantics has two variants for th e\nmapping of super-classes. The variant mapSuperCDirect carries an additional\nconstraint which excludes the use of variant SingleInheritance for the system\nmodel. The actual implementation of the theories has been om itted.\n\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\n\r\u000e\u0007\u000f\u0010\f\f\u0011\u000b\f \r\u000e\u0007\u000f\u0004\u0012\u000f\u0005\u0013\u0001\u0014\u0007\f\f\u0005\f \u0015\u0015\u0015\n\u0006\u0007\u000f\u0004\u0012\u000f\u0005\u0013\u0001\u0002\n\u0013\u0005\u000b\t \u0006\u0007\u000f\u0004\u0012\u000f\u0005\u0013\u0001\u0002\u0005\u0014\u0005\u0016\u0007\t\u0005\n\u0005\u0017\u000b\u0014\u0012\u0018\u0005\f\n\u0004\u0019\f\t\u0005\u0006\u000e\u0011\u0018\u0005\u0014\u0015\n\u0003\u0003\r\u001a\u001b\u001c\u0005\u000b\t\u0015\u0004\n\b\u0016\u0014\u0005\u001d\b\u001e\u0005\u0013\n\t\u0007\b\u000b\u0005\n\u001f\u0005\u0016\u0005\b\u0018 \n\u0011\u000f\t\n\u0011\b\u0007\u0014\u0003!\u0005\u0007\t\u0012\u0013\u0005\n\u0007\u0014\t\u0005\u0013\b\u0007\t\n\r\u0005\u0003!\u0005\u0007\t\u0012\u0013\u0005\n\u0015\u0015\u0015 \n\b\u000b\u0014\u0012\f\n\u0011\b\"\u0005\u0017\u000b\u0014\u0012\f\n\u0011\b\n\u000b\u0011\b\f\t\u0013\u0007\n\b\t\n\u0001\n\u0001 \f\u0005\u0014\u0005\u000b\t\u0005\u0018\u0003\u0011\u000f\t\n\u0011\b\u0007\u0014\u0003!\u0005\u0007\t\u0012\u0013\u0005\n!\u0005\u0007\t\u0012\u0013\u0005\u0003\u0018\n\u0007\u0016\u0013\u0007\u0006\nFig. 11. Semantic mapping feature diagram (fragment)\n4.3 Conﬁguration\nThe conﬁguration space of the simple class diagram language has been deﬁned\nabove with the help of feature diagrams. A concrete conﬁguration for a sy stem\nmodel is also given in Fig. 10, in which the single inheritanc e variant is selected\nas indicated by the check mark. As a conﬁguration for the class diagram s emantic\nmapping, we select variant mapSuperCDelegate (see Fig. 11); choosing the other\nvariant would violate the exclusion constraint.\nVariability within Modeling Language Deﬁnitions 681\nA generator written for MontiCore processes a set of conﬁguration ﬁ les (mul-\ntiple conﬁgurations of, e.g., the system model may be deﬁned ). It ﬁrst com-\nbines conﬁguration ﬁles that refer to the same feature diagr am. Then, it checks\nif the conﬁgurations conform to the feature diagrams and if t he constraints\nhave been observed. Afterwards, the co nﬁgured theories for the system model\nand the semantic mapping are generated. In case of a system mo del conﬁgu-\nration, the generated theory (see Fig. 12) combines all predicates (l ine 4) from\nthe imported theories that constitute the conﬁguration. Th is is done by name\nconvention: The theory SingleInheritance has to provide a predicate called\nvalid-SingleInheritance.\n1 theory SystemModel imports SystemModel-base\n2 \"vObject/SingleInheritance\"\n3 begin\n4 constdefs \"valid sm == valid-base sm ∧ valid-SingleInheritance sm\"\n5 end\nFig. 12. Resulting generated system model theory in Isabelle/HOL\nFig. 13 shows the resulting (generated) class diagram semantic mappi ng. It\nsimply combines the chosen theories using the Isabelle/HOL import mechanism.\nT h el o o s ee n di nF i g .8 ,n amely the declaration mSuperClasses, is automatically\nbound to the deﬁnition provided in theory MapSuperCDelegate.\n1 theory CDSimpSem imports CDSimpSem-base\n2 \"vMapSuperClasses/MapSuperCDelegate\"\n3 begin end\nFig. 13. Resulting generated class diagram semantics theory in Isabell e/HOL\nFinally , the theory in Fig. 14 uses the generated semantic ma pping theory . The\ngenerated system model theory was already used in Fig. 8 by th e base version of\nthe semantic mapping. Presenting a meaningful veriﬁcation application is outside\nthe scope of this paper, a simple veriﬁca tion example has been given in [2]. The\nscenario in Fig. 14, however, suﬃces to show, on the one hand, how var iants in\na language deﬁnition can be systematically handled using fe ature diagrams. On\nthe other, it shows that the whole approach can be supported b y tools. In this\nscenario, property P (Fig. 14, l. 3) ranges over all class diagrams and all systems.\nIn [2], we also presented an additional generator that translates c oncrete textual\nmodels to instances of the generated ab stract syntax data type. This makes it\nalso possible to reason about properties of concrete models .\nThe instantiation of variants is done at the theory level. W e could h ave made\nall variation points type parameters, similar to [14]. A con ﬁguration would then\ncorrespond to instantiating type parameters with concrete type s. W e refrained\nfrom doing so because the readability of the theories would h ave been drastically\nreduced and it would be no longer possible to leave variants u nderspeciﬁed.\n682 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\n1 theory myVerifyApp imports CDSimpSem\n2 begin\n3 lemma \"∀ cd sm . mCDDefinition cd sm ∧ valid sm −→ P cd sm\"\n4 ... done\n5 end\nFig. 14. A possible veriﬁcation scenario in Isabelle/HOL\n5 Related Work\nT o the best of our knowledge, there is no previous work on a gen eral classiﬁcation\nof variability mechanisms oﬀered by modeling languages. [1 5] also suggests fea-\nture models to express language variabilities. The focus is on syntactic variability\nand variable code generators, formal semantics is not addressed.\nRegarding the presented tool support for formal language deﬁnitions, most re-\nlated approaches do not consider variability . F or example, a complete language\ndeﬁnition (including syntax, typing rules, and operationa l semantics) can be\nexpressed in Alloy [16], which has the advantage of immediat e analyzability . Se-\nmantic anchoring [17] is another approach to deﬁne semantics with t ool support.\nOperational semantics is given by generated abstract state machines.\nOther works support semantic variability to a certain exten t. T emplate seman-\ntics [18] can be used to deﬁne the behavio ral semantics of stat e-based modeling\nnotations. The execution semantics is based on parametric hierarc hical transition\nsystems whose behavior can be conﬁgured with the help of pred eﬁned template\nparameters. In [19], template semantics is employed to deﬁn e the semantics of\nUML state machines. The semantics explicitly models the vari ability found in the\nUML standard. [20,21] describe semantically conﬁgurable Jav a code generation\nand analyzable models using template semantics. T emplate s emantics provides\na rich theory for state-based modeling notation variants but is res tricted to be-\nhavioral semantics that furthermore ﬁts the computational model. T emplatable\nmetamodels, introduced in [22,23], is a similar approach pr esented for metamod-\neling the abstract syntax and operational semantics of a domain spec iﬁc modeling\nlanguage. It uses the UML 2 proﬁle and template mechanisms to d eﬁne variation\npoints at the metamodel level and to bind the introduced gene ric types to con-\ncrete types at the metamodeling or mode ling level. Like template semantics, the\napproach is targeted towards behavioral semantics but its mechanism s are more\ncompliant with the UML standard. Quite diﬀerently , [24] proposes an approach\nto model semantic variation points and implementation choices as c lass models\nin their own right. These are transformed together with a source UML model\ninto a speciﬁc target UML model that reﬂ ects the chosen variants. The focus in\nthis work is also behavioral semantics in that variants correspond to operations\nimplemented in an action language. W e are not aware of any other frame work\nthat supports deﬁning and conﬁguring syntactic and semanti c variability in a\nformal language deﬁnition.\nVariability within Modeling Language Deﬁnitions 683\n6C o n c l u s i o n\nThe contribution of this work is twofold. First, we presented a taxonomy of\nvariability mechanisms that may be found in a modeling langu age deﬁnition.\nV ariability may be of presentation, syntactic or semantic n ature. Opposed to\nUML, which only talks about “semantic variation points” in general, w e further\nclassify semantic variability according to semantic domai n and semantic mapping\nvariability . Semantic domain variability can be thought of as variability in some\nrun-time system modeling the underlying platform assumpti ons, while semantic\nmapping variability would correspond to conﬁguration opti ons in a generator\ntargeting a previously chosen (i.e., conﬁgured) run-time s ystem.\nSecond, we extended our framework for deﬁning the syntax and semantics of\nan object-oriented modeling language by integrating the va riability mechanisms\nthat we have identiﬁed. The tool suite built on MontiCore and Isabelle/HOL\nuses feature diagrams with inclusion/exclusion constraints to model variants and\ntheir interdependencies in the syntax, semantic domain, an d semantic mapping.\nGiven a conﬁguration of variants for possibly multiple modeling languages, the\nframework generates a set of theories repr esenting the integrated language deﬁni-\ntions. This set of theories can be used in several veriﬁcation scenar ios. Note that,\nwhile the framework is tailored towards object-oriented mo deling languages, the\ntaxonomy mentioned above applies to any kind of modeling lan guage. Likewise,\nthe framework could be used for semantic domains other than t he system model.\nF uture work will be concerned with elaborating variability for concrete mod-\neling languages; larger case studies will contribute to validate the p roposal and,\nin particular, the tool support. The long term goal, regarding one of our main\ntargets UML, is to provide a comprehensive feature model for U ML variability\nwhich ultimately could replace the currently used informal deﬁnitions and feature\nsupport statements. Another line of work is veriﬁcation within our framework.\nTheorem proving is challenging. The eﬀect of variability in concrete veriﬁcation\nscenarios is not very well discussed and may require substan tial further research.\nReferences\n1. Harel, D., Rumpe, B.: Meaningful Modeling: What’s the Semanti cs of “Semantics”?\nComputer 37(10), 64–72 (2004)\n2. Gr¨ onniger, H., Ringert, J.O., Rumpe, B.: System Model-Base d Deﬁnition of Mod-\neling Language Semantics. In: FMOODS/FORTE 2009. LNCS, vol. 5522, pp. 152–\n166. Springer, Heidelberg (2009)\n3. Object Management Group: Uniﬁed Modeling Language: Superstruc ture Version\n2.1.2 (07-11-02) (2007), http://www.omg.org/docs/formal/07-11-02.pdf\n4. Object Management Group: Uniﬁed Modeling Language: Infrastruc ture Version\n2.1.2 (07-11-04) (2007), http://www.omg.org/docs/formal/07-11-04.pdf\n5. Cook, S., Kleppe, A., Warmer, J., Mitchell, R., Rumpe, B., Wil ls, A.C.: Deﬁning\nUML Family Members Using Prefaces. In: Proc. of TOOLS 1999, Washin gton, DC,\nUSA, pp. 102–114. IEEE Computer Society, Los Alamitos (1999 )\n684 M.V. Cengarle, H. Gr¨ onniger, and B. Rumpe\n6. Deelstra, S., Sinnema, M., Nijhuis, J., Bosch, J.: COSV AM: A T echniq ue for As-\nsessing Software Variability in Software Product Families. In: Pro c. of ICSM 2004,\npp. 458–462. IEEE Computer Society, Los Alamitos (2004)\n7. Broy, M., Cengarle, M.V., Gr¨ onniger, H., Rumpe, B.: Modular Description of a\nComprehensive Semantics Model for the UML (Version 2.0). Informa tik-Bericht\n2008-06, T echnische Universit¨at Braunschweig (2008)\n8. Rumpe, B.: Formale Methodik des Entwurfs verteilter objektorien tierter Systeme.\nDoktorarbeit, T echnische Universit¨at M¨ unchen (1996)\n9. Gamma, E., Helm, R., Johnson, R., Vlissides, J.: Design pa tterns: elements of\nreusable object-oriented software. Addison-Wesley Professional , Reading (1995)\n10. Czarnecki, K., Eisenecker, U.W.: Generative Programming: Me thods, T ools, and\nApplications. Addison-Wesley, Reading (2000)\n11. Krahn, H., Rumpe, B., V¨ olkel, S.: MontiCore: Modular Development of T extual\nDomain Speciﬁc Languages. In: Proceedings of T ools Europe (2 008)\n12. Nipkow, T., Paulson, L.C., Wenzel, M.: Isabelle/HOL - A Pro of Assistant for\nHigher-Order Logic. Springer, Heidelberg (2002)\n13. Wildmoser, M., Nipkow, T.: Certifying Machine Code Safety: Shal low versus Deep\nEmbedding. In: Slind, K., Bunker, A., Gopalakrishnan, G.C. ( eds.) TPHOLs 2004.\nLNCS, vol. 3223, pp. 305–320. Springer, Heidelberg (2004)\n14. Shankar, S., Asa, S., Sipos, V., Xu, X.: Reasoning about rea l-time statecharts in\nthe presence of semantic variations. In: Proc. of ASE 2005, pp. 2 43–252. ACM,\nNew York (2005)\n15. V¨olter, M.: A Family of Languages for Architecture Description. I n: 8th OOPSLA\nWorkshop on Domain-Speciﬁc Modeling (DSM 2008), University of Alabama at\nBirmingham (2008)\n16. Kelsen, P., Ma, Q.: A Lightweight Approach for Deﬁning the Formal Semantics of\na Modeling Language. In: Czarnecki, K., Ober, I., Bruel, J.-M., U hl, A., V¨olter, M.\n(eds.) MODELS 2008. LNCS, vol. 5301, pp. 690–704. Springer, He idelberg (2008)\n17. Chen, K., Sztipanovits, J., Abdelwahed, S., Jackson, E.K.: Se mantic anchoring\nwith model transformations. In: Hartman, A., Kreische, D. (eds.) ECMDA- F A\n2005. LNCS, vol. 3748, pp. 115–129. Springer, Heidelberg (200 5)\n18. Niu, J., Atlee, J.M., Day, N.A.: T emplate Semantics for Mod el-Based Notations.\nIEEE T rans. Software Eng. 29(10), 866–882 (2003)\n19. T aleghani, A., Atlee, J.M.: Semantic Variations Among UML StateMachines. In:\nNierstrasz, O., Whittle, J., Harel, D., Reggio, G. (eds.) MoDELS 2006. LNCS,\nvol. 4199, pp. 245–259. Springer, Heidelberg (2006)\n20. Prout, A., Atlee, J.M., Day, N.A., Shaker, P .: Semantically Conﬁgurable Code\nGeneration. In: Czarnecki, K., Ober, I., Bruel, J.-M., Uhl, A., V¨ olter, M. (eds.)\nMODELS 2008. LNCS, vol. 5301, pp. 705–720. Springer, Heidelbe rg (2008)\n21. Atlee, J.M., Day, N.A., Niu, J., Kang, E., Lu, Y., F ung, D., W ong , L.: Metro: An\nAnalysis T oolkit for T emplate Semantics. T echnical Report C S-2006-34, David R.\nCheriton School of Computer Science, University of Waterloo (2 006)\n22. Cuccuru, A., Mraidha, C., T errier, F., G´ erard, S.: T emplatable Metamodels for Se-\nmantic Variation Points. In: Akehurst, D.H., Vogel, R., Paige , R.F. (eds.) ECMDA-\nF A. LNCS, vol. 4530, pp. 68–82. Springer, Heidelberg (2007)\n2 3 . C u c c u r u ,A . ,M r a i d h a ,C . ,T e r r i e r ,F . ,G ´erard, S.: Enhancing UML Extensions with\nOperational Semantics. In: Engels, G., Opdyke, B., Schmidt, D.C., Weil, F. (eds.)\nMODELS 2007. LNCS, vol. 4735, pp. 271–285. Springer, Heidelbe rg (2007)\n24. Chauvel, F., J´ ez´equel, J.M.: Code Generation from UML Models with Seman-\ntic Variation Points. In: Briand, L.C., Williams, C. (eds.) Mo DELS 2005. LNCS,\nvol. 3713, pp. 54–68. Springer, Heidelberg (2005)"
}