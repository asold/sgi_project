{
    "title": "The Systems Modeling Language for Products and Systems Development.",
    "url": "https://openalex.org/W2080635904",
    "year": 2007,
    "authors": [
        {
            "id": "https://openalex.org/A5042749880",
            "name": "Laurent Balmelli",
            "affiliations": [
                "IBM Research - Tokyo",
                "Keio University",
                "IBM (United States)"
            ]
        }
    ],
    "references": [
        "https://openalex.org/W4237137266"
    ],
    "abstract": "In this paper we present an overview of the capabilities of the Systems Modeling Language (SysML.)SysML is a standard from the Object Management Group.It is geared toward incrementally refinable description of conceptual design and product architecture.Elements in the design represent abstractions of artifacts in the various engineering disciplines involved in the development of the system.The design represents how these artifacts collaborate to provide the product functionalities.This paper explores all the diagrams available in SysML through the real-life example of an embedded system.",
    "full_text": "JOURNAL OF OBJECT TECHNOLOGY \nOnline at http://www.jot.fm. Published by ETH Zurich, Chair of Software Engineering ©JOT, 2007 \n \nVol. 6, No. 6, July-August 2007 \n \n \n \n \nCite this article as follows: Laurent Balmelli: “An Overview of the Systems Modeling Language for \nProducts and Systems Development”, in Journal of Object Technology, vol. 6, no. 6, July-August \n2007, pp. 149-177 http://www.jot.fm/issues/issue_2007_07/article2 \nAn Overview of the Systems Modeling \nLanguage for Products and Systems \nDevelopment \nLaurent Balmelli, Ph.D., Manager, International Business Machine (IBM), \nResearch Division, T.J.Watson Center \nAbstract \nIn this paper we present an overview of  the capabilities of the Systems Modeling \nLanguage (SysML.) SysML is a standard from the Object Management Group. It is \ngeared toward incrementally refinable descrip tion of conceptual design and product \narchitecture. Elements in the design represent abstractions of artifacts in the various \nengineering disciplines involved in the development of the system. The design \nrepresents how these artifacts collaborate to provide the product functionalities. This \npaper explores all the diagrams available in  SysML through the real-life example of an \nembedded system. \n1 INTRODUCTION \nToday's competitive pressures and other market  forces drive manufacturing companies to \nimprove the efficiency with which they de sign and manufacture pr oducts and systems. \nAcross the product lifecycle, one area where ther e has been a notorious lack of efficiency \nsupport is the conceptu al stage, during which the func tional architecture (and sometimes \nthe physical architecture) is decided upon.  \nThe conceptual stage follows  the transformation of customer needs into product \nfunctions and use cases, and precedes the design of these functions across the engineering \ndisciplines (for example, mechanical, electrica l, software, etc.). A lack of support during \nproduct conceptualization make s it difficult to efficiently trace the realization of \nrequirements in the product. The lack of a fo rmal representation for concepts also results \nin an inadequate ability to make decisions at  the level of systems in  the product, such as \nduring feasibility studies. More over, the lack of a clear vision of the product architecture \nhinders team understanding and communication, whic h in turn often incr eases the risk of \nintegration issues. It is these and other cha llenges confronted during the conceptual phase \nof product and system development that SysML is designed to mitigate. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n150 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nSysML is based on the actual standard for software engineering, the Unified \nModeling Language (UML) developed within  the Object Management Group (OMG) \nconsortium. SysML was developed as a response to the request for proposal (RFP) issued \nby the OMG in March 2003. The development team includes representatives from more \nthan ten companies. IBM has played a leadership role in the definition of the standard by \nauthoring part of the specification. \n \nFigure 1 Comparison of SysML1.0 with UML2.0: The text in the figure summarizes the various diagrams \navailable in SysML. Requirements, Parametrics and Allocations are new diagrams available only in \nSysML. Activity and Block diagrams are reused from UML2.0 and extended in SysML. Lastly, State \nMachines, Interactions and Use cases are reused from UML2.0 without modifications. \nSysML is a modeling language for representi ng systems and product architectures, as \nwell as their behavior and functionalities. It builds on the experience gained in the \nsoftware engineering discipline of building software architectures in UML (think of the \nclassic Class Diagram.) The architecture repres ents the elements realizing the functional \naspect of their product. The physical aspect is sometimes represented too, for example \nwhen the architecture represents how the software is deployed on a set of computing \nresources. \nThe overview of SysML presented in this pa per covers all the diagrams available in \nSysML. We explore most of the constructs attached to this diagram and refer to the OMG \nspecification [OMGSysML] for the ones that we do not address. In –Figure1 we compare \nSysML1.0 to UML2.0 in term of re-use. The te xt in the figure summarizes the various \ndiagrams available in SysML. Requirements, Parametrics and Allocations are new \ndiagrams available only in SysML. Activity  and Block diagrams are reused from \nUML2.0 and extended in SysML. Lastly, State Machines, Interactions and Use cases are \nreused from UML2.0 without modifications. \nWe explore the capabilities of SysML through an example: the Rain Sensing Wiper  \n(RSW) system. This sample problem is inspired from a real-life product failure that can be \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 151 \neasily found using your preferred Internet search engine. In  Appendix A we explain in \ndetails the background story of the example that we are using in this paper. This example \nis a nice illustration of the importance of having an understanding of a product at the \nlevel of its sub-systems in order to prev ent complex failure modes involving costly \nproduct recalls. In the story, the product manufacturer endur es a lengthy (hence costly) \nroot cause analysis that eventually requires a design change. In this article, we present a \nmodel that is resilient to the failure experienced by the manufacturer. \nWe briefly explain now the purpose of the RSW: The goal of the RSW is to wipe the \nsurface of the windshield automatically (i.e. wi thout user intervention) whenever droplets \nof liquid are detected. In addition, the amount of  liquid detected dictates the speed of the \nwiper. This system has three main components: the software that controls the behavior of \nthe wiper, an electronic control unit that ex ecutes the software and a sensor fixed on the \nwindshield whose task is to sense droplets through the windshield. \nIn this article, we give a detailed model that describes many aspects of this system. \nThis example constitutes a realistic product in  the area of embedded electronics (for the \nautomotive industry) whose design greatly benefits from a SysML representation. We \nconclude this paper by summarizing th e capabilities offered by SysML and give a \nperspective for the potential improvements th at SysML brings for products and systems \ndevelopment. \n2 CONTEXT, REQUIREM ENTS AND USE CASES \nWhen modeling a system, an important primary task is to decide what belongs to the \nsystem and what does not. The Context Diagram is an informal means (informal in the \nsense that it does not carry pr ecise semantics) to represen t the boundaries of the system. \nIn Figure 2 we show a context diagram for the RSW. Three actors for the system are \nidentified in the context: Maintenance (for repair purposes), Car Electrical System  (to \nactivate the system in the car) and Driver (to manually disable th e system for example.) \nThree external systems are considered here : the wiper interface, the windshield and the \ncar electrical system. Note that the car electr ical system also provides electrical power to \nthe RSW. Hence it is considered both an actor and external system. The context diagram \nestablishes the scope of the system. Note that  a user-defined keywor d “external” is used \nto qualify the external components. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n152 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \n \nFigure 2 Context diagram for the Rain Sensing Wiper system. \nIn the introduction of this paper, we explai n that the conceptual stage of the lifecycle \nsucceeds to the analysis of the customer n eeds into product requirements. Requirements \nhave been traditionally represented as text  (accompanied with figures and drawings) and \nstored in files or databases. The requiremen ts describe all the product functions and the \nconstraints under which these functions should be realized.  \nSysML allows the representation of requirements as model elements. Hence \nrequirements become an integral part of th e product architecture. The language offers a \nflexible means to represent text-based requi rements of any nature (e.g. functional or non-\nfunctional) as well as the relationships between them.  \nIn Figure 3 we represent a requirement diag ram for the RSW. Note that it contains \nboth functional and non-functiona l requirements. Requirement s in SysML are abstract \nclassifiers (i.e. they cannot be  instantiated) with no operations or attributes. They cannot \nparticipate in associations or generalizations , however a set of predefined relationships \nhelp to characterize the re lationships between the requirements. We review these \nrelationships below. \nSub-requirements are relate d to their parent requirement using the crosshair \nrelationship (that denotes namespace embeddi ng). For example in Figure 3, some of the \nsub-requirements of the requirement Automatic Wiping  are connected to it using the \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 153 \ncrosshair. The parent requirement is a pack age for the embedded requirements. In that \nsense, deleting the parent requirement will automatically delete all the embedded ones. \nAnother example of requirement acting as a package for other requirements is the \nrequirement Core Functions which contains two sub-requirements. For readability in the \nmodel, a user-defined keyword “package” is rendered next to the Requirement stereotype. \nDuring requirement analysis (e.g. decomposition and flow-down) new requirements \nare created by derivation. Thes e new requirements can be c onnected to the initial ones \nwith the DeriveRqt dependency. For example in Figure 3, a set of core functions for the \nproduct are derived from the set of requirements under Automatic Wiping. The name \nDeriveRqt was chosen in order to avoid an y confusion with the standard Derive \ndependency in UML2.0. Other examples of derived requirements are the technical \nchoices for each function (see the box Technical Choices in Figure 3) Note that in the \nFigure, the designer captures a Rationale comment to explain his choice for using a \nsensor fixed on the windshield. A last exampl e of derived requirement is the quality \nrequirement System Calibration stating that the system shoul d be calibrated. This is the \nrequirement added to the product after the in famous RSW failure was identified (see the \nAppendix A for more details.) The satisfacti on of this requirement insures that the \nproduct will be resilient to changes in the sensor and windshield characteristics.  \nAnother relationship between requirements is Refine. An example of requirement \nrefinement is shown in Figure 3.The require ment on speed actuation is refined by the \npossible selection for speed (slow, me dium or fast.) Lastly, a generic Trace dependency \ncan be used to emphasize that a pair of requi rements are related in some way or another. \nIn Figure 3, the requirement fo r manual deactivation is traced to the one about automatic \ndeactivation. \nRequirements have a number of derived at tributes to store the status of the \nrelationships reviewed in the above paragraphs. We will see later in this paper that these \nattributes become particularly handy when  requirement relationships are represented \noutside requirements diagrams. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n154 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \n \nFigure 3 SysML Requirement Diagram for the Rain Sensing Wiper system. \nOften requirements are elicited during the whole product lifecycle and additional \nrequirement diagrams are used to repres ent them. Hence the product requirements are \ntypically laid out on a set of requirement diagrams. \nSysML provides a generic model for require ments that allows the modeling of both \nfunctional and non-functional requirements. A non-normative set of requirement types \nare proposed in the appendix of the OMG SysML specification [OMGSysML]. Specific \ntypes of requirements (for example related to timing or scheduling, etc) are handled by \nlanguage extensions. SysML supports a prof ile mechanism to extend the language. The \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 155 \nObject Management Group (OMG ) has released a series of  modeling standards that \naddress specific needs: for the modeling of non-functional requir ements related to \nperformance and quality [QoS, STP], and for th e modeling of test cases [Testing profile]. \nThese profiles can be used in SysML without restriction. \nSysML provides a use case diagram that  is inherited from UML2.0 without \nmodifications. In Figure 1 we show the interaction of the external actors with some of the \nmain use cases (represented by ellipses) ow ned by the RSW. We represent the three \nactors and connect them to thei r respective use cases. In this  figure, a central use case \nAutomatic Wiping is composed of a series of sub-us e cases. The hierarchical relationship \nis modeled using the Include dependency. \n \nFigure 1 SysML Use Case Diagram \nSysML has the capability for representing test  cases and attach them to their related \nrequirements or use cases. A test case can  be an operation or a behavioral model \n(Interaction, State Machine or Activity.) \nIn Figure 5 we show a test case for the RS W. The test case verifies the requirement \nSystem Calibration (see Figure 3.) This is done by: Firs t, retrieving the characteristics of \nthe different components (sensor, windshield and software configur ation file.) Second, \nusing these characteristics to compute an operating range (both for the sensor and \nwindshield) in order to asse ss their compatibility. If th e sensor and windshield are \ncompatible, then the test case is successful. Otherwise, an alert is triggered. The actions \nin the activity diagram contributing to each st ep are enclosed in illustrative boxes (Figure \n4a) for the sake of clarity. \nThe first step is realized in this example using a set of webservices to access the \nrepositories containing the artif acts related to the different  components (see the leftmost \nenclosing box in Figure 4a.) More precisely, the bill of mate rial (e.g. in a product data \nmanagement system) is queried for the charac teristics of the sens or and the windshield \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n156 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nand the configuration file is retrieved, fo r example, from a software configuration \nmanagement system. \nThe second step (see central box in Figure 4a ) is realized by defining constraints on \nthe attributes of the sensor and the windshi eld in SysML Parametric Diagrams. We will \nexplore how these diagrams are constructed later in this paper. \nIn Figure 4b a test context is created to host prototypes for the webservices and other \nfunctions necessary to execute the test case. This context is traced to the requirement. The \nactivity diagram uses the functions of the test context for its execution. \n \n(a) The test case is realized with an activity diagram. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 157 \n \n(b) Requirement and test case traceability  \nFigure 2 SysML Test Case for the quality requirement System Calibration. \nThis concludes our review of the capabilit ies of SysML for modeling uses cases and \nrequirement. In the next section, we show  how SysML is used to create a product \nstructure that satisfies these requirements. \n3 STRUCTURE OF THE RAIN  SENSING WIPER SYSTEM \nIn this section, we build now a structure fo r the RSW. We assume that a set of sub-\nsystems and components have been identif ied through the requirements engineering \nprocess based on stakeholder concerns such as cost, performances, etc. \nSysML provides a basic structural element called Block whose aim is to provide a \ndiscipline-agnostic building block for systems. Blocks can be used to represent any type \nof components of the system, e.g. functional, physical, and human, etc. Blocks assemble \nto form architectures that represent how different elements in the system co-exist. \nThe SysML Block Definition Diagram (BDD) is the simplest way to describe the \nstructure of the system. It is the equivalent to the Class Diagram in UML. It is used to \nrepresent the system decomposition using for example associations and composition \nrelationships. The BDD is ideal to display the features of a block, such as its properties, \nand operations. SysML allows blocks to own special types of properties: Block Properties \nand Distributed Property. Block properties impose additional constraints on classic UML \nProperties, and can for instance own a SysML Value Type. Value Type s are designed to \nhold units (e.g. physical units) and dimensions. Distributed Properties let the user apply a \nprobability distribution to the values of the property. SysML proposes model libraries for \npossible values of units, dimensions and probability distributions. \nIn Figure 5 we show a BDD for the RSW. For the sake of readability of the diagram, \nwe do not render the associations between the sub-systems and the Rain Sensing Wiper \nelement, although these associations exist in the model. Instead we use an illustrative box \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n158 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \naround each set of components (composite and external) and a black diamond shape over \nthe composite component as a visual clue for composition. The main components of the \nRSW are: an interface to actuate the wiper, an electronic control uni t, a sensor and the \nwindshield element. Both the interface and the windshield can exist in the car with or \nwithout the RSW (In SysML they are so-called reference properties.) \nThe properties and the operations for each block are visible in Figure 5. Properties \n(more precisely SysML BlockProperties, shown using the stereotype <<blockProperty>>) \nare used to model the physical characteristic s of the components. The operations (called \nsometimes services) represent the functional aspects of the system. \n \nFigure 3 Block Definition Diagram for the Rain Sensing Wiper. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 159 \nWe now examine how the product structure a nd the product requirements can be related: \nOne of the important consequence of having re quirements as model elements is that it \nallows the designer to specify which compone nts in the system satisfy a given set of \nrequirements. This is called allocation process . We show an example of requirement \nallocation in Figure 4. In the figure, the pa rt on the left hand side represents some \nelements of the RSW, and the part on the righ t hand side is a hierar chy of requirements. \nOne way to perform allocation is to use the Satisfy dependency. In the figure the rain \nsensing wiper model element is allocated to the requirement named “Automatic Wiping”. \nAny element in SysML can be used to satisfy a requirement. \nAnother way to display allocation is to use a dedicated compartment named \n“Requirement related”. This compartment di splays the status of a set of derived \nproperties related to requirements. In Figure 4 the element ECU displays this \ncompartment: The ECU element is allocated to the requirement named “Use dedicated \nECU”. \n \n \nFigure 4 Example of requirement allocation. \nThe SysML Internal Block Diagram  (IBD) allows the designer to refine the structural \naspect of the model. The IBD is the equivalent of the composite structure in UML. In the \nIBD properties (or parts) are assembled to de fine how they collaborate to realize the \nbehavior of the block. A part represents the usage of another other block. \nThe most important aspect of the IBD is that it allows the designer to refine the \ndefinition of the interaction between the usages of blocks by defining Ports, as explained \nbelow. \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n160 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nPorts are parts available for connection fr om the outside of the owing block. Ports \nare typed by interfaces or blocks that defi ne what can be exchanged through them. Ports \nare connected using connectors that represent the use of an association in the IBD. \nTwo types of ports are available in SysML: Standard ports handle the requests and \ninvocations of services (i.e. f unction calls) with other block, and Flow ports  let blocks \nexchange flows of information or material. For standard ports, an interface class is used \nto list the services offered by the block. For flow ports, a Flow Specification is created to \nlist the type of data that can flow through th e port. When only a single type of object can \nflow through a port, then the type is used as  type for the port directly. Such a port is \nnamed Atomic Port . The class Item Flow  is used to represent what does actually flow \nbetween blocks in a particular  usage context. We refer the interested reader to the \nstandard specification [OMGSysML] for more details on item flows. An example of IBD \nis given in Figure 5. \n \n \nFigure 5 Internal structure of the Rain Sensing Wiper system. \nIn Figure 5 we refine our initial descri ption of the RSW by showing how parts are \ninteracting inside the block named Rain Sens ing Wiper. Previously to constructing the \nIBD, we need to define a model for the a ssociations characteriz ing the relationships \nbetween the different blocks. Also additional blocks are defined for example to type the \nports. We show this model in another BDD that can be found in Figure 15 (Appendix B.)  \nThe central part of Figure 5 consists of th e parts of the system that represent the \nembedded hardware. The parts underneath are us ed for mounting the system in the car. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 161 \nThe ones above represent the software. A set of standard ports and interfaces are defined \nto represent the functional aspect of the co mmunication between the parts. For example, \nthe processing unit accesses the actuation in terface of the wiper through the interface \nWiperECUCommunication. Details about the interfaces used in this IBD are found in \nFigure 17. \nThe processing unit communicates with the sensor using a flow port. The data \nexchanged is two bitstreams, one containi ng the measurements from the sensor and \nanother containing synchroniza tion data. The port is typed with a specification of these \nflows using the element SensorECUCommunication (see Figure 17.) Note the direction of \nthe flows in the definition. \nFor convenience a flow port can be conjugate d in the sense that its input and outputs \nare inversed (flows declared as “ in” becomes “ out” and vice-versa) with respect to the \ndefinition of the interface. This is useful when connecting two syst ems whose flow ports \nare conjugated with respect to  each other. This is the case for instance between the \nprocessing unit and the sensor in Figure 5. A conjugated flow port is represented in black. \nSince the synchronization data flow is declared as “inout”, the conjugation of the port has \nno effect on it. \nNote that in Figure 5 connectors between por ts link parts defined within the block. \nSysML actually allows direct connection betw een ports defined at different levels of \ngranularity, for example between a port and another one defined inside a part. This type \nof connector are called nested connectors. We refer readers to the standard specification \n[OMGSysML] for more details about these connectors. \nFlow ports are also useful to define physic al contact between parts: For example the \nSensorAttachement unit is fixed to the windshield using an adhesive. The block \nrepresenting the adhesive material (AttachementAdhesive in Figure 15) is used to type the \nflow port connecting these parts. \nWe explain now how to represent requireme nts allocation in an IBD: Requirements \nare classifiers and therefore cannot be represen ted on an IBD. For this  type of diagrams, \nthe compartment notation as introduced in Figure 7 is used.  \nAn example is shown in Figure 5: The parts representing the windshield and the \nsensor attachment are used to satisfy the requirements named “ Use Sensor on \nWindshield” and “System Calibration” , respectively (see Figure 2.) The satisfaction of \nthese requirements is displayed in each part. \nA large and complex model is composed of  hundreds, maybe of thousands elements. \nHence such a model is laid out over a set of  BDD’s. Typically, the content is organized \naccording to stakeholders concerns. \nMost design methodologies advocate the use of viewpoints to organize the model, \nfor example according to stakeholder’s in terests. SysML provides a model element \nViewpoint that allows users to capture the charact eristics of a viewpoi nt (for example, \ntargeted stakeholders, concerns  addressed, construction rule s, etc.) A container element \ncalled View is then used to organize the model according to the viewpoint description. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n162 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nFigure 6(a) represents a model for the de finition of a viewpoi nt. In our example \nmodel, the elements of the system are contained in a central package called Systems. \nSome elements are imported from this package into a view called RSW Power  whose \npurpose is to gather elements playing a role in the power consumption of the system. The \nview conforms to the definition given by the viewpoint description. Within the view, an \nelement Power System RSW is defined to describe how the various imported elements are \ncollaborating in the scope of the power consumption of the system. \n \n(a) Definition of the view RSW Power. The block Power System RSW is defined in the context of the \nview and uses a set of elements imported from the package Systems for its definition. \n \n(b) An internal block diagram for the block Power System RSW. The diagram describes the roles of the \nimported elements in the context of the power subsystem of the car. \nFigure 6 Separation of concerns using viewpoint modeling. \nIn Figure 6(b) the car electrical system powe rs the parts using atomic flow ports typed \nusing the Power Supply Channel Block (Figure 15). In this case, the direction of the port \n(in or out) is specified in one of the port’s attributes. \nWe have seen so far how attributes are defi ned for blocks in order to represent their \nphysical characteristics. Often attributes of a set of systems are not independent. Consider \ntwo sub-systems A and B having attributes a and b, respectively, and that the constraint \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 163 \n{A.a greater than B.b} must hold true. SysML ConstraintBlocks allows the engineer to \ndefine any relationships (e.g. an alytical) between the system attributes. These constraints \nform networks of expressions that are typical ly leveraged in simulations, for example for \nrequirements verification. Note that constraint blocks are not instantiated as runtime \nobjects, but rather used to type special properties of blocks, as explained below.  \nConstraints are properties in sub-systems (i.e. blocks) named ConstraintProperty and \nare typed by ConstaintBlocks. A constraint block defines an  expression and the attributes \nthat represent its parameters. SysML does not  prescribe any language  to represent the \nexpressions or provide a solver for it. This setting is typically offered within the usage of \na particular tool. \nThe RSW uses a set of analytical constraint s to verify that the system is properly \ncalibrated (requirement “ System Calibration”  in Figure 2.) Three constraints are shown \nin Figure 7: The constraint SensorEffectiveRange computes an operational range for the \nsensor, based on some of its parame ters. Similarly, the constraint \nWinshieldIREffectiveRange computes an operating range for infrared sensor that can be \ncompared with the one computed for the sensor. Finally the constraint \nSensorWindshieldRangeCompare is used to compare the above values. \n \n \nFigure 7 Definition of Constraint Blocks for the Rain Sensing Wiper system. \nThe SysML Parametric Diagram (PD) is used to represent the usage of constraint blocks \nas constraint properties . Syntactically the PD is actually  is similar to IBD. In a PD, \nconstraint properties are connected to each other through the parameters defined by their \nconstraint block. In turn they connect to ot her properties in the c ontext of their owning \nblock. These other properties must be dir ectly bound to parameters  of the constraint \nproperties because they can only play a “feedi ng role” to the constraints parameters in a \nPD. \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n164 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nAn example of PD is shown in Figure 8. Constraint properties are represented by \nboxes with rounded corners. In this diagra m, both the sensor and windshield parts \ncompute an operational range that is  compared by the property named “ compare”. These \nvalues are also fed to the part representing th e configuration file (bottom of the figure.) If \nthe sensor and the windshield are compatible, the flag IsCalibrated (exposed as a port) is \nset to true. The verification of  the calibration requirement is hence reduced to testing the \nvalue of this port. The system is therefore resilient to chan ges in windshie ld and sensor \ncharacteristics.  \nThe usage of the constraint blocks WinshieldIREffectiveRange and \nSensorEffectiveRange can be seen in the diagra ms of Figure 16 and Figure 17, \nrespectively (Appendix B.) They are nested in the parts named RainSensor and \nCarWinshield (see comments in the figure.) Note that the parametric diagrams of Figure \n8, Figure 16 and Figure 17 are used to implemen t the second step of test case that we \npresented in Figure 2. \nAn attractive aspect of constraint blocks is that they provide a reusable mechanism to \ndefine types of constraints. Hence the same constraint can be used several times in the \nmodel. It is important to note that a constraint does not specify which variable is an input \nor an output. Values are assigned by the c ontext and a numerical solver will provide \nresults for the variables of the system. Note to conclude our review of SysML constraints \nthat remarkable work on this topic is available from Peak et al. [GTech]. \n \nFigure 8 Parametric Diagram for the Rain Sensing Wiper system. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 165 \nRequirement allocation is shown in PD ’s using compartments: In Figure 8, the \nrequirement allocation compartment is displayed in both the constraint used for \ncomparison and the part representing the conf iguration file. These elements satisfy the \nrequirement named System Calibration. \n4 BEHAVIOR \nIn this section, we explore how SysML is used  to model the behavior of the product. The \nexpression of the behavior of a system equates to realizing its Use Cases under a \nspecified set of non-functional constraints. SysML offers three types of behavioral \nconstructs: Interactions, State Machine  and Activities. Several behavioral models from \nUML are not reused for the sake of simplicity or because of some maturity concerns. We \nexamine these three models below through our RSW example. \nThe first behavior model that we review is the SysML Interaction Diagram . This \ndiagram allows the designer to model a sequ ence of service calls between components. \nSysML leverages the UML2.0 interaction model but restrict its use in the interaction \ndiagram only. Other forms of interaction di agrams (e.g. communication diagram) are not \nused. \nIn Figure 9 we represent the initialization sequence of the RSW using an interaction \ndiagram. The initialization sequence consists  of a synchronization protocol between the \ncomponents. This diagram is well adapted to represent this type of behavior. Initially, the \ncar electrical system starts the RSW, which in turn queries the sensor and the wiper \ninterface for an acknowledgement. After that, the software is loaded in the memory of the \nECU and its execution is started. Once the software is started, it reads the parameters \nstored in the calibration file. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n166 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \n \nFigure 9 Interaction Diagram for the initialization of the Rain Sensing Wiper system. \nThe use case named Initialization (Figure 1) is realized by the interaction model in Figure \n11. One mechanism for expressing the relationship between the interaction model and the \nrealized use case is to use the SysML Allocation mechanism, as introduced below. \nIn our previous examples, we have seen how requirements are allocated to system \nelements aiming at satisfying or verifying them. SysML generalizes  this concept by \nallowing any elements to be related to any el ements to express a particular relationship. \nWe will examine this mechanism in more deta ils in the coming examples and in Section \n[Allocation]. Similarly to requirement relati onships, elements in SysML have derived \nproperties to display the status of their alloca tions to other elements. For example, at the \nbottom of the interaction diagram, we can read that the behavior model is allocated to the \nuse case Initialization. In addition, the model is alloca ted to the system state named \nInitializing (see below.) \nThe second behavior model that we introduced is the SysML State Machine \nDiagram. This diagram is used to represent the different states of the RSW. This \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 167 \nbehavioral model is also reused from UML and not extended in SysML. Protocol State \nMachines from UML2.0 are excluded from SysML for simplicity. \nIn Figure 10 the different states of th e RSW are represented as well as their \ntransitions. Three states are identified: Deactivated, Initializing and Activated. In \ndeactivated mode (for instance manually by the user), the system waits for an activation \ncommand. When this signal is received, it transits to the initializing state. In that state, the \ninteraction sequence in Figure 9 is execute d. When completed successfully, the system \ntransits to the “activated” state. Note that, when entering and exiti ng states, flags are set \nand unset, respectively. These flags are used for example to display the current status of \nthe system on the driver dashboard.  \n \n \nFigure 10 State Machine Diagram for the Rain Sensing Wiper system. \nAllocation can also be shown in the state machine diagram as well. In Figure 12 the states \nInitializing and Activated both exhibit requirement and allocation compartments.  \nThe third type of the behavior that we review is the SysML Activity Diagram. SysML \nleverages and extends the activity model from  UML to support continuous systems. The \nSysML Activity Diagram  offers many innovations presen ted briefly below. A more \nthorough description of the SysML activity model is available in [Bock]. \nThe modeling of activities in SysML consists of describing behavior as a flow graph. \nAn activity is defined as a set of actions re presented as graph nodes (these actions are the \nusage of other activities) linked by edges ca rrying control flow a nd data flow between \nactions. Object nodes represent the type of data  that can traverse th e flow graph and are \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n168 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nused as containers for the data as it trav erses the graph. For example, object nodes are \nused to store input para meters of actions (called pins.) Finally, control nodes are used to \nroute control and data flows through the act ivity (for example create forks, duplicate \nflows, etc.) An example of activity model is shown in Figure 12. \nSince UML2.0, activities are classifiers and can be represented in Class Diagram. \nSysML clarifies the semantic of association between activities. As a result, Activities can \nbe related to each other to represent for example functional decomposition in a similar \nway that blocks represent structural decomposition in a BDD. In Figure 11 we represent a \ndecomposition of the main functions of the system. \nIn this setting, the upper limit at the part  end represents the maximum number of \ninstances that can execute c oncurrently. In Figure 11 the lower and upper limits for each \nactivity owned by Rain Sensing Wiper Main  (i.e. Actuate, Process and Sense) are \nenclosed in an illustrative box. The exampl e setting allows only one instance of each \nactivity to be run concurrently in the system. \nActivities can also be associated to classi fiers when the latter are used as type of \nobject node. In the case, the upp er limit at the classifier end represents the maximum \nnumber of instances that can reside in an object node at any given time. In Figure 13 we \ncan see that the upper li mit for the number of instances that can be owne d by Process is \nten.  \nIn Figure 13, we can see that the activiti es Sense and Process share a common type \nof object node named SensorMeasurement. Also, all activities use the type \nInterfaceCommand. Note that both these blocks are sp ecializations of a data type named \nBitstream. The bitstream modeled by the block In terfaceCommand is used to implement \nthe services communications between the ECU and the wiper interface (defined by the \nvarious service ports between the parts.) \n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 169 \n \nFigure 11 Activities and object node types for the sensing activity of the RSW. \nThe requirements that the Actuate and Sense functions satisfy are also represented in \nFigure 11. In addition the main function of th e product is allocated to the rain sensing \nwiper block using an Allocate relationship. In this case, th e designer expresses that the \nfunction is owned by this block. The activity Actuate displays its allocation compartment \nwhich shows that this activity is allocated to the block WiperInterface. \nThe rain sensing function is implemented in the activity diagram in Figure 14. The \nthree functions defined in Figure 13 (Actuate, Process and Sense) are used as actions in \nthe activity. \nIn Figure 14 the data flows across edges th at connect the actions  through their pins. \nThe type of data that can flow between actions  is defined by the type of their pins. For \nexample, objects of type InterfaceCommand are flowing from the action Process to the \naction Actuate.  \nSysML introduces notions to specify the ra te at which data can flow across edges \nand parameters (pins) of activities. Two types of the rate are defined: Discrete and \nContinuous. In the example of Figure 14, the bitstream exchanged between the function \nProcess and Actuate is limited in rate by the serial link that is used to connect the parts \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n170 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nowning these functions (these parts are shown in Figure 5.) In Figure 14, this is modeled \nby the edge (of type Discrete) named”serial data channel”. Edges of type Continuous are \nused when the time interval between objects te nds towards zero. Note that in order to use \nrate-controlled edges and pins, activity parameters must be “streaming”1. An activity with \nstreaming parameters can accept values at any time during its operation. \n \n \nFigure 12 Sensing activity for the Rain Sensing Wiper system. \nThe UML2.0 action model only enables actions to start. SysML introduces the notion of \ncontrol operators as a special type of actions able to enable or disable other actions. A \ncontrol operator named ManualControl is used in Figure 14 to start and stop the rain \nsensing function. It deactivates  the function upon reception of  a “deactivate” signal (for \nexample triggered by the pressure of a bu tton on the dashboard.) It can restart the \nfunction later when receiving the proper sign al. The type of data exchanged between the \nactions Process and ManualContro l is of type ControlValue. SysML defines some types \nof control values ( enable action, disable action) that can be extended by users according \ntheir needs (for example, a suspend action value can be added.) \nSysML also introduces two new types of obj ect nodes to support continuous concept \nsuch as transient states (e.g. for the mode ling of electrical signals.) In Figure 14, the \naction Process exposes a pin of type Overwrite to collect the data sent from the sensor. \nAn object node of type overwrite will ensure that the latest measurements from the sensor \nare available to the Process action by erasing older ones in the object  node. Note that up \n                                                           \n1 UML2.0 notion. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 171 \nto ten values can be stored in the pin according to the bound (0..10) defined in Figure 13. \nThe second new type of object node is NoBuffer: In this case, the pin does not store any \nvalue; hence a value is discarded if it is not directly accepted by outgoing edges (in the \ncase of an output pin) or an action (when used as input.) \nLastly, SysML supports assigning probabilitie s to activity edges (whose source is a \ndecision node or object node) and parameter sets. It allows the modeler to assign a \nprobability for an object value in order for it  to traverse an edge. In the case of a \nparameter set, it assigns a probability for the set to be assigned a value at runtime. This \nfeature can be used for instance to simulate loss in a communication channel. \nAllocation to requirements or other elements  is shown in the activity diagram using \nthe compartment notation. In Figure 14, the ac tion called “manual control” satisfies the \nrequirement named “manual disablement”. Als o, this action is allocated to the block \nrepresenting the dashboard button to emphasi ze that this button causes the system to \ndeactivate. \n5 ALLOCATION \nThe review of the SysML Allocation  mechanism will conclude this presentation of the \nSystems Modeling Language. We have introduced  some examples of allocations in the \nprevious examples of Figure 11 to 14. \nThe concept of allocation allows the us er to bridge between various modeling \ntechniques. By allowing allocation between any pair of elements, the designer can \nenforce consistency between the various parts of the model. \nThrough the examples of Figures 11 to 14, we have seen that allocations can be \ndisplayed using special compartments or us ing the Allocate depe ndency. The usage of \nthis dependency is only possible when the related elements can be represented on the \nsame diagram. \nAllocation is often used to represent mapping of function to structure, as used in the \nexample of Figure 13. Mapping between elements can be complex and require the display \nof several relationships. To allow a scalable  display of dependencies between elements, \nSysML provides a tabular notation for relationships, as explained below. \nIn Figure 15 we show the allocation rela tionships between the edge named “serial \ndata channel” in Figure 14 (linking the actions  Process and Sense) and other elements in \nthe model. Note that the type of an activity edge is shown as ObjectFlow in the table. The \nfigure shows that the edge is allocated to four elements in the model. \n \nFigure 13 Display of allocation relationships using the tabular notation. \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n172 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nRequirement dependencies can also be displa yed using the tabular notation. To conclude \nthis review of the SysML Language, we show  in Figure 16 the resu lt of an allocation \nquery for the requirement System Calibration. Note that the direc tion of the relationship \ndepends on whether the requirement is the client or the supplier. \n \nFigure 14 The tabular notation is used to display the requirements relationships. \n6 CONCLUSION \nIn this paper we have toured the different capabilities that SysML offers to system \nengineers and product designers. SysML is ai med at supporting the conceptual stage of \nthe lifecycle of the product. This stage is pr eceded by the decomposition of the customer \nneeds into product features. We have seen th at SysML allows the re presentation of these \nfeatures as requirements in the model. In turn  these requirements can be allocated to the \nuse cases, to the sub-systems and components (whether functional or physical) identified \nfor the product. \nThe conceptual stage requires the specifica tion of the various sub-systems and the \nneed for details depends on their level of in tegration. SysML provides a set of constructs \nto support the description of the structure of the product. Bl ocks are used to model sub-\nsystems and components, and ports support the description of their interfaces. \nDependencies (e.g. analytical ) between structural proper ties are expressed using \nconstraints and represented using the parametric diagram.  \nIn addition to structure, the conceptual stage should clarify how the product behavior \nis expressed through the interaction of its components. For example, behavior modeling \ngives a detailed description of the product use cases. SysML provides three means for \nexplicating the product behavior, namely intera ctions, state machine and activities. These \nthree mechanisms are built as a unified behavior concept  and can consequently be \norchestrated in a single, uniform and complex behavior model for the whole product. \nA complex product model is form by several “sub”-models of different nature (for \nexample requirements, blocks, constraints, activities, etc.) SysML provides a mechanism \nto relate different aspects of the model and to enforce traceability across it. \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 173 \nThe conceptual stage precedes the detailed elaboration of the components within the \ndifferent engineering disciplines. The con ceptual design plays therefore many central \nroles in the product lifecycle and we emphasi ze below some of the most important ones \nin our opinion. \nThe formal description of the product at an early stage of the lifecycle improves the \nunderstanding of the product requirements and how  they answer the customer needs. The \nallocation of requirements to the model elements ensures that these needs are covered and \nprovides a rationale for the engineer in ch arge of fulfilling th ese requirements. The \nrationalization of the design is  therefore a communication t ool spanning organizational \nlevels and lifecycle stages. It improves communication across t eams, between teams \n(think of the different engineering disciplines) and between teams and decision makers. It \nuses a generic language (in the sense that it is  not specific to any engineering discipline) \nthat accommodates the incremental detailing of the product representation. That last \naspect allows coping with organizational levels . Note that such a formal description is \nwell suited to methodologies. \nThe SysML model provides an electronic representation of the product that is \nleveraged as a decision tool. Trade-off studi es are performed by evaluating functions on \nthe model (cost function, estimation of the integration effort.) At an early stage in the \nlifecycle, often rough estimations are used, he nce the model need not necessarily have a \ngreat amount of details in order to be used efficiently. When details are added, or artifacts \n(for example sub-system simulations) are pr oduced by detailed engineering, the model is \nused to orchestrate the various simulations  and perform requireme nt verification. Hence \nthe SysML model is an evolving decision tool available throughout the whole lifecycle of \nthe product, and not only at the conceptual stage. \nThe product model represents abstractions  of artifacts that are progressively \nelaborated throughout the lifecycle. These arti facts are distributed across the engineering \ndisciplines participating to the design. Hen ce the model forms a traceability scaffold that \nprovides a means to measure the development progress, perform change impact analysis, \nand manage dependencies between processe s and the produced artifacts. The SysML \nmodel is hence a management and integration tool for the stakeholders. \nThe role of the system model clearly extends beyond the capabilities that we \ndescribe above. We aim at discussing some  of the attractive ones in our opinion. \nModeling for conceptual design is a young discip line and best practices will grow out of \nit. \n7 THE RAIN SENSING WIPER STORY \nThe development of the first Rain Sensing Wi per illustrates how a classic failure to fully \nconceptualize a product's physical architecture resulted in the disc overy of integration \nissues at servicing time, t hus quickly leading to engine ering change requests. The \nscenario revolves around the initial introduction of the Rain Sensing Wiper (RSW) \nfeature in an automobile manufacturer's vehicle program. \n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n174 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \nBefore examining the reason of the failure of the RSW, let us briefly review the \ncharacteristics of the system. The RSW contains mechanical (optical mounting device), \nelectronics (IR sensors and EC U), and software (computer vision algorithm) components \nthat are procured by tier-one suppliers. Thes e components are simply integrated by the \nmanufacturer. The main parameters of the system are: (1) the optical and geometric \nspecifications of the windshield, in particular  its thickness and glass optical indexes, and \n(2) the ranges of operation of the electronic optical sensors. The detection software also \nhas normal ranges of operation relative to thes e parameters, but in addition relies on data \nabout the actual values of the parameters of the windshield. \nThe fact that the RSW electronics and soft ware specifications include ranges for the \nrelevant windshield properties is important, because it allows more flexibility on the \nchoice of the windshield itself. This is a critical design choice, the procurement and \nintegration costs associated with the windshiel d being an order of magnitude greater than \nthat of the RSW. For optimal performance, the actual values of the windshield properties \nshould fall near the center of the normal operating ranges both for the RSW sensors and \nthe software; however, acceptable operation should be guaranteed for the whole range. \nFrom a procurement standpoint, the windshi eld is simultaneously purchased from \ndifferent suppliers. Depending on the year of production and where the product is \nmanufactured, suppliers may modi fy the design of their windshields. Also, one or more \nchanges of suppliers can occur during the production phase. \nIn the failure scenario, which occurred  during the first year of the RSW's \nintroduction, a local windshield supplier pr ovided a component whose characteristics \nwere incompatible with the operating range of the sensor. Unfortunately, no requirement \nfor calibrating the system properly (i.e., for verifying that sensor  and windshield are \ncompatible) had been captured for the RSW at that point. Thus cars were sent to \ncustomers with a non-functioning wiper system. \nInitial diagnostics designated the software as the culprit for the malfunction, since it \nwas difficult for mechanics to test its beha vior. The other components (ECU, sensor, and \nwindshield) were functioning normally when te sted independently. The failure mode for \nthe RSW resided at the level of its sub- systems, which made it difficult for the \nmanufacturer to discover it. After discove ring the root cause, a new requirement was \ncaptured to ensure that new systems will be properly calibrated at the production stage. \nIn our SysML model, this requirement is named System Calibration and shown in \nFigure 1 and Figure 2. \n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 175 \n8 ADDITIONAL DIAGRAMS \n \nFigure 15 Associations between Blocks and Additional Elements \n \n \n \n \n \n \n \n \n \n \n \n \n \nFigure 16 arametric Diagram for the Sensor. \n\n \nAN OVERVIEW OF THE SYSTEMS MODELING LANGUAGE FOR PRODUCTS AND SYSTEMS \nDEVELOPMENT \n \n \n \n \n176 J\nOURNAL OF OBJECT TECHNOLOGY V OL. 6, NO. 6 \n \nFigure 17 Parametric Diagram for the Windshield. \nREFERENCES \n[OMGSysML] SysML 1.0 Specification (ptc/06-05-04), OMG final adopted specification, \navailable at http://www.omgsysml.org/ \n[QoS] UML Profile for Modeling Quality of Serv ice and Fault Tolerance Characteristics \nand Mechanisms (ptc/04-06-01), OMG final adopted specification, available \nat http://www.omg.org/docs/ptc/04-06-01.pdf \n[STP] UML Profile for Schedulability Performance and Time (ptc/05-01-02), OMG final \nadopted specification, available at \nwww.omg.org/technology/documents/formal/schedulability.htm\n \n[Testing profile] UML Testing Profile  (ptc/05-07-07), OMG fina l adopted specification, \navailable at www.omg.org/technology/documents/formal/schedula-bility.htm \n[GTech] Peak RS, Friedenthal S, Moore A, Burkhart R, Waterbury SC, Bajaj M, Kim I \n(2005) Experiences Using SysML Para metrics to Represent Constrained \nObject-based Analysis Template s. 7th NASA-ESA Workshop on Product \nData Exchange (PDE): The Workshop for Open Product & System Lifecycle \nManagement (PLM/SLiM), Atlanta. See also \nhttp://www.pslm.gatech.edu/topics/sysml/\n \n[Bock] Conrad Bock, SysML and UML 2 Support  for Activity Modeling, Wiley \nInterScience (www.interscience.wiley.com) DOI 10.1002/sys.20046 \n\n \n \n \n \n \nV\nOL. 6, NO. 6 J OURNAL OF OBJECT TECHNOLOGY 177 \nAbout the author \nLaurent Balmelli, Ph.D. Dr. Laurent Balmelli is currently a manager at \nIBM in charge of archite cting the new generation of offerings and tools \nfor Systems Engineering and Prod uct Development He has been a \nResearch Staff Member at T.J. Watson Research Center and IBM Tokyo \nResearch Labs, and a member of se veral leadership councils in IBM \nsince 2000. Since 2003, Dr. Balmelli has represented IBM within the \nSysML standard team and is one of the lead authors of the SysML language specification. \nHe was recently awarded the position of invite d professor at Keio University in Tokyo, \nJapan, where he currently resides. He can be reached at balmelli@us.ibm.com.  \n"
}