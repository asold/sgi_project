{
  "title": "Predicate Transformer Semantics for Hybrid Systems",
  "url": "https://openalex.org/W3210385152",
  "year": 2021,
  "authors": [
    {
      "id": null,
      "name": "Jonathan Julián Huerta y Munive",
      "affiliations": [
        "University of Sheffield"
      ]
    },
    {
      "id": "https://openalex.org/A135621682",
      "name": "Georg Struth",
      "affiliations": [
        "University of Sheffield"
      ]
    },
    {
      "id": null,
      "name": "Jonathan Julián Huerta y Munive",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A135621682",
      "name": "Georg Struth",
      "affiliations": [
        "University of Sheffield"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2097910887",
    "https://openalex.org/W2234482668",
    "https://openalex.org/W4253748132",
    "https://openalex.org/W2561211292",
    "https://openalex.org/W1498091397",
    "https://openalex.org/W2001616837",
    "https://openalex.org/W2803699674",
    "https://openalex.org/W3014009067",
    "https://openalex.org/W3169853196",
    "https://openalex.org/W2747477340",
    "https://openalex.org/W1590463358",
    "https://openalex.org/W1582269801",
    "https://openalex.org/W2529657190",
    "https://openalex.org/W6602036895",
    "https://openalex.org/W1995504856",
    "https://openalex.org/W4239007999",
    "https://openalex.org/W2174838357",
    "https://openalex.org/W71012416",
    "https://openalex.org/W3085046366",
    "https://openalex.org/W2895754784",
    "https://openalex.org/W56092462",
    "https://openalex.org/W2793741686",
    "https://openalex.org/W2529440634",
    "https://openalex.org/W2315064349",
    "https://openalex.org/W1998368317",
    "https://openalex.org/W1558296274",
    "https://openalex.org/W1979646426",
    "https://openalex.org/W2107872611",
    "https://openalex.org/W69146909",
    "https://openalex.org/W1502663392",
    "https://openalex.org/W1608714802",
    "https://openalex.org/W2101389394",
    "https://openalex.org/W3168224710",
    "https://openalex.org/W2296642625",
    "https://openalex.org/W2885880873",
    "https://openalex.org/W4289761034",
    "https://openalex.org/W113582640",
    "https://openalex.org/W575850752",
    "https://openalex.org/W4242300732",
    "https://openalex.org/W2075133940",
    "https://openalex.org/W3123260378",
    "https://openalex.org/W2974059972",
    "https://openalex.org/W1007073359",
    "https://openalex.org/W4230791618",
    "https://openalex.org/W1521738998",
    "https://openalex.org/W2407773024",
    "https://openalex.org/W1527487696",
    "https://openalex.org/W1864574667",
    "https://openalex.org/W3102859554",
    "https://openalex.org/W2408469252",
    "https://openalex.org/W1497366684",
    "https://openalex.org/W3183673898",
    "https://openalex.org/W3150521218",
    "https://openalex.org/W1509923322",
    "https://openalex.org/W2965195073",
    "https://openalex.org/W2913377762",
    "https://openalex.org/W3141151088",
    "https://openalex.org/W2120713972",
    "https://openalex.org/W1975906542",
    "https://openalex.org/W2336123333",
    "https://openalex.org/W2572942399",
    "https://openalex.org/W3101115050",
    "https://openalex.org/W2775956080",
    "https://openalex.org/W4230994598",
    "https://openalex.org/W2285040361",
    "https://openalex.org/W3111685920",
    "https://openalex.org/W3105046808",
    "https://openalex.org/W2399573863",
    "https://openalex.org/W2492964445",
    "https://openalex.org/W1977106683",
    "https://openalex.org/W2578782373"
  ],
  "abstract": "Abstract We present a semantic framework for the deductive verification of hybrid systems with Isabelle/HOL. It supports reasoning about the temporal evolutions of hybrid programs in the style of differential dynamic logic modelled by flows or invariant sets for vector fields. We introduce the semantic foundations of this framework and summarise their Isabelle formalisation as well as the resulting verification components. A series of simple examples shows our approach at work.",
  "full_text": "Journal of Automated Reasoning (2022) 66:93–139\nhttps://doi.org/10.1007/s10817-021-09607-x\nPredicate Transformer Semantics for Hybrid Systems\nVeriﬁcation Components for Isabelle/HOL\nJonathan Julián Huerta y Munive 1 · Georg Struth 1\nReceived: 14 September 2019 / Accepted: 15 September 2021 / Published online: 31 October 2021\n© The Author(s) 2021\nAbstract\nWe present a semantic framework for the deductive veriﬁcation of hybrid systems with\nIsabelle/HOL. It supports reasoning about the temporal evolutions of hybrid programs in the\nstyle of differential dynamic logic modelled by ﬂows or invariant sets for vector ﬁelds. We\nintroduce the semantic foundations of this framework and summarise their Isabelle formal-\nisation as well as the resulting veriﬁcation components. A series of simple examples shows\nour approach at work.\nKeywords Hybrid systems · Predicate transformers · Modal Kleene algebra · Hybrid\nprogram veriﬁcation · Interactive theorem proving\n1 Introduction\nHybrid systems combine continuous dynamics with discrete control. Their veriﬁcation is\nreceiving increasing attention as the number of computing systems controlling real-world\nphysical systems is growing. Mathematically, hybrid system veriﬁcation requires integrating\ncontinuous system dynamics, often modelled by systems of differential equations, and dis-\ncrete control components into hybrid automata, hybrid programs or similar domain-speciﬁc\nmodelling formalisms, and into analysis techniques for these. Such techniques include state\nspace exploration, reachability or safety analyses by model checking and deductive veriﬁca-\ntion with domain-speciﬁc logics [ 10].\nOne of the most prominent deductive approaches is differential dynamic logic d\nL [47], an\nextension of dynamic logic [ 21] to hybrid programs for reasoning with autonomous systems\nof differential equations, their solutions and invariant sets. It is supported by the KeYmaera X\ntool [14] and has proved its worth in numerous case studies [ 33,40,47]. KeYmaera X veriﬁes\npartial correctness speciﬁcations for hybrid programs using a combination of domain-speciﬁc\nsequent and Hilbert calculi, which itself is based on an intricate uniform substitution calculus.\nB Jonathan Julián Huerta y Munive\njonathan.munive@di.ku.dk\nGeorg Struth\ng.struth@shefﬁeld.ac.uk\n1 Department of Computer Science, University of Shefﬁeld, Shefﬁeld, UK\n123\n94 J. J. Huerta y Munive, G. Struth\nFor pragmatic reasons, its language is restricted to differential terms of real arithmetic [ 14]\n(that of hybrid automata is usually restricted to polynomial or linear constraints [ 10]).\nOur initial motivation for this work has been the formalisation of a dL-style approach to\nhybrid program veriﬁcation in the Isabelle/HOL proof assistant [ 28] by combining Isabelle’s\nmathematical components for analysis and ordinary differential equations [ 23,29–31] with\nveriﬁcation components for modal Kleene algebras [ 17]. We are using a shallow embedding\nthat, in general, encodes semantic representations of domain-speciﬁc formalisms within a\nhost-language (deep embeddings start from syntactic representations using data types to\nprogram abstract syntax trees). This beneﬁts not only from the well-known advantages of\nshallowness: more rapid developments and simpler, more adaptable components. It has also\nshifted our focus from encoding d\nL’s complex syntactic proof system to developing denota-\ntional semantics for hybrid systems and supporting the natural style in which mathematicians,\nphysicists or engineers reason about them—without proof-theoretic baggage. After all, we\nget Isabelle’s own proof system and proof methods for free, and our expressive power is only\nlimited by its type theory and higher-order logic.\nOur main contribution is an open compositional semantic framework for the deductive\nveriﬁcation of hybrid programs in a general purpose proof assistant. In a nutshell, hybrid\nprograms are while programs, or simply programs with control loops, in which an evolu-\ntion command for the continuous system dynamics complements the standard assignment\ncommand for the discrete control. Evolution commands roughly specify vector ﬁelds (via\nsystems of ordinary differential equations) together with guards that model boundary condi-\ntions. Here, we restrict our attention to abstract predicate transformer algebras using modal\nKleene algebras [ 9], quantales of lattice endofunctions or quantaloids of functions between\nlattices [5]. They are instantiated ﬁrst to intermediate relational or state transformer semantics\nfor d\nL-style hybrid programs, and then to concrete semantics over program stores for hybrid\nprograms: for dynamical systems with global ﬂows, Lipschitz continuous vector ﬁelds with\nlocal ﬂows and continuous vector ﬁelds with multiple solutions. Another veriﬁcation compo-\nnent is based directly on ﬂows. This array of components demonstrates the compositionality\nand versatility of our framework. Figure 1 shows its basic anatomy.\nmodal Kleene\nalgebras\nstate transformers\npredicate trans-\nformer quantales\nbinary relations\npredicate trans-\nformer quantaloids\ndynamical systems Lipschitz continuous\nvector ﬁelds\ncontinuous\nvector ﬁelds\nhybrid store dynamics\nFig. 1 Isabelle framework for hybrid systems veriﬁcation\n123\nPredicate Transformer Semantics for Hybrid Systems 95\nOur framework beneﬁts from compositionality and algebra in various ways. Using alge-\nbra allows us to derive most of the semantic properties needed for veriﬁcation by equational\nreasoning, and it reduces the overhead of developing different concrete semantics to a mini-\nmum. Using modal Kleene algebras and predicate transformer algebras, in particular, makes\nlarge parts of veriﬁcation condition generation equational, and thus accessible to Isabelle’s\nsimpliﬁers. Compositionality of our extant framework for classical programs allows us to\nlocalise the development of concrete semantics for hybrid programs to the speciﬁcation and\nformalisation of a semantics for evolutions commands. We only need to replace standard\nmodels of the program store by a hybrid store model. In our denotational state transformer\nsemantics, evolution commands are interpreted as unions of all orbits of solutions of the\nvector ﬁeld at some initial value, subject to the guards constraining the durations of evolu-\ntions. This covers situations beyond the remits of the Picard–Lindelöf theorem [ 22,66]a n d\nsupports general reasoning about guarded invariant sets. Ultimately, we can simply plug the\npredicate transformers for evolution commands into the generic algebras for while programs\nand their rules for veriﬁcation condition generation.\nV eriﬁcation condition generation for evolution commands is supported by three workﬂows\nthat are inspired by d\nL, but work differently in practice:\n– The ﬁrst one asks users to supply a ﬂow and a Lipschitz constant for the vector ﬁeld spec-\niﬁed by the evolution command. We usually obtain this data using an external computer\nalgebra system (integrating one into Isabelle seems routine and is left for future work).\nAfter certifying the ﬂow conditions and checking Lipschitz continuity of the vector ﬁeld,\nas dictated by the Picard–Lindelöf theorem, the orbit for the ﬂow can be used to compute\nthe weakest liberal preconditions for the evolution command. This workﬂow deviates\nfrom d\nL in allowing users to supply an interval of interest as domain of the ﬂow.\n– The second workﬂow works more generally in situations where unique solutions need not\nexist or are difﬁcult to work with. It requires users to supply an invariant set for the vector\nﬁeld in the sense of dynamical systems theory [ 22,66]. After certifying the properties for\ninvariant sets, a correctness speciﬁcation for the evolution command and the invariant set\nis used in place of a weakest liberal precondition. Here, beyond d\nL, we support working\nwith solutions deﬁned over chosen intervals and using dL-style inference rules as well\nas arbitrary higher-order logic.\n– The third workﬂow uses ﬂows ab initio in the speciﬁcation and semantic analysis of\nevolution commands. This circumvents checking any continuity, existence, uniqueness\nor invariant conditions of vector ﬁelds mentioned. This is not at all supported by d\nL.\nWith all three workﬂows, hybrid program veriﬁcation is ultimately performed within\nthe concrete semantics. But, as with classical program veriﬁcation, veriﬁcation condition\ngeneration eliminates all structural conditions automatically so that proof obligations are\nentirely about the dynamics of the hybrid program store. They can be calculated in mathe-\nmatical textbook style by equational reasoning, and of course by external solvers and decision\nprocedures for arithmetic. (Their integration, as oracles or as veriﬁed components, is very\nimportant, but left for future work.) For the introductory examples presented, we have merely\nformalised some simple tactics that help automating the computation of derivatives in multi-\nvariate Banach spaces or that of polynomials and transcendental functions. Yet for those who\nprefer d\nL-style reasoning, we have formalised a rudimentary set of its inference rules that\nare sound relative to our semantics. Overall, unlike dL, which prescribes its domain-speciﬁc\nset of inference rules, we grant users the freedom of choice between various workﬂows and\neven of developing their own one within our semantic framework.\n123\n96 J. J. Huerta y Munive, G. Struth\nThe entire framework, including the mathematical development in this article, has been\nformalised with Isabelle/HOL. All Isabelle components can be found in the Archive of\nFormal Proofs [ 16,18,25,65]. We are currently using them to verify hybrid programs post\nhoc in the standard weakest liberal precondition style outlined above. Yet the approach is\nﬂexible enough to support the veriﬁcation of hybrid systems using Hoare logic [ 11], symbolic\nexecution with strongest postconditions, program reﬁnement with predicate transformers in\nthe style of Back and von Wright [ 5] and Morgan [ 11], and reasoning about hybrid program\nequivalences in the elegant equational style of Kleene algebra with tests [ 37].\nWhile our approach is powerful enough to tackle most problems of a recent systems\ncompetition [ 45], the work documented in this article focuses mainly on the semantic foun-\ndations and the proof of concept that the approach works. A more user-friendly speciﬁcation\nlanguage, a less simplistic hybrid store model, enhanced tactics for reasoning with ﬂows\nand invariants, and mathematical background theories for reasoning about afﬁne and linear\nsystems of differential equations have been added, while this article has been under review\n[12,26]. The doctoral dissertation of the ﬁrst author contains a more comprehensive descrip-\ntion of the framework and further generalisations [ 27].\nThe remainder of this article is organised as follows: Sects. 2–6 introduce the algebras of\nrelations, state and predicate transformers needed. Section 7 explains the shallow embedding\nused to formalise veriﬁcation components for while programs. After recalling the basics\nof differential equations in Sect. 8, we introduce our semantics for evolution commands in\nSects. 9–11 and explain our procedures for computing weakest liberal preconditions and\nreasoning with differential invariants for them. Sections 13–15 summarise the corresponding\nIsabelle components. Sections 12 and 16 brieﬂy list the derivation and formalisation of\nsemantic variants of d\nL inference rules. Section 17 presents four veriﬁcation examples in\nour framework using the main two workﬂows. Section 18 presents our third workﬂow and\na brief example for it. Sections 19 and 20 discuss related work and conclude the article. A\nglossary of cross-references between theorems in the text and the Isabelle theories is presented\nin Appendix A.\n2 KleeneAlgebra\nThis section summarises the mathematical foundations of our simplest and most developed\npredicate transformer algebra—modal Kleene algebra. It introduces the basics of Kleene\nalgebras, and the state transformer model and relational model used. The relational model is\nstandard for Kleene algebra. The state transformer model has so far received less attention\nand is therefore explained in detail.\nA dioid (S,+,·,0,1) is an additively idempotent semiring, α + α = α holds for all\nα ∈ S. The underlying abelian monoid (S,+,0) is therefore a semilattice with order deﬁned\nby α ≤ β ↔ α + β = β. The order is preserved by · and + in both arguments; 0 is its least\nelement.\nA Kleene algebra (K ,+,·,0,1,\n∗ ) is a dioid expanded by the Kleene star (−)∗ : K → K\nthat satisﬁes the left and right unfold and induction axioms\n1 + α · α∗ ≤ α∗,γ + α · β ≤ β → α∗ · γ ≤ β,\n1 + α∗ · α ≤ α∗,γ + β · α ≤ β → γ · α∗ ≤ β.\nBy these axioms, α∗ · γ is the least ﬁxpoint of the function γ + α · (−) and γ · α∗ that of\nγ +(−)·α, where we use −as a wildcard for function arguments. The ﬁxpoint α∗ arises as a\n123\nPredicate Transformer Semantics for Hybrid Systems 97\nspecial case. The more general induction axioms combine its deﬁnition with sup-preservation\nor continuity of left and right multiplication.\nOpposition is an important duality of Kleene algebras: swapping the order of multiplication\nin any Kleene algebra yields another one. The class of Kleene algebras is therefore closed\nunder opposition.\nKleene algebras were conceived as algebras of regular expressions. But here we interpret\ntheir elements as programs. Addition models their nondeterministic choice, multiplication\ntheir sequential composition and the Kleene star their unbounded ﬁnite iteration. The element\n0 models abort; 1 models the ineffective program. Two programs are deemed equal if they\nlead from the same inputs to the same outputs. These intuitions are grounded in concrete\nprogram semantics.\nWith the relational composition of R ⊆ X × Y and S ⊆ Y × Z deﬁned as (R;S) xz if\nRxy and Syz for some y ∈ Y , with Id\nX xy if x = y, and the reﬂexive-transitive closure\nof R ⊆ X × X deﬁned as R∗ = ⋃\ni∈N Ri ,w h e r e R0 = IdX and Ri+1 = R; Ri ,w h e r ew e\nwrite Rxy instead of (x, y) ∈ R, the following holds.\nProposition 2.1 Let X be a set. Then, Rel X = (P (X × X),∪,;,∅,IdX ,∗ ) forms a Kleene\nalgebra—the full relation Kleene algebra over X.\nA relation Kleene algebra over X is thus any subalgebra of Rel X.\nOpposition can be expressed in Rel X by conversion, where the converse of relation R is\ndeﬁned by R⌣ xy ↔ Ryx . It satisﬁes in particular (R;S)⌣ = S⌣ ; R⌣ .\nThe isomorphism P (X × Y ) ∼= (P Y )X between categories of relations and non-\ndeterministic functions—so-called state transformers—yields an alternative representation.\nIt is given by the bijections F : P (X ×Y ) → (P Y )X and R : (P Y )X → P(X ×Y ) deﬁned\nby F Rx ={ y ∈ Y | Rxy } and by R fxy ⇔ y ∈ fx . Following Isabelle syntax, we use\njuxtaposition with a space to denote function application. State transformers f : X → P Y\nand g : Y → P Z are composed by the (forward) Kleisli composition of the powerset monad\n( f ◦K g) x =\n⋃\n{gy | y ∈ fx }.\nThe function ηX ={ − }is a unit of this monad. The functors F and R preserve arbitrary sups\nand infs, extended pointwise to state transformers, and stars f ∗K x = ⋃\ni∈N f iK x,w h i c h\nare deﬁned with respect to Kleisli composition.\nProposition 2.2 Let X be a set. Then, Sta X = ((P X)X ,∪,◦K ,λ x. ∅,η X ,∗K ) forms a\nKleene algebra—the full state transformer Kleene algebra over X.\nA state transformer Kleene algebra over X is any subalgebra of Sta X. Opposition is now\nexpressed using the (contravariant) functor (−)op = F ◦(−)⌣ ◦R that associates f op : Y →\nP X with every f : X → P Y .\nThe category Rel, with relations of type X × Y or state transformers of type X → P Y\nas arrows, is beyond mono-type Kleene algebra.\nFor a more reﬁned hierarchy of variants of Kleene algebras, their calculational properties\nand the most important computational models, see our formalisation in the Archive of Formal\nProofs [ 3]. The state transformer model has been formalised with Isabelle for this article.\n123\n98 J. J. Huerta y Munive, G. Struth\n3 ModalKleeneAlgebra\nKleene algebras must be extended to express conditionals or while loops more faithfully. This\nrequires tests, which are not prima facie actions, but propositions. Assertions and correctness\nspeciﬁcations cannot be expressed directly either.\nTwo standard extensions bring Kleene algebra closer to program semantics. Kleene algebra\nwith tests [37] yields a simple algebraic semantics for while programs and a partial correctness\nsemantics for these in terms of an algebraic propositional Hoare logic—ignoring assignments.\nPredicate transformer semantics, however, cannot be expressed [ 61]. Alternatively, Kleene\nalgebras can be enriched by modal box and diamond operators in the style of propositional\ndynamic logic ( PDL), which yields test and assertions as well as predicate transformers.\nYet once again, assignments cannot be expressed within the algebra. We outline the second\napproach.\nAn antidomain semiring [9] is a semiring S expanded by an antidomain operation ad :\nS → S axiomatised by\nad α · α = 0, ad α + ad\n2 α = 1, ad (α · β) ≤ ad (α · ad2 β).\nBy opposition, an antirange semiring[9] is a semiring S expanded by an antirange operation\nar : S → S axiomatised by\nα · ar α = 0, ar α +ar2 α = 1, ar (α · β) ≤ ar (ar2 α · β).\nAntidomain and antirange semirings are a fortiori dioids.\nThe antidomain ad α of program α models the set of those states from which α cannot\nbe executed. The operation d = ad2 thus deﬁnes the domain of a program: the set of those\nstates from which it can be executed. By opposition, the antirange ar α of α yields those\nstates into which α cannot be executed and r = ar2 deﬁnes the range of α: those states into\nwhich it can be executed.\nA modal Kleene algebra (MKA)[ 9] is a Kleene algebra that is both an antidomain and an\nantirange Kleene algebra in which d ◦r = r and r ◦d = d.\nIn a MKA K ,t h es e t P ad K —the image of K under ad—models the set of all tests\nor propositions. We henceforth often write p,q,... for its elements. Moreover, P ad K =\nP dK = P rK = P ar K = Kd = Kr ,w h e r e K f ={ α ∈ S | f α = α} for f ∈{ d,r}.\nHence, p ∈ P ad K ↔ dp = p. It follows that the class MKA is closed under opposition. In\naddition, Kd forms a Boolean algebra with least element 0, greatest element 1, join +, meet\n· and complementation ad—the algebra of propositions, assertions or tests.\nAxiomatising MKA based on domain and range would lack the power to express comple-\nmentation: Kd would only be a distributive lattice.\nThe programming intuitions for MKA are once again grounded in concrete semantics.\nProposition 3.1 If X is a set, then Rel X is the full relation MKA over X with\nad R x x ↔¬ ∃y ∈ X. R x y and ar R = ad R⌣ .\nEvery subalgebra of a full relation MKA is a relation MKA.\nSimilarly, ar = ad ◦(−)⌣ , d = r ◦(−)⌣ and r = d ◦ (−)⌣ . Furthermore,\n(P (X × X))d ={ P | P ⊆ IdX }.\nHenceforth, we often identify such relational subidentities, sets and predicates and their types\nvia the isomorphisms (P (X × X))d ∼= X → B ∼= P X.\n123\nPredicate Transformer Semantics for Hybrid Systems 99\nProposition 3.2 Let X be a set. Then, Sta X is the full state transformer MKA over X with\nad f x =\n{\nηX x, if f x =∅ ,\n∅, otherwise, and ar f = ad f op.\nEvery subalgebra of a full relation MKA is a state transformer MKA. Similarly,\ndfx =\n{\n∅, if fx =∅ ,\nηX x, otherwise, and rf = df op.\nThese propositions generalise again beyond mono-types, but algebras of such typed relations\nand state transformers cannot be captured by MKA.\nIn every MKA, p · α and α · p model the domain and range restriction of α to states\nsatisfying p. Conditionals and while loops can thus be expressed:\nif p then α else β = p · α +¯p · β and while p do α = (p · α)∗ ·¯p,\nwhere we write ¯p = ad p = ar p. Together with sequential composition α;β = α · β,t h i s\nyields an algebraic semantics of while programs without assignments. It is grounded in the\nrelational and the state transformer semantics. A more reﬁned hierarchy of variants of MKAs,\nstarting from domain and antidomain semigroups, their calculational properties and the most\nimportant computational models, can be found in the Archive of Formal Proofs [ 16]. The\nstate transformer model of MKA has been formalised with Isabelle for this article.\n4 ModalKleeneAlgebra,PredicateTransformersandInvariants\nMKA can express the modal operators of PDL, both with a relational Kripke semantics and a\ncoalgebraic state transformer semantics.\n|α⟩p = d (α · p), |α]p = ad (α · ad p), ⟨α|p = r (p · α), [α|p = ar (ar p · α).\nThis is consistent with Jónsson and Tarski’s Boolean algebras with operators [ 35]: Each of\n|α⟩, ⟨α|, |α] and [α| is an endofunction Kd → Kd on the Boolean algebra Kd . Yet another\nview of modal operators is that of predicate transformers. The function |−]− yields the\nweakest liberal precondition operator wlp; ⟨−|− the strongest postcondition operator.\nThe boxes and diamonds of MKA are related by De Morgan duality:\n|α⟩p = |α]¯p, |α]p = |α⟩¯p, ⟨α|p = [α|¯p, [α|p = ⟨α|¯p ;\ntheir dualities are captured by the adjunctions and conjugations\n|α⟩p ≤ q ↔ p ≤[ α|q, ⟨α|p ≤ q ↔ p ≤| α]q,\n|α⟩p ·q = 0 ↔ p ·⟨α|q = 0, |α]p +q = 1 ↔ p +[ α|q = 1.\nIn Rel X, as in standard Kripke semantics of modal logics in general, and of PDL in\nparticular,\n|R⟩P ={ x |∃ y ∈ X. Rxy ∧ Py } and |R]P ={ x |∀ y ∈ X. Rxy → Py },\nwhere we identify predicates and subidentity relations. For the remaining two modalities,\n⟨−| = |−⟩ ◦(−)⌣ and [−| = |−] ◦(−)⌣ . Hence, |R⟩P is the preimage of P under R and\n⟨R|P the image of P under R. The isomorphism between subidentities, predicates and sets\n123\n100 J. J. Huerta y Munive, G. Struth\nalso allows us to see |R⟩, ⟨R|, |R] and [R| as operators on the complete atomic Boolean\nalgebra P X, which carries algebraic structure beyond Kd that is reminiscent of a module.\nIn Sta X, alternatively,\n⟨f |P ={ y |∃ x. y ∈ fx ∧ Px } and |f ]P ={ x | fx ⊆ P}.\nMoreover, |−⟩ = ⟨−|◦(−)op and [−| = |−]◦(−)op. Here, ⟨f | is the Kleisli extension of f\nfor the powerset monad and |f ⟩ that of the opposite function (see Sect. 6).\nThe isomorphism P (X × X) ∼= (P X)X makes the approaches coherent:\n|f ⟩=| R f ⟩, |R⟩=| F R⟩, |f ]=| R f ], |R]=| F R],\nand, dually, ⟨f |=⟨ R f |, ⟨R|=⟨ F R|, [f |=[ R f | and [R|=[ F R|.\nPredicate transformers are useful for specifying program correctness conditions and for\nveriﬁcation condition generation. The identity\np ≤| α]q\ncaptures the standard partial correctness speciﬁcation for programs: if α is executed from\nstates where precondition p holds, and if it terminates, then postcondition q holds in the states\nwhere it does. V erifying it amounts to computing |α]q recursively over the program structure\nfrom q and checking that the result is greater or equal to p. Intuitively, |α]q represents the\nlargest set of states from which one must end up in set q when executing α, or alternatively\nthe weakest precondition from which postcondition q must hold when executing α.\nCalculating |α]q for straight-line programs is completely equational, but loops require\ninvariants. To this end, one usually adds annotations to loops,\nwhile p inv i do α = while p do α,\nwhere i is the loop invariant for α and calculates wlps as follows [ 17,18]. For all p,q,i,t ∈\nKd and α, β ∈ K ,\n|α · β]q =| α]|β]q, (wlp-seq)\n|if p then α else β]q = ( ¯p +| α]q) · (p +| β]q) = p ·| α]q +¯p ·| β]q, (wlp-cond)\ni ≤| α]i → i ≤| α∗]i, (wlp-star)\np ≤ i ∧i · t ≤| α]i ∧i · ¯t ≤ q → p ≤| while t inv i do α]q. (wlp-while)\nIn the rule ( wlp-star), i is an invariant for the star as well. In addition, we support a while\nrule without an invariant annotation.\nMore generally, beyond loops, an element i ∈ Kd is an invariant for α if it is a postﬁxpoint\nof |α] in Kd :\ni ≤| α]i.\nBy the adjunction between boxes and diamonds, this is the case if and only if ⟨α|i ≤ i;t h a t\nis, i is a preﬁxpoint of ⟨α| in Kd . We return to this equivalence in the context of differential\ninvariants and invariant sets of vector ﬁelds in Sect. 11. We write Inv α for the set of invariants\nof α.\nLemma 4.1 In every MKA,i fi , j ∈ Inv α,t h e ni+ j,i · j ∈ Inv α.\n123\nPredicate Transformer Semantics for Hybrid Systems 101\nAs a generalisation of the rule ( wlp-while) for annotated while loops, we can derive a\nrule for commands annotated with tentative invariants α inv i = α.F o ra l l i, p,q ∈ Kd and\nα ∈ K ,\np ≤ i ∧i ≤| α]i ∧i ≤ q → p ≤| α inv i]q. (wlp-cmd)\nCombining ( wlp-cmd) with ( wlp-star) then yields, for loop α inv i = α∗,\np ≤ i ∧i ≤| α]i ∧i ≤ q → p ≤| loop α inv i]q. (wlp-loop-inv)\nWe use such annotated commands for reasoning about differential invariants and loops of\nhybrid programs below.\nThe modal operators of MKA have, of course, a much richer algebra beyond veriﬁcation\ncondition generation. For a comprehensive list, see the Archive of Formal Proofs [ 16]. We\nhave already derived the rules of propositional Hoare logic, which ignores assignments, and\nthose for veriﬁcation condition generation for symbolic execution with strongest postcon-\nditions in this setting [ 18]. A component for total correctness is also available. It supports\nreﬁnement proofs in the style of Back and von Wright [ 5]. But this is beyond the scope of\nthis article. The other two abstract predicate transformer algebras from Fig. 1 are surveyed\nin the following two sections.\n5 PredicateTransformersàlaBackandvonWright\nWhile MKA has so far been our most developed setting for verifying (hybrid) programs, our\nframework is compositional and supports other predicate transformer algebras as well. Two\nof them are outlined in this and the following section. Their Isabelle formalisation [ 65]i s\ndiscussed in Sect. 6.\nThe ﬁrst approach follows Back and von Wright [ 5] in modelling predicate transformers,\nor simply transformers, as functions between complete lattices. Readers not familiar with\nlattice theory can freely skip this section. To obtain useful laws for program construction or\nveriﬁcation, conditions are imposed.\nA function f : L\n1 → L2 between two complete lattices (L1,≤1) and (L2,≤2) is order-\npreserving if x ≤1 y → fx ≤2 fy , sup-preserving if f ◦⨆ = ⨆ ◦P f and inf-preserving\nif f ◦/bigsqcap= /bigsqcap◦P f . All sup- or inf-preserving functions are order-preserving.\nWe write T (L) for the set of transformers over the complete lattice L,a n d T≤(L), T⊔ (L),\nT⊓ (L) for the subsets of order-, sup- and inf-preserving transformers. Obviously, T⊓ (L) =\nT⊔ (Lop). The following fact is well known [ 5,15].\nProposition 5.1 Let X be a set, and let L be a complete lattice. Then, L X forms a complete\nlattice with order and sups extended pointwise.\nInfs, least and greatest elements can then be deﬁned from sups on L X as usual. Function\nspaces LL , in particular, form monoids with respect to function composition ◦ and idL .I n\naddition, ◦ preserves sups and infs in its ﬁrst argument, but not necessarily in its second one.\nAlgebraically, this is captured as follows.\nA near-quantale (Q,≤,·) is a complete lattice (Q,≤) with an associative composition ·\nthat preserves sups in its ﬁrst argument. It is unital if composition has a unit 1. A prequantaleis\na near-quantale in which composition is order-preserving in its second argument. A quantale\nis a near quantale in which composition preserves sups in its second argument. See [ 56]f o r\nmore information about quantales.\n123\n102 J. J. Huerta y Munive, G. Struth\nProposition 5.2 Let L be a complete lattice. Then,\n1. T (L) and T (Lop) form unital near-quantales;\n2. T≤(L) (T≤(Lop)) forms a unital sub-prequantale of T (L) (T (Lop));\n3. T⊔ (L) (T⊓ (L)) forms a unital subquantale of T≤(L) (T≤(Lop)).\nTransformers for while loops are obtained by connecting quantales with Kleene algebras.\nThis requires ﬁxpoints of ϕαγ = γ ⊔ α · (−) and ϕα = 1 ⊔ α · (−) as well as the Kleene\nstar α∗ = ⨆\ni∈N αi .A left Kleene algebra is a dioid in which ϕ has a least ﬁxpoint that\nsatisﬁes lfp ϕαγ = lfp ϕα · γ. Hence, ϕα satisﬁes the left unfold and left induction axioms\n1 ⊔ α ·ϕα ≤ ϕα and γ ⊔ α ·β ≤ β → ϕα ·γ ≤ β. By opposition, a right Kleene algebra is\na dioid in which the least ﬁxpoint of a dual function 1 ⊔ (−) ·α satisﬁes the right unfold and\nright induction axioms.\nProposition 5.3\n1. Every near-quantale is a right Kleene algebra with lfp ϕα = α∗.\n2. Every prequantale is also a left Kleene algebra.\n3. Every quantale is a Kleene algebra with lfp ϕ\nα = α∗.\nThe proofs of (1) and (3) use sup-preservation and Kleene’s ﬁxpoint theorem. That of (2)\nuses the Knaster–Tarski ﬁxpoint theorem to show that ϕαγ has a least ﬁxpoint, and ﬁxpoint\nfusion [ 44]t od e r i v e lfp ϕαγ = lfp ϕα · γ, which yields the left Kleene algebra axioms. In\nprequantales, lfp ϕα · γ ≤ α∗ · γ; equality generally requires sup-preservation in the ﬁrst\nargument of composition.\nThe ﬁxpoint and iteration laws on functions spaces, which follow from Propositions 5.3\nand 5.2, still need to be translated into laws for transformers operating on the underlying\nlattice. This is achieved again by ﬁxpoint fusion [ 5]. In T≤(L),\nlfp (λg. idL ⊔ f ◦ g) x = lfp (λy. x ⊔ fy ),\nand lfp preserves isotonicity. In T⊔ (L), moreover,\nfx ≤ x → f ∗ x ≤ x,\nidL ⊔ f ◦ f ∗ = f ∗ = f ∗◦ f ⊔ idL and (−)∗ preserves sups. All results dualise to inf-preserving\ntransformers.\nRelative to MKA, backward diamonds correspond to sup-preserving forward transformers\nand forward boxes to inf-preserving backward transformers in the opposite quantale, where\nthe lattice has been dualised and the order of composition been swapped. An analogous\ncorrespondence holds for forward diamonds and backward boxes. Sup- and inf-preserving\ntransformers over complete lattices are less general than MKA in that preservation of arbitrary\nsups or infs is required, whereas that of MKA is restricted to ﬁnite sups and infs. Isotone\ntransformers, however, are more general, as not even ﬁnite sups or infs need to be preserved,\nand ﬁnite sup- or inf-preservation implies order preservation.\nWe are mainly using the wlp operator for veriﬁcation condition generation and hence\nbrieﬂy outline wlps for conditionals and loops in this setting. We assume that the underlying\nlattice L is a complete Boolean algebra, that is, a complete lattice as well as a complemented\ndistributive lattice. We can then lift elements of L to wlpsa s |p]q = p → q and deﬁne, in\nT≤(Lop),\nif p then f else g =| p]◦ f ⊓|¯ p]◦ g and while p do f = lfp ϕ|p]f ◦|¯p].\n123\nPredicate Transformer Semantics for Hybrid Systems 103\nIn T⊓ (L),w ee v e no b t a i n\nwhile p do f = (|p]◦ f )∗ ◦|¯p].\nThese equations allow generating veriﬁcation conditions as with ( wlp-cond)a n d( wlp-while)\nfrom Sect. 4. Overall, our Isabelle components for lattice-based predicate transformers in the\nArchive of Formal Proofs [ 65] contain essentially the same equations and rules for veriﬁcation\ncondition generation as those for MKA.\nWe have so far restricted the approach to endofunctions on a complete lattice to relate it\nto MKA. Yet it generalises to functions in LL1\n2 and hence to categories [ 5]. The correspond-\ning poly-typed generalisations of quantales are known as quantaloids [55]. In particular,\ncomposition is then a partial operation.\n6 PredicateTransformersfromthePowersetMonad\nA second, more coalgebraic approach to predicate transformers starts from monads [ 41]. In\naddition, it details the relational and state transformer semantics of MKA in a more modern\nalgebraic approach. We need to assume basic knowledge of categories and monads. Once\nagain, readers unfamiliar with these concepts can freely skip it.\nRecall that (\nP,η X ,μ X ),f o r P : Set → Set, ηX : X → P X deﬁned by ηX ={ − }and\nμX : P2 X → P X deﬁned by μX = ⋃ is the monad of the powerset functor in the category\nSet of sets and functions. The morphisms η and μ are natural transformations. They satisfy,\nfor every f : X → Y ,\nηY ◦id f = P f ◦ ηX and μY ◦P2 f = P f ◦μX .\nFrom the monadic point of view, state transformers X → P Y are arrows X → Y in the\nKleisli category SetP of P over Set. They are composed by (forward) Kleisli composition\nf ◦K g = μ ◦ P g ◦ f as explained before Proposition 2.2 in Sect. 2. The category SetP is\nknown to be isomorphic to Rel, the category of sets and binary relations.\nThe isomorphism between state and forward predicate transformers is based on the con-\ntravariant functor (−)† : SetP (X,P Y ) → SetP (P X,P Y )—the Kleisli extension. Its\ndeﬁnition f † = μ ◦ P f implies that (−)† =⟨ − |on morphisms, which is the strongest\npostcondition operator.\nThe structure of state spaces—Boolean algebras for MKA, complete lattices in Back and\nvon Wright’s approach—is captured by the Eilenberg–Moore algebras of the powerset monad.\nIt is well known that (−)\n† embeds SetP into their category. Its objects are complete (sup-\nsemi)lattices; its morphisms sup-preserving functions, hence transformers. More precisely,\n(−)\n† embeds into powerset algebras, complete atomic Boolean algebras that are the free\nobjects in this category.\nThe isomorphism SetP (X,P Y ) ∼= Set⊔ (P X,P Y ) between state transformers and\nsup-preserving predicate transformers then arises as follows. The embedding ⟨−| has an\ninjective inverse ⟨−|−1 on the subcategory of sup-preserving transformers. It is deﬁned by\n⟨−|−1 = (−) ◦ η, which can be spelled out as ⟨ϕ|−1 x ={ y | y ∈ ϕ {x}}. The isomorphism\npreserves the quantaloid structures of state and predicate transformers that is, compositions\n(contravariantly), units and sups, hence least elements, but not necessarily infs and greatest\nelements. These results extend to Set\n⊔ (P X,P Y ) ∼= Rel(X, Y ) via SetP ∼= Rel. In addition,\npredicate transformers ⟨f |: P X → P Y preserve of course sups in powerset lattices, hence\nleast elements, but not necessarily infs and greatest elements.\n123\n104 J. J. Huerta y Munive, G. Struth\nForward boxes or wlps can be obtained from state transformers via a (covariant) functor\n|−] : SetP (X,P Y ) → Set(P Y ,P X), embedding Kleisli arrows into the opposite of\nthe category of Eilenberg–Moore algebras formed by complete (inf-semi)lattices and inf-\npreserving functions. It is deﬁned on morphisms as |−] =∂\nF ◦⟨ − |◦(−)op,w h e r e∂F f =\n∂ ◦ f ◦∂ and ∂ dualises the lattice. Unfolding deﬁnitions, once again |f ] P ={ x | fx ⊆ P}.\nFurthermore, its inverse |−]−1 on the subcategory of inf-preserving transformers is\n|ϕ]−1 x = ⋂ {P | x ∈ ϕ P}. The duality SetP (X,P Y ) ∼= Set⊓ (P Y ,P X) reverses Kleisli\narrows and preserves the quantaloid structures up to lattice duality, mapping sups to infs and\nvice versa. It extends to relations as before. In addition, predicate transformers |f ] preserve\nof course infs of powerset lattices, hence greatest elements, but not necessarily sups and least\nelements.\nThe remaining transformers |−⟩ and [−| and their inverses arise from ⟨−| and |−] by\nopposition: |−⟩ = ⟨−| ◦(−)\nop, |−⟩−1 = (−)op ◦⟨ − |−1, [−| = |−] ◦(−)op and [−|−1 =\n(−)op ◦|−]−1. Taken together, the four modal operators satisfy the laws of the MKA modalities\noutlined in Sect. 4 and those of the abstract sup/inf-preserving transformers discussed in\nSect. 5. They give in fact semantics to the algebraic developments, when restricted to mono-\ntypes, and once again yield the same rules for veriﬁcation condition in the state transformer\nand the relational semantics, albeit in a more general categorical setting.\nThe categorical approach to predicate transformers outlined is not new, apart perhaps\nfrom the emphasis on quantales and quantaloids. The emphasis on monads is due at least\nto Manes [ 43]. More recently, Jacob’s work on state-and-effect triangles [ 32] has explored\nsimilar connections and their generalisation beyond sequential programs. A formalisation\nwith Isabelle, which is further discussed in Sect. 13, is a contribution of this article.\n7 Assignments\nTwo important ingredients for concrete program semantics and veriﬁcation condition gener-\nation are still missing: a mathematical model of the program store and program assignments,\nand rules for calculating wlps for these basic commands. To prepare for hybrid programs (see\nSect. 9 for a syntax), we model stores and assignments as discrete dynamical systems over\nstate spaces.\nFormally, a dynamical system [4,66]i sa n action of a monoid (M,⋆ ,u) on a set or state\nspace S, that is, a monoid morphism ϕ : M → S → S into the transformation monoid\n(S\nS,◦,idS) on SS. Thus, by deﬁnition,\nϕ( m ⋆ n) = (ϕ m) ◦(ϕ n) and ϕ u = idS.\nThe ﬁrst action axiom captures the inherent determinism of dynamical systems. Conversely,\neach transformation monoid (SS,◦,idS) determines a monoid action in which the action\nϕ : SS → S → S is function application.\nStates of simple while programs can be modelled simply as maps s : V → E from\nprogram variables in V to values in E. State spaces for such discrete dynamical systems are\nfunction spaces S = EV .\nAn update function fa : V → (S → E) → S → S for assignment commands can be\ndeﬁned as\nfa v es = s[v ↦→ es ],\nwhere f [a ↦→ b] updates f : A → B by associating a ∈ A with b and every y ̸= a with\nfy . The “expression” e : S → E is evaluated in state s to es . The maps fa v e generate a\n123\nPredicate Transformer Semantics for Hybrid Systems 105\ntransformation monoid, hence a monoid action SS → S → S on SS. They also connect\nthe concrete program store semantics with the wlp semantics used for veriﬁcation condition\ngeneration.\nWe lift fa v e : S → S to a state transformer v :=F e : S → P S as\n(v :=F e) = ηS ◦( fa v e) = λs. {fa v es },\nthus creating a semantic illusion for syntactic assignment commands in the MKA Sta S.F o r\nRel S, the isomorphism between SetP and Rel yields\n(v :=R e) = R (v :=F e),\nhence (v :=R e) ={ (s, fa v es ) | s ∈ EV }={ (s,s[v ↦→ es ]) | s ∈ EV }. Alternatively,\nwe could have deﬁned the state transformer semantics from the relational one via (v :=F\ne) = F (v :=R e).\nThe wlps for assignment commands in Rel S and Sta S are of course the same. Hence, we\ndrop the indices F and R and write\n|v := e]Q = λs. Q (s[v ↦→ es ]) = λs. Q ( fa v es ). (wlp-asgn)\nAdding the wlp law for assignments in either semantics to the algebraic ones for the\nprogram structure sufﬁces to generate data-level veriﬁcation conditions for while programs.\nThe approach outlined so far is suited for building veriﬁcation components via shallow\nembeddings with proof assistants such as Isabelle. The predicate transformer algebras of the\nprevious sections, as shown in the ﬁrst row of Fig. 1, can all be instantiated to intermediate\nstate transformer and relational semantics, as shown in Propositions 3.1 and 3.2 for MKA.\nThese form the second row in Fig. 1. Each of these can be instantiated further to concrete\nsemantics with predicate transformers for assignments, as described in this section.\nIn Isabelle, these instantiations are enabled by type polymorphism. If modal Kleene\nalgebras have type\n′a, then the intermediate semantics have the type of relations or state\ntransformers over ′a, and Propositions 3.1 and 3.2 can be formalised, so that all facts known\nfor MKA are available in the intermediate semantics. The concrete semantics then require\nanother simple instantiation of the types of relations or state transformers to those of pro-\ngram stores. All facts known for MKA and the two intermediate semantics are then available\nin the concrete predicate transformer semantics for while programs. A particularity of the\nsemantic approach and the shallow embedding is that assignment semantics are based on\nfunction updates instead of substitutions—see the rule ( wlp-asgn)—so that an explicit sub-\nstitution calculus like that of d\nL is not needed. We can simply rely on that of Isabelle/HOL.\nThe use of algebra and the modularity of the shallow semantics simplify the construction\nof program veriﬁcation components [ 18] considerably. The overall approach discussed has\nbeen developed initially for Hoare logics in [ 2]. It has been extended to predicate transformer\nsemantics based on MKA in [ 17].\n8 OrdinaryDiﬀerentialEquations\nBefore developing relational and state transformer models for the basic evolution commands\nof hybrid programs in the next section, we brieﬂy review some basic facts about continuous\ndynamical systems and ordinary differential equations.\nContinuous dynamical systems ϕ : T → S → S are ﬂows, which often represent solutions\nto systems of ordinary differential equations (ODEs) [ 4,22,66]. They are called continuous\n123\n106 J. J. Huerta y Munive, G. Struth\nbecause T , which models time, is assumed to form a non-discrete submonoid of (R,+,0),\nand the state space or phase space S is usually a manifold with topological structure. By\ndeﬁnition, ﬂows are monoid actions. Hence, ϕ satisﬁes, for all t1,t2 ∈ T ,\nϕ( t1 + t2) = ϕ t1 ◦ϕ t2 and ϕ 0 = id.\nWe always assume that T is an open interval in R and S an open subset of Rn. Beyond that,\none usually assumes that actions are compatible with the structure on S.A s S is a manifold,\nwe assume that ﬂows are continuously differentiable.\nThe trajectory of ϕ through state s ∈ S is the function ϕs : T → S deﬁned by ϕs =\nλt.ϕ ts ,t h a ti s ,ϕs t = ϕ ts . It describes the system’s evolution in time passing through state\ns.\nThe orbit of s is the set of all states on the trajectory passing through s, but not necessarily\nstarting in this state. We model it as the function γϕ : S → P S deﬁned by\nγϕ s = P ϕs T ,\nthe canonical map sending each s ∈ S to its equivalence class γϕ s. Orbit functions are state\ntransformers, as their type indicates. They form our basic semantics for evolution commands\nand hybrid programs.\nFlows arise from ODEs as follows. In a system of ODEs\nx\n′\ni t = fi (t,( x1 t) ,...,( xn t)), ( 1 ≤ i ≤ n),\neach fi is a continuous real-valued function and t ∈ T ⊆ R. Any such system can be made\ntime-independent—or autonomous—by adding the equation x′\n0 t = 1. We henceforth restrict\nour attention to autonomous systems and write\nX′t =\n⎛\n⎜⎜\n⎜⎝\nx\n′\n1 t\nx′\n2 t\n...\nx′\nn t\n⎞\n⎟⎟\n⎟⎠ =\n⎛\n⎜⎜\n⎜⎝\nf\n1 (x1 t)...( xn t)\nf2 (x1 t)...( xn t)\n...\nfn (x1 t)...( xn t)\n⎞\n⎟⎟\n⎟⎠ = f (Xt ).\nThe continuous function f : S → S on S ⊆ R\nn is a vector ﬁeld. It assigns a vector to each\npoint in S.\nAn autonomous system of ODEs is thus simply a vector ﬁeld f ,a n da solution a continu-\nously differentiable function X : T → S that satisﬁes X′t = f (Xt ) for all t ∈ T ,o rm o r e\nbrieﬂy X′ = f ◦ X.\nAn initial value problem (IVP) is a pair ( f ,s) of a vector ﬁeld f and an initial value\n(0,s) ∈ T × S [22,66], where t0 = 0a n d s represent the initial time and initial state of the\nsystem. A solution to the IVP ( f ,s) satisﬁes\nX′ = f ◦ X and X 0 = s.\nIf solutions X to an IVP ( f ,s) are unique and T = R, then it is easy to show that X = ϕ f\ns\nis the trajectory of the ﬂow ϕ f through s.\nGeometrically,ϕ f\ns is the unique curve in S that is parametrised by t, passes through s and is\ntangential to f at any point. As trajectories arise from integrating both sides of (ϕ f\ns )′ = f ◦ϕ f\ns ,\nthey are also called integral curves. We henceforth write ϕs when the dependency on f is\nclear.\nThe following example provides some physical intuition for readers unfamiliar with these\nconcepts.\n123\nPredicate Transformer Semantics for Hybrid Systems 107\nExample 8.1 (Particles in ﬂuid) We use the autonomous system of ODEs\nx′t = v, y′t = 0, z′t =− sin (xt ),\nwhere v ∈ R \\{ 0} is a constant, as a simple model for the movement of particles in a\nthree-dimensional ﬂuid. Its vector ﬁeld f : R3 → R3,\nf\n⎛\n⎝\nx\ny\nz\n⎞\n⎠ =\n⎛\n⎝\nv\n0\n−sin x\n⎞\n⎠ ,\nassociates a velocity vector with each point of S = R3 (vectors in Fig. 2).\nFor each point s = (s1,s2,s3)T , the solutions ϕs : R → R3 of the IVP ( f ,s) are uniquely\ndeﬁned. They are the trajectories of particles through time passing through state s (dot and\nline in Fig. 2), given by\nϕs t =\n⎛\n⎝\ns1\ns2\ns3\n⎞\n⎠ +\n⎛\n⎝\nvt\n0\ncos (s1+vt)\nv − cos s1\nv\n⎞\n⎠ ,\nwhere we use juxtaposition without spaces as multiplication of real numbers.\nChecking that they are indeed solutions to the IVP requires simple calculations:\nϕ′\ns t =\n⎛\n⎝\nv\n0\n−sin (s1 + vt)\n⎞\n⎠ = f\n⎛\n⎝\ns1 + vt\ns2\ns3 + cos (s1+vt)\nv − cos s1\nv\n⎞\n⎠ = f (ϕs t),\nϕs 0 =\n⎛\n⎝\ns1\ns2\ns3\n⎞\n⎠ +\n⎛\n⎝\nv0\n0\ncos (s1+v0)\nv − cos s1\nv\n⎞\n⎠ =\n⎛\n⎝\ns1\ns2\ns3\n⎞\n⎠ = s.\nChecking that ϕ : R → R3 → R3, ϕ ts = ϕs t, is a ﬂow is calculational, too:\nϕ t1(ϕ t2 s) =\n⎛\n⎝\ns1 + vt2\ns2\ns3 + cos (s1+vt2)\nv − cos s1\nv\n⎞\n⎠ +\n⎛\n⎝\nvt1\n0\ncos (s1+vt2+vt1)\nv − cos (s1+vt2)\nv\n⎞\n⎠\n=\n⎛\n⎝\ns1\ns2\ns3\n⎞\n⎠ +\n⎛\n⎝\nv(t1 + t2)\n0\ncos (s1+v(t1+t2))\nv − cos s1\nv\n⎞\n⎠\n= ϕ( t1 + t2)s.\nThe condition ϕ 0 s = s has already been checked. ⊓⊔\nIt is well known that not all IVPs admit ﬂows: not all of them have unique solutions, and in\nmany situations, ﬂows exist locally on a subset of R that does not form a submonoid. Peano’s\ntheorem guarantees the local existence of solutions for systems of ODEs whose associated\nvector ﬁeld is continuous. Conditions for local existence and uniqueness are provided by\nthe Picard–Lindelöf theorem [ 22,66], which we brieﬂy discuss, as we use it for our ﬁrst\nworkﬂow.\nBy the fundamental theorem of calculus, any solution to an IVP must satisfy\nXt − X 0 =\n∫\nt\n0\nf (X τ) dτ.\n123\n108 J. J. Huerta y Munive, G. Struth\nFig. 2 V ector ﬁeld and trajectory for a particle in a ﬂuid (Example 8.1)\nIt can be shown that this equation holds if, for X 0 = s, the function\nhxt = s +\n∫ t\n0\nf (x τ) dτ\nhas a ﬁxpoint. This, in turn, is the case if the limit X of the sequence (hn)n∈N,d e ﬁ n e db y\nh0 xt = s and hn+1 = h ◦ hn, exists. Indeed, with this assumption,\nXt = limn→∞\n(\ns +\n∫ t\n0\nf (hn−1 τ)dτ\n)\n= s +\n∫ t\n0\nf (X τ) dτ,\nusing continuity of addition, integration and f in the second step. Finally, existence of the\nlimit of (hn)n∈N is guaranteed by constraining the domain of the hn, and by Banach’s ﬁxpoint\ntheorem, there must be a Lipschitz constant ℓ ≥ 0 such that\n∥ fs 1 − fs 2∥≤ ℓ∥s1 − s2∥,\nfor any s1,s2 ∈ S,w h e r e ∥−∥ is the Euclidean norm on Rn. V ector ﬁelds satisfying this\ncondition are called Lipschitz continuous.\nTheorem 8.2 (Picard–Lindelöf) Let S ⊆ Rn be an open set and f : S → S a Lipschitz\ncontinuous vector ﬁeld. The IVP( f ,s) then has a unique solution X : Ts → S on some open\ninterval Ts ⊆ R.\nThe Picard–Lindelöf theorem makes it possible to patch together intervals Ts to a set\nU = ⋃\ns∈S Ts ×{ s}⊆ R × S, from which a largest interval of existence T = ⋃\ns∈S Ts can\nbe extracted. One can then deﬁne a local ﬂow ϕ : T → S → S such that ϕs t is the maximal\nintegral curve at s. The monoid action identities ϕ 0 = id and ϕ( t1 + t2)s = ϕ t1(ϕ t2 s)\ncan thus be shown for all t2,t1 +t2 ∈ Ts [66], but U need not be closed under addition. The\nPicard–Lindelöf theorem, in the form presented, thus provides sufﬁcient conditions for the\nexistence and uniqueness of local ﬂows for autonomous systems of ODEs. Flows are global\nand hence monoid actions if T is equal to R or its nonnegative or non-positive subset.\n123\nPredicate Transformer Semantics for Hybrid Systems 109\nHybrid systems often deal with dynamical systems where T = Ts = R for any s ∈ S and\nS is isomorphic to Rn for some n ∈ N. Our approach supports local ﬂows with T ⊂ R and\nS ⊂ Rn as well, and even IVPs with multiple solutions beyond the realm of Picard–Lindelöf.\n9 EvolutionCommandsforLipschitzContinuousVectorFields\nSimple hybrid programs of dL [47] are deﬁned by the syntax\nC :: = x := e | x′ = f & G |?P | C;C | C + C | C∗,\nwhich adds evolution commands x ′ = f & G to the program syntax of dynamic logic.\nIntuitively, evolution commands introduce a vector ﬁeld f for an autonomous system of\nODEs and a guard G, which models boundary conditions or similar constraints that restrict\ntemporal evolutions. Guards are also known as evolution domain restrictionsor invariants in\nthe hybrid automata literature [ 10], but henceforth we consistently refer to them as “guards”.\nNondeterministic choice and ﬁnite iteration can be adapted for modelling conditionals and\nwhile loops as with MKA or predicate transformer semantics.\nWe are only interested in the semantics of hybrid programs. Relative to the semantics\nof standard while programs, it thus remains to deﬁne the wlps for evolution commands.\nThis requires relational and state transformer semantics for evolution commands over hybrid\nprogram stores. In this section, we describe our ﬁrst workﬂow that certiﬁes solutions using\nthe Picard–Lindelöf theorem. We thus assume that vector ﬁelds are Lipschitz continuous,\nsuch that the Picard–Lindelöf theorem guarantees at least local ﬂows. This is more general\nthan needed for dynamical systems. A further generalisation to continuous vector ﬁelds is\npresented in the next section in preparation for our second, more powerful workﬂow.\nWe begin with hybrid program stores for d\nL [46]. These are maps s : V → R that assign\nreal numbers to program variables in V . V ariables may appear both in differential equations\nand the discrete control of a hybrid system. One usually assumes that |V |= n for some\nn ∈ N,w h i c hm a k e sRV isomorphic to the vector space Rn. The results from Sect. 8 then\napply to any state space S ⊆ RV .\nNext, we describe a state transformer semantics and a dL-style relational semantics of\nevolution commands with Lipschitz continuous vector ﬁelds. Intuitively, the semantics of\nx′ = f & G in state s ∈ S ⊆ RV is the longest segment of the trajectory ϕ f\ns at s along which\nall points satisfy G.\nFor the remainder of this section, we ﬁx a Lipschitz continuous vector ﬁeld f : S → S\nand a guard G : S → B,f o r S ⊆ RV . We freely consider G, and any other function of that\ntype, as a set or a predicate. As explained in Sect. 8,t h e r ei sa( l o c a l )ﬂ o w ϕ : T → S → S\ndeﬁned on a maximal interval T ⊆ R with 0 ∈ T . Thus, we can pick any interval U ⊆ T\nwith 0 ∈ U to compute wlp s over subintervals of the interval of existence T .I ne x a m p l e s ,\nwe typically use the subinterval [0,t], from the time at which the system dynamics starts to\na maximal time t of interest, or the subinterval R+, the set of nonnegative real numbers.\nFor each t ∈ U,l e t ↓t ={ t′ ∈ U | t′ ≤ t}.T h e G-guarded orbit on U at s ∈ S is then\ndeﬁned as γϕ\nG,U : S → P S by\nγϕ\nG,U s =\n⋃\n{P ϕs ↓t | t ∈ U ∧P ϕs ↓t ⊆ G}.\nIntuitively,γϕ\nG,U s is the orbit at s deﬁned along the longest interval of time in U that satisﬁes\nguard G. This intuition is more apparent in the following lemma.\n123\n110 J. J. Huerta y Munive, G. Struth\nLemma 9.1 Let s ∈ S. Then,\n1. γϕ\nG,U s = ⋃ {γϕ|↓t s | t ∈ U ∧ γϕ|↓t s ⊆ G},\n2. γϕ\nG,U s ={ ϕs t | t ∈ U ∧∀ τ ∈↓ t. G (ϕs τ)}.\nWe have not formalised (1) with Isabelle because reasoning with partial functions may be\ntedious. As a special case, for U = T+, any subinterval of R+,\nγϕ\nG,T+ s ={ ϕs t | t ∈ T+ ∧∀ τ ∈[ 0,t]. G (ϕs τ)}.\nWe can now deﬁne the state transformer semantics of x′ = f & G simply as\n(x′ =F f & G)U = γϕ\nG,U .\nHence, the denotation of an evolution command in state s is the guarded orbit at s in time\ninterval U. Alternatively, in Rel S,\n(x′ =R f & G)U = R (x′ =F f & G)U ={ (s,ϕ ts ) | t ∈ U ∧∀τ ∈↓ t. G (ϕs τ)}\nlike in Sect. 7. Restricting this further to U = R+ yields the standard semantics of\nevolution commands of dL.\nIt remains to derive the wlps for evolution commands. These are the same in Rel S and\nSta S,s ow ed r o p F and R.\nProposition 9.2 Let Q : S → B. Then,\n|(x′ = f & G)U ]Q = λs ∈ S. {s |∀ t ∈ U. P ϕs ↓t ⊆ G → P ϕs ↓t ⊆ Q}.\nBy Lemma 9.1, alternatively,\n|(x′ = f & G)U ]Q = λs ∈ S. {s |∀ t ∈ U.γ ϕ|↓t s ⊆ G → γϕ|↓t s ⊆ Q}.\nFor veriﬁcation condition generation, the following variant is most useful.\nLemma 9.3 Let Q : S → B. Then,\n|(x′ = f & G)U ]Q = λs ∈ S.∀t ∈ U.( ∀τ ∈↓ t. G (ϕs τ)) → Q (ϕs t). (wlp-evl)\nIn particular, for T = R and U = R+,\n|(x′ = f & G)R+]Q = λs ∈ S.∀t ∈ R+.( ∀τ ∈[ 0,t]. G (ϕs τ)) → Q (ϕs t).\nAccordingly, and consistently with dL, Q is no longer a postcondition in the traditional\nsense: by deﬁnition, it is supposed to hold along the trajectory and therefore on any orbit at\nany particular initial condition s guarded by G.\nFor a more categorical view on the wlp of evolution commands, remember from Sect. 6\nthat ⟨(x\n′ = f & G)U |= (γϕ\nG,U )† ,w h e r e(−)† is the Kleisli extension map, and that the wlp\nof (x′ = f & G)U is its right adjoint. It therefore satisﬁes\n123\nPredicate Transformer Semantics for Hybrid Systems 111\n|(x′ = f & G)U ]P =\n⋃\n{Q | (γϕ\nG,U )† Q ⊆ P}={ s | γϕ\nG,U s ⊆ P}.\nThe identity in Proposition 9.2 can then be calculated from there.\nThe wlp laws in Proposition 9.2 and Lemma 9.3 complete the laws for veriﬁcation con-\ndition generation for hybrid programs in the relational and state transformer semantics. In\npractice, Proposition 9.2, Lemma 9.3 and the Picard–Lindelöf theorem support our ﬁrst work-\nﬂow for computing the wlp of an evolution command x′ = f & G on a set U for a Lipschitz\ncontinuous vector ﬁeld:\n1. check that the vector ﬁeld f is indeed Lipschitz continuous and S ⊆ RV open;\n2. supply the (local) ﬂow ϕ for f with U, a subinterval of the interval of existence around\n0;\n3. certify that ϕs is indeed the unique solution for ( f ,s) for any s ∈ S and for U:\n(a) ϕ′\ns = f ◦ϕs on U for any s ∈ S,\n(b) ϕs 0 = s for any s ∈ S,\n(c) U is subset of open set T with 0 ∈ U;\n4. if successful, apply the identity in Proposition 9.2 or Lemma 9.3.\nIn practice, computer algebra tools are helpful for ﬁnding ﬂows. Their integration into proof\nassistants for this purpose is routine and therefore not pursued in this article. The existence\nof unique solutions can be guaranteed uniformly, for instance, for afﬁne or linear systems\nof ordinary differential equations. See [ 26] for the formalisation of such an approach with\nIsabelle.\nThe following classical example illustrates our algebraic approach and gives a ﬁrst glimpse\nof the mathematics involved. It should be noted that we are not embellishing our natural\nsemantical notation with any façade program syntax in this article; see [ 12] for such an\nextension. A formal veriﬁcation with Isabelle can be found in Example 17.1.\nExample 9.4 (Bouncing ball) A ball of mass m is dropped from height h ≥ 0. Its state space\nis s ∈ R\nV for V ={ x,v },w h e r e x denotes its position and v its velocity. Its kinematics is\nspeciﬁed by the vector ﬁeld f : RV → RV with\nf\n( sx\nsv\n)\n=\n( sv\n−g\n)\n,\nwhere g is the acceleration due to gravity and we abbreviate sx = sx and sv = s v.T h e\nball is assumed to bounce back from the ground in an elastic collision. This is modelled\nusing a discrete control, which checks for s\nx = 0 and then ﬂips the velocity. A guard\nG = (λs. sx ≥ 0) precludes any motion below the ground. The system is modelled by the\nhybrid program [ 47]\nCntrl = if (λs. sx = 0) then v := (λs. − sv) else skip,\nBall = (x′ = f & G ;Cntrl)∗,\nwhere skip denotes the program that maps each state to itself (represented by 1 in MKA). Its\ncorrectness speciﬁcation is\nP ≤| Ball]Q for P = (λs. sx = h ∧ sv = 0) and Q = (λs. 0 ≤ sx ≤ h).\n123\n112 J. J. Huerta y Munive, G. Struth\nWe also need the loop invariant\nI =\n(\nλs. 0 ≤ sx ∧ 1\n2 s2\nv = g(h − sx )\n)\n,\nwhich uses a variant of energy conservation with m cancelled out.\nThe ﬁrst step of our veriﬁcation proof shows that P ≤ I and I ≤ Q. The ﬁrst inequality\nholds because 1\n2 02 = 0 = h − h; the second one because 0 ≤ sx appears both in I and\nin Q and because sx ≤ h is guaranteed by g(h − sx ) ≥ 0, which holds as 1\n2 s2\nv ≥ 0. With\ntransitivity and isotonicity of boxes, we can thus bring the correctness speciﬁcation into the\nform I ≤| Ball]I .\nApplying ( wlp-star) then yields the proof obligation I ≤| x\n′ = f & G ;Cntrl]I .T od i s -\ncharge it, we use ( wlp-seq) to calculate the wlps\nJ =| if (λs. sx = 0) then v := (λs. − sv) else skip]I ,\nK =| x′ = f & G]J\nincrementally and ﬁnally show that I ≤ K .\nFor the ﬁrst wlp, we calculate, with ( wlp-cond)a n df o r T = (λs. sx = 0),\nJ = (T →| v := (λs. − sv)]I ) · (T → I )\n=\n(\nT →| v := (λs. − sv)]\n(\nλs. 0 ≤ sx ∧ 1\n2 s2\nv = g(h − sx )\n))\n· (T → I )\n=\n(\nT →\n(\nλs. 0 ≤ sx ∧ 1\n2 (−sv)2 = g(h − sx )\n))\n· (T → I )\n= (T → I ) · (T → I )\n= I .\nFor the second wlp,w ew i s ht oa p p l y( wlp-evl). This requires checking that f is Lipschitz\ncontinuous— ℓ = 1 does the job, supplying a ﬂow and checking that it solves the IVP ( f ,s)\nfor all s ∈ S and satisﬁes the ﬂow conditions for T = R and S = RV . We leave it to the\nreader to verify that ϕ : R → RV → RV deﬁned by\nϕs t =\n( sx\nsv\n)\n+\n( sv\n−g\n)\nt − 1\n2\n( g\n0\n)\nt2\nmeets the requirements in the procedure outlined above, cf. Example 8.1. Then, expanding\ndeﬁnitions and applying ( wlp-evl) from Lemma 9.3,\nKs\n=\n(\n∀t ∈ R+.( ∀τ ∈[ 0,t]. 0 ≤ ϕs τ x) → 0 ≤ ϕs tx ∧ 1\n2 (ϕs t v)2 = g(h − ϕs tx )\n)\n=\n(\n∀t.( ∀τ ∈[ 0,t]. 0 ≤ ϕs τ x) → 1\n2 (ϕs t v)2 = g(h − ϕs tx )\n)\n=\n(\n∀t.\n(\n∀τ ∈[ 0,t]. 0 ≤ sx + svt − 1\n2 gτ2\n)\n→ 1\n2 (sv − gt )2 = g\n(\nh − sx − svt + 1\n2 gt 2\n))\n.\n123\nPredicate Transformer Semantics for Hybrid Systems 113\nFinally, for I ≤ K , suppose 0 ≤ sx , 1\n2 s2\nv = g (h − sx ) and 0 ≤ sx + svτ − 1\n2 gτ2 for all\nτ ∈[ 0,t]. It remains to show that 1\n2 (sv − gt )2 = g\n(\nh − sx − svt + 1\n2 gt 2)\n. Indeed, using\nthe second assumption in the second step,\n1\n2 (sv − gt )2 = 1\n2 s2\nv − g\n(\nsvt + 1\n2 gt 2\n)\n= g(h − sx ) − g\n(\nsvt + 1\n2 gt 2\n)\n= g\n(\nh − sx + svt + 1\n2 gt 2\n)\n.\nThe veriﬁcation with Isabelle described in Example 17.1 is far more automatic than this proof\non paper suggests, and there is ample scope for further automation. As already pointed out,\nthe main purpose of this example is to illustrate our ﬁrst workﬂow and give an impression of\nthe mathematical reasoning involved. ⊓⊔\nCertifying solutions of systems of ODEs can be tedious and hard to automate, and many\nODEs do not admit analytic solutions. It is possible to circumvent these obstacles to practical\nveriﬁcation applications in various ways. One approach, using invariant sets for systems of\nODEs, is pursued by d\nL and described in the following sections. It constitutes the second\nworkﬂow supported by our framework. Another approach aims at particular types of vector\nﬁelds for which (global) ﬂows always exist and are easy to compute. A classical example\nis linear systems of ODEs [ 22,66], for which the ﬁrst author has already developed meth-\nods in a successor article [ 26]. A ﬁnal approach abandons differential equations and vector\nﬁelds altogether and starts from ﬂows—as known from hybrid automata [ 10]. This requires\nchanging the syntax of hybrid programs. The approach is outlined in Sect. 18. It constitutes\nthe third workﬂow supported by our framework.\n10 EvolutionCommandsforContinuousVectorFields\nAs the semantic approach to evolution commands developed in the previous section depends\nmainly on orbits, which are nothing but sets of states, it can be generalised beyond trajectories\nand ﬂows. In this section, we drop the requirement of uniqueness of solutions to IVPs and\nhence assume that vector ﬁelds are merely continuous. In fact, if vector ﬁelds are non-\ncontinuous, the set of solutions deﬁned below will simply be empty. We therefore generalise\nthe deﬁnitions in the previous section to obtain weakest liberal preconditions for evolution\ncommands that do not admit unique solutions, for instance, IVPs of the form x\n′t = k√xt\nwith x 0 = 0f o ra n y k ∈ R [24]. Our second workﬂow using invariant sets is based on this\ngeneralisation.\nConsider the IVP ( f ,s) for continuous vector ﬁeld f : S → S and initial state s ∈ S ⊆\nRV .L e t\nSols fTs ={ X |∀ t ∈ T . X′t = f (Xt ) ∧ X 0 = s}\ndenote its set of solutions on T ⊆ R with 0 ∈ T . Here, T is no longer the maximal interval\nof existence deﬁned by the Picard–Lindelöf theorem; it can be changed like the set U in the\nprevious section. Then, each solution X is still continuously differentiable and thus f ◦ X\nintegrable in T .\n123\n114 J. J. Huerta y Munive, G. Struth\nFor all X ∈ Sols fTs and G : S → B,w ed e ﬁ n et h e G-guarded orbit of X along T in s\nvia the function γ X\nG : S → P S as\nγ X\nG s =\n⋃\n{P X ↓t | t ∈ T ∧ P X ↓t ⊆ G},\nwhich simpliﬁes to γ X\nG s ={ Xt | t ∈ T ∧∀ τ ∈↓ t. G (X τ)}. By Kneser’s theorem [ 36],\nwhen non-uniqueness occurs at some point, inﬁnitely many solutions exist for it. Thus, we\ndeﬁne the G-guarded orbital of f along T in s via the function γ f\nG : S → P S as\nγ f\nG s =\n⋃\n{γ X\nG s | X ∈ Sols fTs }.\nWe thus patch the guarded orbit of each solution to the associated IVP together so that\nγ f\nG s represents all possible evolutions in time that pass through s. This is evident from the\nfollowing result.\nLemma 10.1 Let f : S → S be continuous and G : S → B. Then,\nγ f\nG s ={ Xt | t ∈ T ∧P X ↓t ⊆ G ∧ X ∈ Sols fTs }.\nIf G =⊤ , the constantly true predicate on S or the set S itself, we simply write γ f instead\nof γ f\n⊤ .\nThe state transformer semantics of the evolution command for a continuous vector ﬁeld\nf can then be deﬁned as\n(x′ =F f & G) = γ f\nG .\nThe corresponding relational semantics is\n(x′ =R f & G) ={ (s, Xt ) | t ∈ T ∧∀τ ∈↓ t. G (X τ) ∧ X ∈ Sols fTs }.\nOnce again, ⟨x′ = f & G|= (γ f\nG )† . This leads to a wlp for evolution commands.\nProposition 10.2 Let S ⊆ RV and T ⊆ R.L e t f : S → S be a continuous vector ﬁeld and\nG, Q : S → B. Then,\n|x′ = f & G]Q = λs ∈ S. {s |∀ X ∈ Sols fTs .∀t ∈ T . P X ↓t ⊆ G → P X ↓t ⊆ Q}.\nThis identity can be rewritten, for predicates, as\n|x′ = f & G]Q = λs ∈ S.∀X ∈ Sols fTs .∀t ∈ T .( ∀τ ∈↓ t. G (X τ)) → Q (Xt ).\nWhether this fact is useful for veriﬁcation applications, as outlined above, remains to be\nseen. Yet the next section shows that it is certainly useful for reasoning with invariant sets.\nThe following corollary is important for veriﬁcation proofs with invariants as well.\nCorollary 10.3 Let f : S → S, S ⊆ R\nV , be a continuous vector ﬁeld, T ⊆ R and G , Q :\nS → B. Then,\n|x′ = f & G]Q =| x′ = f & G](G · Q).\n123\nPredicate Transformer Semantics for Hybrid Systems 115\n11 InvariantsforEvolutionCommands\nIn dL, differential invariants are predicates I that satisfy I ≤| x′ = f & G]I [46]. In the\nterminology of Sect. 4, they are simply invariants for evolution commands. They play a\ncrucial role in dL and KeYmaera X because of the limited support for solving ODEs and\ntheir greater generality.\nIn dynamical systems theory, when all guards are ⊤ and global ﬂows exist, and in\n(semi)group theory, invariant sets for actions or ﬂows ϕ : T → S → S are sets I ⊆ S\nsatisfying γϕ s ⊆ I for all s ∈ I [66]. Based on the results from Sect. 10, we generalise both\nnotions uniformly.\nA predicate or set I : S → B is an invariant of the continuous vector ﬁeld f : S → S\nand guard G : S → B along T ⊆ R if\n(γ f\nG )† I ⊆ I .\nNote that the parameter T is hidden in the deﬁnition of γ f\nG .F o r G =⊤ ,w h e n (γ f )† I ⊆ I ,\nwe call I simply an invariant of f along T .\nThe following proposition yields a structural insight in the relationship between invariant\nsets of dynamical systems and differential invariants of dL in terms of an adjunction.\nProposition 11.1 Let f : S → S be continuous, G : S → B and T ⊆ R. Then, the following\nare equivalent.\n1. I is an invariant for f and G along T;\n2. ⟨x′ = f & G|I ⊆ I;\n3. I ⊆| x′ = f & G]I.\nProof\n(γ f\nG )† I ⊆ I ↔⟨ x′ = f & G|I ⊆ I ↔ I ⊆| x′ = f & G]I .\nThe ﬁrst step uses the deﬁnition of backward diamonds as Kleisli extensions in Sect. 6 and\nthat of the semantics of evolution commands in Sect. 10. The ﬁnal step uses the adjunction\nbetween boxes and diamonds from Sect. 4. ⊓⊔\nFor our wlp-calculus, condition (3) is of course most useful. Yet instead of checking that a ﬂow\nis a solution to a vector ﬁeld, as previously, we now need to check whether a predicate is an\ninvariant—without having to solve the system of ODEs. This may in some case be a condicio\nsine qua non and in others a considerable simpliﬁcation of reasoning. The following lemmas\nlead to our second workﬂow. We show some proofs although they have been formalised with\nIsabelle, as they explain why the approach works.\nFirst, towards Corollary 11.4, we may ignore guards when checking for invariants and we\ncan use a simple second-order formula.\nLemma 11.2 Let f : S → S be continuous and I : S → B. Then,\n1. I ⊆| x\n′ = f & ⊤] I → I ⊆| x′ = f & G]I,\n2. I ⊆| x′ = f & ⊤] I ↔ (Is →∀ X ∈ Sols fTs .∀t ∈ T . I (Xt )).\nProof For (1), γ f\nG ⊆ γ f for all G and hence ⟨x′ = f & G|I ⊆⟨ x′ = f &⊤| I ⊆ I .T h e\nproof of (2) is a simple calculation . ⊓⊔\nSecond, we can recurse over predicates as follows.\n123\n116 J. J. Huerta y Munive, G. Struth\nLemma 11.3 Let f : S → S be a continuous vector ﬁeld, μ,ν : S → R differentiable and\nT ⊆ R with 0 ∈ T.\n1. If (μ ◦ X)′ = (ν ◦ X)′ for all X such that X ′t = ft (Xt ) and G (Xt ) when t ∈ T,t h e n\nμ = ν is an invariant for f along T ,\n2. if (μ ◦ X)′τ ≤ (ν ◦ X)′τ when τ> 0, and (μ ◦ X)′τ ≥ (ν ◦ X)′τ when τ< 0, for all\nX such that X ′t = ft (Xt ) and G (Xt ), then both μ<ν and μ ≤ ν are invariants for\nf along T ,\n3. if μ<ν and ν<μ are invariants for f along T , then μ ̸= ν is too (and conversely if0\nis the least element in T ),\n4. μ ̸≤ ν is an invariant for f along T if and only if ν<μ is too.\nProof We only show the proof of (1), as it reveals the main idea of the procedure outlined\nbelow. By deﬁnition, μ = ν is an invariant for f along T if and only if μs = ν s implies\nμ( Xt ) = ν( Xt ) for all X ∈ Sols fTs . It is a well-known consequence of the mean\nvalue theorem that two continuously differentiable functions are the same if and only if they\nintersect at some point and have the same derivative. Hence, (μ◦X)\n′ = (ν◦X)′and μs = ν s\nimply μ( Xt ) = ν( Xt ) for all X ∈ Sols fTs . ⊓⊔\nProposition 10.3, the properties in this section—in particular Lemma 11.3—and\nLemma 4.1 about invariants that are conjunctions or disjunctions support our second work-\nﬂow for proving a correctness speciﬁcation P ≤| x′ = f & G]Q.\n1. Check whether a candidate predicate I is a differential invariant:\n(a) transform I into negation normal form;\n(b) if I is complex, reduce it with Lemma 4.1, and Proposition 11.3(3) and (4);\n(c) if I is atomic, apply Proposition 11.3(1) and (2);\n(if successful, I ≤| x′ = f & G]I holds by Proposition 11.1(3) and Lemma 11.2);\n2. if successful, prove P ≤ I and |x′ = f & G](G · I ) ≤| x′ = f & G]Q.\nFor G =⊤ and Lipschitz continuous vector ﬁelds, the notions of invariant can be strength-\nened.\nCorollary 11.4 Let f : S → S be Lipschitz continuous. Then, the following are equivalent.\n1. I is an invariant for f along T ;\n2. ⟨x′ = f & ⊤| I = I;\n3. I =| x′ = f & ⊤] I.\nThe identities (2) and (3) hold because 0 ∈ T .\nNext, we revisit the bouncing ball example from Sect. 9 to illustrate our second work\nﬂow that reasons with differential invariants. Once again, we give detailed mathematical\ncalculations to indicate the kind of mathematical reasoning involved. A veriﬁcation with\nIsabelle, which is much more automatic, can be found in Example 17.2.\nExample 11.5 (Bouncing ball with differential invariant)We can avoid solving the system of\nODEs in Example 9.4 using a differential invariant to show that\nI ≤| x\n′ = f & G]I\nfor the loop invariant I and vector ﬁeld f (sx ,sv)T = (sv,−g)T . The most natural candidate\nfor a differential invariant is of course energy conservation. Cancelling the mass, we use\nId =\n(\nλs. 1\n2 s2\nv = g(h − sx )\n)\n.\n123\nPredicate Transformer Semantics for Hybrid Systems 117\nWe now apply our procedure for reasoning with differential invariants.\n1. We use Proposition 11.3 with μs = 1\n2 s2\nv and ν s = g(h − sx ) to check that Id is indeed\nan invariant. We thus need to show that (μ◦X)′ = (ν ◦X)′ for all X ∈ Sols fTs ,w h i c h\nunfolds to\n( 1\n2 (Xt v)2\n) ′\n= g(h − Xtx )′,\nbecause s = Xt and therefore sv = Xt v and sx = Xtx . And indeed,\n( 1\n2 (Xt v)2\n) ′\n= (Xt v)(X′t v) = (Xt v)( f (Xt )v) =− (Xt v)g\n=− g( f (Xt ) x) =− g(X′tx ) = (g(h − Xtx ))′.\nBy Proposition 11.3(1), Id is thus an invariant for f along RV . Proposition 11.1(3) and\nLemma 11.2 then imply that\nId ≤| x′ = f & G]Id .\n2. It remains to show that I ≤ Id and |x′ = f & G]Id ≤| x′ = f & G]I .\n– The ﬁrst inequality is trivial.\n– For the second one, we calculate\n(G · Id )s =\n(\n0 ≤ sx ∧ 1\n2 s2\nv = g(h − sx )\n)\n= Is .\nBy Corollary 10.3, therefore,\n|x′ = f & G]Id =| x′ = f & G](G · Id ) =| x′ = f & G]I .\nThis shows that I ≤| x′ = f & G]I . The remaining proof of P ≤| Ball]Q is the same as in\nExample 9.4. ⊓⊔\nThis example shows that one can reason about invariants of evolution commands in a\nnatural mathematical style as it can be found in textbooks on differential equations [ 4,22,\n66]. By contrast, dL relies on syntactic substitution-based reasoning in the term algebra of\ndifferential rings [ 46] to check invariants, and complex domain-speciﬁc inference rules to\nmanipulate them. The following section shows that we can derive semantic variants of most\nof the d\nL inference rules for those who like this style of reasoning, see [ 12] for a complete\nlist.\nNext, we brieﬂy specialise our approach to dL-invariants, the invariants sets used in\ndynamical systems theory and those in (semi)group theory. We assume a setting where\nglobal ﬂows exist and indices U can be dropped.\nCorollary 11.6 Let f : S → S be Lipschitz continuous. Then, I : S → B is a d\nL-invariant\nfor x′ = f & ⊤ if and only if I is an invariant set for ϕ f .\nProof It is easy to check that (∀s ∈ I . Is → γϕ s ⊆ I ) ↔ (γϕ)† I ⊆ I . The claim then\nfollows from Proposition 11.1. In the Lipschitz continuous case, of course, Sols fTs ={ ϕ f }.\n⊓⊔\nIt remains to point out that the difference between the deﬁnition of invariant sets for\ndynamical systems and that for (semi)group actions is merely notational: In group theory,\n123\n118 J. J. Huerta y Munive, G. Struth\nan invariant set I of a (semi)group action ϕ : T → S → S satisﬁes T · I ⊆ I ,w h e r e\nT · I ={ ϕ ts | t ∈ T ∧ s ∈ I }. In the presence of a unit, therefore T · I = I . Yet of course\n(γϕ)† I ={ ϕ ts | t ∈ T ∧ s ∈ I } as well.\nAt the end of this section, we summarise the two main workﬂows presented. Both use the\nstandard laws for predicate transformer algebras for automating veriﬁcation condition gen-\neration with respect to the structural part of hybrid programs. For straight-line programs, this\nrequires only equational reasoning and can be dealt with by Isabelle’s simpliﬁers. The remain-\ning veriﬁcation conditions for basic commands—evolution and assignment commands—are\ngenerated by equational reasoning in the concrete semantics of the hybrid program store. In\nfact, only this concrete semantics had to be added to a standard Isabelle veriﬁcation compo-\nnent to make our veriﬁcation components work.\nThe veriﬁcation conditions generated are then at the level of reasoning with functions over\nR\nn, and in some cases in linear algebra [ 26]. At this level, by contrast with dL, we do not\nrequire any domain-speciﬁc inference rules and can rely on Isabelle’s support for semantic\nreason about the hybrid dynamics within its higher-order logic, an approach that has allowed\nus to verify a large number of benchmark examples [ 45]. Yet our approach is versatile enough\nto derive inference rules in the style of d\nL, as the following section shows.\n12 DerivationofdL InferenceRules\nAs a proof of concept, we derive semantic variants of some axioms and inference rules of\ndL, thus proving their soundness with respect to our semantics. The ﬁrst one introduces\nsolutions of IVPs with constant vector ﬁelds [ 6]. It is a trivial instance of Proposition 9.2\nwith f = λs. c for some c ∈ R. Such vector ﬁelds are Lipschitz continuous; their ﬂows are\nϕ ts = s + ct. Hence,\n|x′ = (λs. c) & G]Q = λs ∈ S. ∀t ∈ T .( ∀τ ≤ t. G (s + cτ)) → Q (s + ct). (DS)\nFor a second dL inference rule, we simply rewrite the wlp in Proposition 9.2 as a Hoare-style\ninference rule.\nLemma 12.1 Let S ⊆ RV and T = R.L e tϕ : T → S → S be the ﬂow for the Lipschitz\ncontinuous vector ﬁeld f : S → S, and G , Q : S → B. Then,\n∀s ∈ S. Ps → (∀t ∈ T .( ∀τ ≤ t. G(ϕs τ)) → Q (ϕs t))\nP ≤| x′ = f & G]Q (dSolve)\nTo apply this rule in our setting, the procedure in Sect. 9 must be followed.\nNext, we derive ﬁve semantic counterparts of the dL axioms and inference rules for\ndifferential invariants in the setting of Sect. 11.T h e differential cut axiom ( DC)a n dr u l e\n(dC), differential weakening,( DW)a n d( dW), and the differential induction rule ( dI). These\nrules are typically applied backwards as follows: dC introduces an invariant. Its left premise is\ndischarged via dI, Proposition 11.1 and logical reasoning, while its right premise is discharged\nvia dW. Note that the conclusions of all these rules are semantically equivalent to Hoare\ntriples. V eriﬁcation examples using these rules and the dL approach can be found in our\nIsabelle components.\nLemma 12.2 Let P , G, I , Q : S → B,T ⊆ R and f : S → S be a continuous vector ﬁeld.\nThen, with ηS the unit of the powerset monad,\n|x′ = f & G]I = ηS →| x′ = f & (λs. Gs ∧ Is )]Q =| x′ = f & G]Q, (DC)\n123\nPredicate Transformer Semantics for Hybrid Systems 119\nP ≤| x′ = f & G]IP ≤| x′ = f & (λs. Gs ∧ Is )]Q\nP ≤| x′ = f & G]Q (dC)\n|x′ = f & G](λs. Gs → Qs ) =| x′ = f & G]Q, (DW)\nG ≤ Q\nP ≤| x′ = f & G]Q (dW)\nFinally, if I is a differential invariant for f along T , then\nP ≤ II ≤ Q\nP ≤| x′ = f & G]Q (dI)\nAxiom (DC)a n dr u l e(dC) introduce differential invariants in guards of evolution commands.\nAxiom and rule ( DW)a n d( dW) summarise the fact that if a guard is strong enough to imply\na postcondition, then no invariant or solution needs to be found. Finally, the differential\ninduction rule follows from Proposition 11.1(3), transitivity and isotonicity of boxes.\nA differential ghost rule [ 51] (dG) and sometimes a differential effect axiom [ 48]h a v e\nalso been proposed for reasoning with invariants in d\nL. Our semantics approach has so far\nno need for these [ 45]—we do not anticipate any reason why we should not be able to freely\nintroduce ghost variables for the continuous dynamics as we have so far done for the discrete\none using Isabelle’s higher-order logic—but see [ 12] for a derivation of (dG) within our\nsemantic framework.\n13 IsabelleComponentsforMKAandPredicateTransformers\nThe entire mathematical development of MKA in Sects. 2–4 has been formalised with Isabelle\n[3,16]. V eriﬁcation components for Isabelle and the relational store model in Sect. 7 have been\ndeveloped, too [ 17,18], using the shallow embedding approach discussed in Sects. 1 and 7.\nPredicate transformers à la Back and von Wright have been formalised previously in Isabelle\nby Preoteasa [ 52,53]. Our alternative formalisation emphasises the quantalic structure of\ntransformers [64,65], as in Sect. 5, and we have added a third component based on quantaloids\n[65]. It is based on a formalisation of the powerset monad [ 65], as outlined in Sect. 6.O u r\nformalisation is compositional in that all three approaches to predicate transformers can be\ncombined with relational and state transformer semantics and different models of the (hybrid)\nprogram store, as shown in Fig. 1.\nThis section summarises the Isabelle components for predicate transformers and the ver-\niﬁcation component based on MKA. More detailed information can be found in the proof\ndocuments for these components [ 18,65].\nThe MKA component is integrated into the Kleene algebra hierarchy that formalises vari-\nants of Kleene algebras [ 3] and modal Kleene algebras [ 16], as outlined in Sects. 2 and 3.\nIn these mathematical components, algebras are formalised as type classes, their models\nvia instantiation and interpretation statements. For Kleene algebras, many computationally\ninteresting models have been formalised; for MKA, only the relational model is present in the\nArchive of Formal Proofs. The state transformer model has been formalised for quantales in\na different component [ 65].\nInstantiation and interpretation statements have several purposes in Isabelle. They make\nalgebraic facts available in all models, establish soundness of algebraic hierarchies and ulti-\nmately make the axiomatic approaches consistent with respect to Isabelle’s small trustworthy\ncore. Finally, they unify developments of multiple concrete semantics.\n123\n120 J. J. Huerta y Munive, G. Struth\nIn our MKA-based veriﬁcation components [ 18], program syntax is absent and semantic\nillusions of program syntax are provided in the concrete program semantics, as outlined\nin Sect. 7. Consequently, veriﬁcation conditions for the control structure of programs are\ngenerated within the algebra; those for assignments in the concrete store semantics. We\ncurrently model stores simply as functions from strings representing variables to values of\narbitrary type. Expressions are simulated by functions from stores to values, as outlined in\nSect. 7; stores with poly-typed values are modelled via sum-types. An extension to veriﬁcation\ncomponents for hybrid programs is described in the following sections.\nA second component is based on predicate transformers à la Back and von Wright [ 5],\nfor which we have built special purpose components with advanced features for orderings\nand lattices [ 63] and for quantales [ 64]. These structures are once again formalised as type\nclasses. Predicate transformers, however, are modelled as global functions that may have\ndifferent source and target types. Isabelle’s simple type system can infer most general types\nfor deﬁnitions. These can be associated with predicate transformers by sort constraints; def-\ninitions can often be declared in the point-free style of functional programming. This makes\nthe formalisation of quantaloids of transformers with partial compositions straightforward.\nMono-typed transformer algebras are obtained from these via subtyping. They are linked\nwith quantales and Kleene algebras by interpretation or instantiation.\nIsabelle’s type system is too weak for a deep embedding of general categorical concepts,\nbut formalising instances such as the powerset monad, its Kleisli category and Eilenberg–\nMoore algebras is straightforward. We have formalised the isomorphisms and dualities\nbetween relations, state transformers and the four predicate transformers corresponding to\nbackward and forward boxes and diamonds in this setting. Using these dualities to transport\ntheorems automatically requires Isabelle’s transfer package, which is ongoing work.\nWe have created a second veriﬁcation component for hybrid systems based on Back\nand von Wright’s approach, using the monadic transformers to obtain a concrete semantics.\nFinally, we have once again restricted the categorical approach to the mono-typed case\nin a third component. Via subtyping, we can then show that the categorical transformers\nform quantales, and more speciﬁcally MKAs. Everything Isabelle knows about MKA is then\navailable in this instance.\n14 IsabelleComponentsforODEsandOrbits\nThis section and the two following ones describe the formalisation of the material in Sects. 8–\n12 in Isabelle, from mathematical components for ODEs and orbits to veriﬁcation components\nfor hybrid programs based on (local) ﬂows, differential invariants and dL-style inference\nrules.\nWe begin with summarising Immler and Hölzl’s formalisation of the Picard–Lindelöf\ntheorem based on the Isabelle hierarchy for analysis and ordinary differential equations [ 23,\n29–31]. We have adapted their results to show that unique solutions to IVPs for autonomous\nsystems of ODEs guaranteed by this theorem satisfy the local ﬂow conditions, as discussed\nin previous sections.\nHölzl and Immler have proved the Picard–Lindelöf theorem for time-dependent vector\nﬁelds of type real ⇒(\n′a::{heine -borel ,banach }) ⇒ ′a [30]. They have called their theorem\nunique-solution and have formalised it within a locale called unique-on-bounded-closed to\nbundle the assumptions for the local existence of unique solutions within a closed interval in\nR. They have specialised and hence extended this locale in various ways.\nOur approach builds on top of their extension ll-on-open-it that bundles more or less the\nconditions of Theorem 8.2, but for the time-dependent case. In our formalisation, we add the\n123\nPredicate Transformer Semantics for Hybrid Systems 121\ncondition t0 ∈ T to have this parameter available in the following developments. Thus, we\nhave generated the following variant.\nlocale picard-lindeloef =\nﬁxes f ::real ⇒ (′a::{heine-borel,banach}) ⇒ ′a\nand T::real set\nand S::′as e t\nand t0::real\nassumes open-domain: open T open S\nand interval-time: is-interval T\nand init-time: t0 ∈ T\nand cont-vec-ﬁeld:∀ s ∈ S. continuous-on T (λt. fts )\nand lipschitz-vec-ﬁeld: local-lipschitz T S f\nbegin\nsublocale ll-on-open-it T f S t0\n⟨proof⟩\nlemma unique-solution:\nassumes xivp: DX = (λt. ft (Xt )) on {t0−−t} Xt 0 = sX ∈{ t0−−t}→ S\nand t ∈ T\nand yivp: DY = (λt. ft (Yt )) on {t0−−t} Yt 0 = sY ∈{ t0−−t}→ S\nand s ∈ S\nshows Xt = Yt\n⟨proof⟩\nend\nThe locale declaration lists the assumptions of the Picard–Lindelöf theorem: the vector ﬁeld\nf —which is still time-dependent—is deﬁned on an open time interval T that contains the\ninitial time t0, and an open subset S of the state space. The vector ﬁeld f is continuous in time\nand, for each (t,s) ∈ T × S, Lipschitz continuous on a closed subset of T × S around (t,s).\nThe sublocale statement shows that these assumptions imply those of the locale ll-on-open-it.\nLemma unique-solution ensures that the Picard–Lindelöf theorem is derivable within this\nlocale. The notation DX stands for X′,a n d g ∈ A → B indicates that function g maps\nfrom the set A into the set B, as opposed to the type of g, which can be larger. The notation\n{t0−−t} indicates the set of real numbers between t0 and t (including both), where t may\nbe above or below t0. The formalisation of the Picard–Lindelöf theorem comprises a formal\ndeﬁnition of solutions to IVPs of system of ODEs in Isabelle. As an abbreviation, we have\ndeﬁned the set Sols fTs of Sect. 10 with the additional requirement that X ∈ T → S.\ndeﬁnition ivp-sols :: (real ⇒ ′a ⇒ (′a :: real-normed-vector)) ⇒ real set ⇒ ′as e t⇒\nreal ⇒ ′a ⇒ (real ⇒ ′a) set (Sols)\nwhere Sols f T S t0 s ={ X |X.( DX = (λt. ft (Xt )) on T) ∧ Xt 0 = s ∧ X ∈ T → S}\nWe restrict locale picard-lindeloef to autonomous systems and to t0 = 0, while introducing\nthe variable ϕ for the local ﬂow of the vector ﬁeld. In support of our open approach to hybrid\nprogram veriﬁcation, this allows users to supply any characterisation of the ﬂow that suits\nthem best, as a successor paper illustrates [ 26].\nlocale local-ﬂow = picard-lindeloef (λ t. f ) TS0\nfor f ::′a::{heine-borel,banach}⇒ ′a\nand TSL +\nﬁxes ϕ :: real ⇒ ′a ⇒ ′a\nassumes ivp:⋀ ts . t ∈ T /equal1⇒s ∈ S /equal1⇒D (λt.ϕ ts ) = (λt. f (ϕ ts )) on {0−−t}⋀ s. s ∈ S /equal1⇒ϕ 0s = s⋀ ts . t ∈ T /equal1⇒s ∈ S /equal1⇒(λt.ϕ ts ) ∈{ 0−−t}→ S\n123\n122 J. J. Huerta y Munive, G. Struth\nThe assumptions ivp force T to coincide with its largest subinterval ( ex-ivl) where solutions\nexist (lemma ex-ivl-eq below). Thus, ϕ is the unique solution on the whole of T —and not\nonly on its subsets {0−−t} unlike picard-lindeloef or ll-on-open-it. This allows users of the\nlocale to choose T as small as they wish.\nlemma ex-ivl-eq: s ∈ S /equal1⇒ex-ivl s = T\n⟨proof⟩\nlemma has-vderiv-on-domain: s ∈ S /equal1⇒D (λt.ϕ ts ) = (λt. f (ϕ ts )) on T\n⟨proof⟩\nlemma in-ivp-sols: s ∈ S /equal1⇒(λt.ϕ ts ) ∈ Sols (λt. f ) TS0s\n⟨proof⟩\nlemma eq-solution: X ∈ Sols (λt. f ) TS0s /equal1⇒t ∈ T /equal1⇒s ∈ S /equal1⇒Xt = ϕ ts\n⟨proof⟩\nFinally, in this locale we can prove that if the maximal interval of existence T equals R,t h e n\nthe ﬂow ϕ is global and hence a proper monoid action.\nlemma ivp-sols-collapse: T = UNIV /equal1⇒s ∈ S /equal1⇒Sols (λt. f ) TS0s ={ (λt.ϕ ts )}\n⟨proof⟩\nlemma is-monoid-action:\nassumes s ∈ S\nand T = UNIV\nshows ϕ 0s = s\nand ϕ( t1 + t2) s = ϕ t1 (ϕ t2 s)\n⟨proof⟩\nWe have not generated a locale for this case, as the assumptions needed to remain unchanged.\nLocale picard-lindeloef thus guarantees the existence of unique solutions for IVPs of time-\ndependent systems. Locale local-ﬂow specialises it to autonomous systems with Lipschitz\ncontinuous vector ﬁelds and local ﬂows. It covers dynamical systems with global ﬂows\nand thus the veriﬁcation of hybrid systems. This provides the basic Isabelle infrastructure\nfor formalising the concrete semantics for hybrid systems with Lipschitz continuous vector\nﬁelds from Fig. 1.\nNext, we describe our formalisation of the orbits and orbitals from Sect. 10. These form\nthe basis for our veriﬁcation components for continuous vector ﬁelds beyond the scope of the\nPicard–Lindelöf theorem, as shown in Fig. 1. Yet we can instantiate all concepts to settings\nwhere (local) ﬂows exist. First, we have formalised the G-guarded orbit γ\nX\nG of X along T ,\nwith down T t standing for ↓t.\ndeﬁnition g-orbit :: (real ⇒ ′a) ⇒ (′a ⇒ bool) ⇒ real set ⇒ ′as e t(γ )\nwhere γ XGT = ⋃ {P X (down T t) |t. P X (down T t) ⊆{ s. Gs }}\nlemma g-orbit-eq: γ XGT ={ Xt |t. t ∈ T ∧ (∀τ∈down T t. G (X τ))}\n⟨proof⟩\nWe have also formalised the G-guarded orbital of f along T in s (as γ f\nG s) together with\nLemma 10.1.\ndeﬁnition g-orbital :: (′a ⇒ ′a) ⇒ (′a ⇒ bool) ⇒ real set ⇒ ′as e t⇒ real ⇒\n(′a::real-normed-vector) ⇒ ′as e t\nwhere g-orbital f G T S t0 s = ⋃ {γ XGT |X. X ∈ Sols (λt. f ) TSt 0 s}\n123\nPredicate Transformer Semantics for Hybrid Systems 123\nlemma g-orbital-eq: g-orbital f G T S t0 s =\n{Xt |tX . t ∈ T ∧ P X (down T t) ⊆{ s. Gs }∧ X ∈ Sols (λt. f ) TSt 0 s }\n⟨proof⟩\nWe have shown that their counterparts from dynamical systems are special cases by instanti-\nating our deﬁnitions to the parameters of the locale local-ﬂow. Hence, the ⊤ -guarded orbital\nof f along T in s becomes the standard orbit of s, and its G-guarded version is the set in\nLemma 9.1.\ncontext local-ﬂow\nbegin\ndeﬁnition orbit :: ′a ⇒ ′as e t(γϕ)\nwhere γϕ s = g-orbital f (λs. True) TS0s\nlemma orbit-eq[simp]: s ∈ S /equal1⇒γϕ s ={ ϕ ts |t. t ∈ T}\n⟨proof⟩\nlemma g-orbital-collapses:\ns ∈ S /equal1⇒g-orbital f G T S 0 s ={ ϕ ts |t. t ∈ T ∧ (∀τ∈down T t. G (ϕ τ s))}\n⟨proof⟩\nend\nOverall, the set-theoretic concepts introduced in Sect. 10 are easily deﬁnable in Isabelle.\nSimilarly, lemmas formalising their properties and relating them are often proved automati-\ncally in one or two lines. Analytical properties like the existence of derivatives in a region of\nspace or the uniqueness of solutions for IVPs are harder to prove. Such lemmas often require\nlong structured proofs with proofs by cases and explicit calculations, that is, a considerable\namount of user interaction. Yet most proofs remain at least roughly at the level of textbook\nreasoning.\n15 IsabelleComponentsforHybridPrograms\nThis section describes the integration of the state transformer and relational semantics for\ndynamical systems and Lipschitz-continuous vector ﬁelds from Sect. 9 and the continuous\nvector ﬁelds from Sect. 10 into the three veriﬁcation components for predicate transformers\noutlined in Sect. 13 and Fig. 1. This requires formalising hybrid stores and the semantics of\nevolution commands for dynamical systems, Lipschitz continuous vector ﬁelds with local\nﬂows and continuous vector ﬁelds. As explained in Sect. 9 and 11, this supports two different\nworkﬂows using the procedures introduced in these sections: the ﬁrst one is for reasoning\nwith (local) ﬂows and orbits, the second, more general one, for reasoning with invariants.\nFirst, we explain our formalisation of the hybrid store type R\nV . We use Isabelle’s type\n(real,′n) vec (abbreviated as realˆ′n) of real valued vectors of dimension n, formalised as the\ntype ′n ⇒real of functions from the ﬁnite type ′n into R. This represents hybrid stores in RV\nwith |V |= n. Isabelle uses the notation s$i for the ith coordinate of a vector s and hence the\nvalue of store s at variable i. More mathematically, $ is the bijection from realˆ′n to ′n ⇒real.\nIts inverse is written using a binder χ that replaces λ-abstraction. Thus, (χi. s)$i = s for\nany s::realˆ′n and (χi. x)$i = x for any x::real. As a consequence of this simple approach,\nvariables are formalised as natural numbers. More general namespaces have been included\nin our framework more recently [ 11,12] to make it more user friendly.\n123\n124 J. J. Huerta y Munive, G. Struth\nOur state transformer semantics uses functions of type realˆ′n ⇒ (realˆ′n) set,w h i c hw e\nabbreviate as (realˆ′n) nd-fun (for non-deterministic functions). These are instances of the\nmore general type ′an d-fun of nondeterministic endofunctions.\nAlternatively, we use relations of type (realˆ′n) rel, which are instances of ′ar e l. For both\nintermediate semantics, we have shown with Isabelle that they form MKAs, but we have also\nintegrated them into the two quantalic predicate transformer semantics in Fig. 1.\ninterpretation rel-aka: antidomain-kleene-algebra Id {} (∪)( ;)( ⊆)( ⊂) rtrancl rel-ad\n⟨proof⟩\ninstantiation nd-fun :: (type) antidomain-kleene-algebra\n⟨proof⟩\nAfter these proofs, all statements proved in Isabelle’s MKA components are available for state\ntransformers and relations. We have formalised wlps for both models, where ⌈−⌉ ambigu-\nously denotes the isomorphism between predicates and binary relations or nondeterministic\nfunctions.\nlemma wp-rel: wp R ⌈P⌉=⌈ λ x. ∀ y.( x,y) ∈ R −→Py ⌉\n⟨proof⟩\nlemma wp-nd-fun: wp F ⌈P⌉=⌈ λ x. ∀ y. y ∈ (Fx ) −→Py ⌉\n⟨proof⟩\nAlternatively, we use the categorical forward box operator fbF for Kleisli arrows of type\nF::′a ⇒ ′bs e tdescribed in Sect. 6,\nlemma ffb-eq: fbF FX ={ x. ∀y. y ∈ Fx −→y ∈ X}\n⟨proof⟩\nor its relational counterpart fbR.\nWe now switch to the categorical approach to predicate transformers based on state trans-\nformers and the Kleisli monad of the powerset functor, as a preliminary MKA-based one with\nrelations has already been described elsewhere [ 28]. Apart from typing and some minor syn-\ntactic differences, the other approaches—predicate transformers based on MKA and quantales,\nand an intermediate relational semantics for these—yield analogous results and are equally\nsuitable for veriﬁcation. This evidences the compositionality of our approach.\nThe state and predicate transformer semantics of assignment commands is based on store\nupdate functions, as described in Sect. 7. For hybrid programs, it must be adapted to type\n′aˆ′n.\ndeﬁnition vec-upd :: ′aˆ′n ⇒ ′n ⇒ ′a ⇒ ′aˆ′n\nwhere vec-upd s i a = (χ j. ((($) s)(i := a)) j)\ndeﬁnition assign :: ′n ⇒ (′aˆ′n ⇒ ′a) ⇒ ′aˆ′n ⇒ (′aˆ′n) set ((2- ::= -) [70, 65] 61)\nwhere (x ::= e) = (λs. {vec-upd s x (es )})\nlemma ffb-assign[simp]: fbF (x ::= e) Q ={ s.( χ j. ((($) s)(x := (es ))) j) ∈ Q}\n⟨proof⟩\nThe ($) applies the bijection $ as a function in preﬁx notation.\nWe write (x ::= e) for the semantic illusion for a syntactic assignment commands, as\nIsabelle uses f (i := a) for function update f [i ↦→ a]. Lemma ffb-assign is then a direct\nconsequence of ffb-eq, and it coincides with ( wlp-asgn) in Sect. 7 up to minor syntactic\n123\nPredicate Transformer Semantics for Hybrid Systems 125\ndifferences. In the veriﬁcation examples that feature in this article, we have not attempted to\nhide the functions that impersonate syntactic expressions and the lambda abstractions they\nrequire. This may be unwieldy for users. It is nevertheless routine to program more elegant\nnotation with Isabelle [ 12].\nSimilarly, wlps for the control structure commands of hybrid programs (Eqs. wlp-seq,\nwlp-cond, wlp-star) are easily derivable.\nlemma ffb-kcomp[simp]: fbF (G ; F) P = fbF G (fbF FP )\n⟨proof⟩\nlemma ffb-if-then-else[simp]: fbF (IF T THEN X ELSE Y) Q =\n{s. Ts −→s ∈ fbF XQ }∩{ s. ¬ Ts −→s ∈ fbF YQ }\n⟨proof⟩\nlemma ffb-loopI: P ≤{ s. Is }/equal1 ⇒ {s. Is }≤ Q /equal1⇒ {s. Is }≤ fbF F {s. Is }/equal1 ⇒\nP ≤ fbF (LOOP F INV I) Q\n⟨proof⟩\nIn these lemmas, ;is syntactic sugar for the forward Kleisli composition ◦K and LOOP stands\nfor the Kleene star for state transformers with its annotated loop-invariant after the keyword\nINV, along the lines of Sect. 4.\nAs in Sect. 10, the general semantics of evolution commands for continuous vector ﬁelds\nis given by G-guarded orbitals of f along T . We have formalised the wlps in Proposition 10.2,\nand a specialisation to local ﬂows in the context of our locale local-ﬂow g i v e nb yL e m m a9.3\n[Eq. ( wlp-evl)].\nnotation g-orbital ((1x´ =- & -o n-- @ -))\nlemma ffb-g-orbital:\nfbF (x´ = f & Go nTS @ t0) Q =\n{s. ∀X∈Sols (λt. f ) TSt 0 s. ∀t∈T.( ∀τ∈down T t. G (X τ)) −→(Xt ) ∈ Q}\n⟨proof⟩\nlemma (in local-ﬂow) ffb-g-ode:\nfbF (x´ = f & Go nTS @ 0) Q =\n{s. s ∈ S −→(∀t∈T.( ∀τ∈down T t. G (ϕ τ s)) −→(ϕ ts ) ∈ Q)}\n⟨proof⟩\nAs Lemma ffb-g-ode is deﬁned in locale local-ﬂow, users are required to check the conditions\nof the Picard–Lindelöf theorem to access this locale and certify that ϕ is indeed a solution of\nthe IVP as part of our ﬁrst workﬂow.\nFinally, we describe our component for reasoning with differential invariants in the general\nsetting of continuous vector ﬁelds, using our second workﬂow. We start with deﬁnitions and\na basic property from Proposition 11.1.\ndeﬁnition diff-invariant :: (′a ⇒ bool) ⇒ ((′a::real-normed-vector) ⇒ ′a) ⇒ real set ⇒\n′as e t⇒ real ⇒ (′a ⇒ bool) ⇒ bool\nwhere diff-invariant I f T S t0 G = (((g-orbital f G T S t0)† ) {s. Is }⊆{ s. Is })\nlemma ffb-diff-inv:\ndiff-invariant I f T S t0 G = ({s. Is }≤ fbF (x´ = f & Go nTS @ t0) {s. Is })\n⟨proof⟩\nWe have formalised the most important rules for reasoning with differential invariants,\nincluding those for the procedure of Sect. 11 via Corollary 10.3 and Lemmas 4.1 and 11.3.\n123\n126 J. J. Huerta y Munive, G. Struth\nThe formalisation of the ﬁrst two is straightforward. We have proved the clauses of 11.3 in\nvarious lemmas and bundled them under the name diff -invariant-rules. We show one of these\nclauses as an example.\nnamed-theorems diff-invariant-rules compilation of rules for differential invariants.\nlemma [diff-invariant-rules]:\nassumes is-interval T\nand t0 ∈ T\nand ∀X.( DX = (λτ. f (X τ)) on T) −→(D (λτ. μ (X τ) − ν( X τ)) = ((∗R) 0) on T)\nshows diff-invariant (λs.μ s = ν s) fTSt 0 G\n⟨proof⟩\nlemma ffb-g-odei: P ≤{ s. Is }/equal1 ⇒{s. Is }≤ fbF (x´ = f & Go nTS @ t0) {s. Is }/equal1 ⇒\n{s. Is ∧ Gs }≤ Q /equal1⇒P ≤ fbF (x´ = f & Go nTS @ t0 DINV I) Q\n⟨proof⟩\nLemma ffb-g-odei completes the procedure of Sect. 11 by formalising step 2, which annotates\ninvariants in evolution commands, following the approach outlined for loops and general\ncommands in MKA at the end of Sect. 4. With Isabelle, we use the DINV keyword.\nThe two workﬂows for proving partial correctness speciﬁcations with evolution com-\nmands require users to discharge proof obligations for derivatives. In the case of ﬂows, these\nmust be solutions for vector ﬁelds; in the case of differential invariants, the procedure of\nSect. 11 requires proving the assumptions of Lemma 11.3. To increase proof automation\nwhen reasoning about derivatives, we have bundled several derivative properties under the\nname poly-derivatives as a proof method.\nnamed-theorems poly-derivatives compilation of optimised miscellaneous derivative rules.\ndeclare has-vderiv-on-const [poly-derivatives]\nand has-vderiv-on-id [poly-derivatives]\nand has-vderiv-on-add [THEN has-vderiv-on-eq-rhs, poly-derivatives]\nand has-vderiv-on-diff [THEN has-vderiv-on-eq-rhs, poly-derivatives]\nand has-vderiv-on-mult [THEN has-vderiv-on-eq-rhs, poly-derivatives]\nlemma [poly-derivatives]: Df = f ′on T /equal1⇒g = (λt. − f ′t) /equal1⇒D (λt. − ft ) = go nT\n⟨proof⟩\nlemma [poly-derivatives]: (a::real) ̸= 0 /equal1⇒Df = f ′on T /equal1⇒g = (λt.( f ′t)/a) /equal1⇒\nD (λt.( ft )/a) = go nT\n⟨proof⟩\nlemma [poly-derivatives]: n ≥ 1 /equal1⇒D (f ::real ⇒ real) = f ′on T /equal1⇒\ng = (λt. n ∗ (f ′t) ∗ (ft )ˆ(n−1)) /equal1⇒D (λt.( ft )ˆn) = go nT\n⟨proof⟩\nlemma [poly-derivatives]: D (f ::real ⇒ real) = f ′on T /equal1⇒\ng = (λt. − (f ′t) ∗ sin (ft )) /equal1⇒D (λt. cos (ft )) = go nT\n⟨proof⟩\nlemma [poly-derivatives]: D (f ::real ⇒ real) = f ′on T /equal1⇒g = (λt.( f ′t) ∗ cos (ft )) /equal1⇒\nD (λt. sin (ft )) = go nT\n⟨proof⟩\nlemma [poly-derivatives]: D (f ::real ⇒ real) = f ′on T /equal1⇒g = (λt.( f ′t) ∗ exp (ft )) /equal1⇒\nD (λt. exp (ft )) = go nT\n⟨proof⟩\n123\nPredicate Transformer Semantics for Hybrid Systems 127\nIsabelle can now apply rules iteratively and check, for pairs of functions, if one is a\nderivative of the other. This is often fully automatic. The following lemma shows an example\nthat involves a mix of polynomials and transcendental functions beyond differential ﬁelds\nwith a\n0 to a5 being constants and t the polynomial variable.\nlemma c ̸= 0 /equal1⇒D (λt. a5 ∗ tˆ5+ a3 ∗ (tˆ3/ c) − a2 ∗ exp (tˆ2) + a1 ∗ cos t + a0)\n= (λt. 5 ∗ a5 ∗ tˆ4+ 3 ∗ a3 ∗ (tˆ2/ c) − 2 ∗ a2 ∗ t ∗ exp (tˆ2) − a1 ∗ sin t) on T\nby(auto intro!: poly-derivatives)\nThe formalisation of more advanced heuristics for such functions, and the integration of\ndecision procedures for suitable classes, is left for future work.\nThe complete Isabelle formalisation, including the other two predicate transformer alge-\nbras and the relational semantics, can be found in the Archive of Formal Proofs [ 25].\nWe brieﬂy reﬂect on our experience with the Isabelle formalisation of our framework. MKA,\nits relational model and the concrete relational semantics for traditional while programs are\nso far the most developed and versatile starting point for our hybrid systems veriﬁcation\ncomponents. The full formalisation of a rudimentary Hoare logic component for this setting\nusing a generalised Kleene algebra from Isabelle’s main libraries ﬁts on two A4 pages [ 62]; a\nsimilar development for a Hoare logic for hybrid programs is discussed in a successor paper\n[11]. Our standalone MKA-based veriﬁcation component for traditional while programs ﬁlls\nabout seven A4 pages. For hybrid programs, in theory, only a concrete semantics for hybrid\nprograms needs to be plugged in as a replacement of the semantics described in Sect. 7.I n\npractice, however, Isabelle’s instantiations often make theory hierarchies non-compositional\nas each type can only be instantiated in one way. We faced such a clash of instances between\nIsabelle’s Kleene algebra and analysis hierarchies and hence had to customise the former for\nour purposes.\nReplacing the intermediate relational semantics by state transformers required some back-\nground work, simply because the former are well supported by Isabelle, whereas the latter are\nnew. Interestingly, it is possible to propagate theorems automatically along the isomorphisms\nbetween these semantics like for type classes, locales and their instantiations and interpreta-\ntion. Isabelle’s transfer and lifting packages provide an infrastructure for this, which remains\nby and large unexplored. We leave this for future work.\nThe categorical approach to transformer quantaloids is more complex—both conceptually\nand from a formalisation point of view—than the MKA based one, in particular when state\ntransformers are integrated via the powerset monad. At the level of veriﬁcation conditions\ngeneration, however, there are almost no differences. Once again a stripped down component\ncan be generated that just sufﬁces for veriﬁcation condition generation, and we are using it\nin subsequent work [ 12]. Relative to Isabelle’s main libraries, it ﬁlls merely four pages [ 25].\nWorking with quantales instead of quantaloids might seem mathematically simpler, but with\nIsabelle it is actually more tedious, as subtypes for endofunctions need to be created.\nIn sum, for simple veriﬁcation tasks, the lightweight stripped down predicate transformer\nalgebras obtained from MKA or quantaloids seem preferable; for more complex program\ntransformations or reﬁnements, the integration into the full MKA hierarchy or categorical\npredicate transformer component is certainly beneﬁcial.\n16 IsabelleSupportford L-StyleReasoning\nThis section lists our formalisation of semantic variants of the most important axioms and\ninference rules of d\nL in Isabelle outlined in Sect. 12. It covers all three predicate transformer\n123\n128 J. J. Huerta y Munive, G. Struth\nsemantics as well as the relational and state transformer model. Once again, we only show\nstate transformers in the categorical approach.\nWe have formalised a generalised version of the dL-rules with parameters T , S and t0\nwith intervals U and for orbitals. We can easily instantiate them to R, RV and 0, respectively.\nThis enables users to perform veriﬁcation proofs in the style of dL and establishes soundness\nof these rules relative to our semantics as a side effect. First, we show our formalisations of\n(DS)a n d( dSolve).\nlemma DS:\nﬁxes c::′a::{heine-borel, banach}\nshows fbF (x´ = (λs. c) & G) Q ={ x. ∀t.( ∀τ≤t. G (x+τ ∗R c)) −→(x+t ∗R c) ∈ Q}\n⟨proof⟩\nlemma solve:\nassumes local-ﬂow f UNIV UNIV ϕ\nand ∀s. s ∈ P −→(∀t.( ∀τ≤t. G (ϕ τ s)) −→(ϕ ts ) ∈ Q)\nshows P ≤ fbF (x´ = f & G) Q\n⟨proof⟩\nNext, we list semantic variants of the ﬁve dL axioms and inference rules for reasoning\nwith differential invariants discussed in Sect. 12. Recall that due to our semantic approach,\nevolution commands in these rules only require the vector ﬁeld f :: ′a ⇒ ′a and guard G :: ′a\n⇒ bool, while the x´ = is just syntactic sugar to resemble ODEs.\nlemma DW: fbF (x´ = f & G) Q = fbF (x´ = f & G) {s. Gs −→s ∈ Q}\n⟨proof⟩\nlemma dW:{ s. Gs }≤ Q /equal1⇒P ≤ fbF (x´ = f & G) Q\n⟨proof⟩\nlemma DC:\nassumes fbF (x´ = f & G) {s. Cs }= UNIV\nshows fbF (x´ = f & G) Q = fbF (x´ = f & (λs. Gs ∧ Cs )) Q\n⟨proof⟩\nlemma dC:\nassumes P ≤ fbF (x´ = f & G) {s. Cs }\nand P ≤ fbF (x´ = f & (λs. Gs ∧ Cs )) Q\nshows P ≤ fbF (x´ = f & G) Q\n⟨proof⟩\nlemma dI:\nassumes P ≤{ s. Is }\nand diff-invariant I f UNIV UNIV 0 G\nand {s. Is }≤ Q\nshows P ≤ fbF (x´ = f & G) Q\n⟨proof⟩\nAdditional dL rules can easily be formalised. More recent work features, for instance, a\nghost rule [ 12], which is heavily used for reasoning with invariants in dL, but seems less\nrelevant to our semantic approach [ 45].\n123\nPredicate Transformer Semantics for Hybrid Systems 129\n17 VeriﬁcationExamples\nThis section explains the formalisation of the bouncing ball examples from Sect. 9 and 11\nwith Isabelle, and we add two further veriﬁcation examples using a simple circular pendulum.\nAll four of them use Isabelle’s type 2 of two elements. It denotes the set of variables V of\nhybrid programs over the state space R\nV for |V |= 2. We follow Isabelle’s notation and\nwrite 0::2 and 1::2 for the two variables and their type. As such a formalisation of variables\nis rather unwieldy, more recent extensions to our framework support more general name\nspaces, more sophisticated store models and a more user-friendly speciﬁcation language for\nhybrid programs and assertions [ 12]. The examples in this section should therefore be taken\ncum grano salis.\nExample 17.1 (Bouncing Ball via Flow)First, we formalise Example 9.4 with our veriﬁcation\ncomponents for ﬂows, using our ﬁrst workﬂow. We write 0::2 for the ball’s position starting\nfrom height h, 1::2 for its velocity, and s$0 and s$1 for s\nx and sv. We formalise the vector\nﬁeld f (sx ,sv)T = (sv,−g)T for the ball as\nabbreviation fball :: real ⇒ realˆ2⇒ realˆ2(f )\nwhere fgs ≡ (χ i. if i=0t h e ns$1 else g)\nWe can now state the partial correctness speciﬁcation for the bouncing ball in Isabelle,\nwhere the loop invariant I is that of Sect. 9, but written slightly differently to enhance proof\nautomation.\nlemma bouncing-ball: g < 0 /equal1⇒h ≥ 0 /equal1⇒\n{s. s$0 = h ∧ s$1 = 0}≤ fbF\n(LOOP (\n(x´ =(fg ) & (λ s. s$0 ≥ 0)) ;\n(IF (λ s. s$0 = 0) THEN (1 ::= (λs. − s$1)) ELSE skip))\nINV (λs. 0 ≤ s$0 ∧2 · g · s$0 − 2 · g · h − s$1 · s$1 = 0))\n{s. 0 ≤ s$0 ∧ s$0 ≤ h}\nThe proof of this lemma is shown below. It follows that in Example 9.4, but requires some\nintermediate lemmas. For example, if we ﬁrst apply rule ffb-loopI (wlp-star), the subgoals\nP ≤ I and I ≤ Q,f o r P = (λs. sx = h ∧ sv = 0) and Q = (λs. 0 ≤ sx ≤ h), need to\nbe proven. They can be discharged automatically after supplying some lemmas about real\narithmetic, which have been bundled under the name bb-real-arith. We show one of them\nbelow to give an impression.\nnamed-theorems bb-real-arith real arithmetic properties for the bouncing ball.\nlemma [bb-real-arith]: 0 > g /equal1⇒2 · g · x − 2 · g · h = v ·/equal1 ⇒(x::real) ≤ h\n⟨proof⟩\nThese properties depend on distributivity and commutativity properties that Isabelle cannot\nsimplify immediately. As we are not working within a well-deﬁned language, such as dif-\nferential rings or ﬁelds, we have not attempted to automate them any further, so that proofs\nrequire some user interaction.\nThe remaining rules, that is, ffb-kcomp (wlp-seq), ffb-if-then-else (wlp-cond), and\nffb-assign (wlp-asgn), have been added to Isabelle’s automatic proof tools. It then remains to\ncompute the wlp for the evolution command of the bouncing ball. To use local-ﬂow.ffb-g-ode\n(wlp-evl), we follow the procedure in Sect. 9. We need to check that the vector ﬁeld is Lip-\n123\n130 J. J. Huerta y Munive, G. Struth\nschitz continuous, supply the local ﬂow as in Example 9.4 and check that it solves the IVP\nand satisﬁes the ﬂow conditions.\nabbreviation ball-ﬂow :: real ⇒ real ⇒ realˆ2⇒ realˆ2(ϕ)\nwhere ϕ gts ≡ (χ i. if i=0t h e ng· tˆ2 /2 + s$1 · t + s$0 else g · t + s$1)\nlemma local-ﬂow-ball: local-ﬂow (fg ) UNIV UNIV (ϕ g)\n⟨proof⟩\nThe arithmetic computations with real numbers at the end of Example 9.4 are then discharged\nautomatically by adding the rules in bb-real-arith to Isabelle’s automatic tools. The resulting\ntwo-line proof of the bouncing ball is shown below.\napply(rule wp-loopI, simp-all add: local-ﬂow.wp-g-ode[OF local-ﬂow-ball])\nby (auto simp: bb-real-arith)\nOverall, the veriﬁcation proof covers less than a page and a half in the proof document—\nand this is mainly due to the few arithmetic calculations in the background that require user\ninteraction. All other proofs make heavy use of Isabelle’s simpliﬁers and are by and large\nautomatic. ⊓⊔\nExample 17.2 (Bouncing Ball via Invariant) This example formalises the invariant-based\nproof from Example 11.5 using our second workﬂow. The correctness speciﬁcation changes\nin that we annotate the differential invariant ab initio.\nlemma bouncing-ball-invariants: g < 0 /equal1⇒h ≥ 0 /equal1⇒\n{s. s$0 = h ∧ s$1 = 0}≤ fbF\n(LOOP (\n(x´ =(fg ) & (λ s. s$0 ≥ 0) DINV (λs. 2 · g · s$0 − 2 · g · h − s$1 · s$1 = 0)) ;\n(IF (λ s. s$0 = 0) THEN (1 ::= (λs. − s$1)) ELSE skip))\nINV (λs. 0 ≤ s$0 ∧2 · g · s$0 − 2 · g · h − s$1 · s$1 = 0))\n{s. 0 ≤ s$0 ∧ s$0 ≤ h}\napply(rule ffb-loopI, simp-all)\napply(force, force simp: bb-real-arith)\nby(rule ffb-g-odei)( auto intro!: diff-invariant-rules poly-derivatives)\nAs before, the ﬁrst line of the proof applies the non-evolution wlp-rules; the sec-\nond one discharges P ≤ I and I ≤ Q for loop invariant I . It remains to show that\nI ≤| x′ = f & G DINV Id ]I for differential invariant Id .\nFor this, we unfold the annotated invariant rule ffb-g-odei, which performs step (2) of\nExample 11.5 and generates the proof obligation Id ≤| x′ = f & G]Id . The proof of this\nfact is automatic because the rule ffb-diff-inv (Lemma 11.2) has been added to Isabelle’s\nsimpliﬁers. Step (1) is checked with our rules for derivatives poly-derivatives and differential\ninvariants diff-invariant-rules (Proposition 11.3). The full veriﬁcation covers less than a page\nin the proof document. ⊓⊔\nExample 17.3 (Circular Pendulum via Invariant)The ODEs\nx′t = yt and y′t =− xt ,\nwhich correspond to the vector ﬁeld f : RV → RV ,\nf\n( sx\nsy\n)\n=\n( 01\n−10\n)( sx\nsy\n)\n,\n123\nPredicate Transformer Semantics for Hybrid Systems 131\nfor V ={ x, y}, describe the kinematics of a circular pendulum. All orbits are “governed” by\nthe separable differential equation\ndy\ndx = y′\nx′ =− x\ny ,\nobtained by parametric derivation. Rewriting it as x dx +y dy = 0 and integrating both sides\nyield x2 +y2 = r2, for some constant r > 0, which describes the circular orbits of the ODEs.\nThis leads to the differential invariant\nI =\n(\nλs. s2\nx + s2\ny = r2\n)\n,( r ≥ 0).\nOnce again, we apply our procedure from Sect. 11 to prove\nI =| x′ = f & ⊤] I\nusing Lemma 11.4, as the guard is trivial.\n1. Using Proposition 11.3 with μs = s2\nx and ν s = r2 −s2\ny , we check that I is an invariant,\nshowing that (μ ◦ X)′ = (ν ◦ X)′ for all X ∈ Sols fTs , and hence\n(\n(Xtx )2)′\n=\n(\nr2 − (Xty )2)′\n.\nWe calculate\n(\n(Xtx )2)′\n= 2(Xtx )(X′tx ) =− 2(X′ty )(Xty ) =\n(\nr2 − (Xty )2)′\n.\nIt therefore follows from Proposition 11.3(1) that I is an invariant for f along RV ;\nI =| x′ = f & ⊤] I holds by Lemma 11.4.\n2. As P = I = Q, there is nothing to show.\nIn the Isabelle formalisation, we introduce a name for the vector ﬁeld and show that I is\nan invariant for it—as the invariant is the pre- and postcondition, an annotation is not needed.\nThe veriﬁcation is straightforward following the workﬂow of the previous example, and even\nsimpler because the pre- and postconditions are just the differential invariant.\nabbreviation fpend :: realˆ2⇒ realˆ2(f )\nwhere fs ≡ (χ i. if i=0t h e ns$1 else −s$0)\nlemma pendulum:{ s. r2 = (s$0)2 + (s$1)2}≤ fbF (x´ = f & G) {s. r2 = (s$0)2 + (s$1)2}\nby (auto intro!: diff-invariant-rules poly-derivatives)\nThe Isabelle proof is automatic if we supply the tactic for derivative rules. ⊓⊔\nExample 17.4 (Circular Pendulum via Flow) Alternatively, the kinematic equations for the\ncircular pendulum from Example 17.4 can of course be solved using linear combinations\nof trigonometric functions. Yet ﬁrst we need to show that the vector ﬁeld f is Lipschitz\ncontinuous with constant 1. Next, we supply the ﬂow\nϕs t =\n( cos t sin t\n−sin t cos t\n)( sx\nsy\n)\n.\nWe need to check that it solves the IVP ( f ,s) for all s ∈ RV and that it satisﬁes the ﬂow\nconditions for T = R and S = RV . As an example calculation,\nϕ′\ns t =\n( −sin t cos t\n−cos t −sin t\n)( sx\nsy\n)\n=\n( 01\n−10\n)( cos t sin t\n−sin t cos t\n)( sx\nsy\n)\n= f (ϕs t).\n123\n132 J. J. Huerta y Munive, G. Struth\nThe remaining conditions are left to the reader.\nTo compute |x′ = f & ⊤] I , we expand ( wlp-evl). This yields\n|x′ = f & ⊤] Is =∀ t. I (ϕs t)\n=\n(\n∀t.( ϕs tx )2 + (ϕs ty )2 = r2)\n=\n(\n∀t.( sx cos t +sy sin t)2 + (sy cos t − sx sin t)2 = r2)\n=\n(\n∀t. s2\nx (sin2 t + cos2 t) + s2\ny (sin2 t + cos2 t) = r2\n)\n= Is .\nIn the Isabelle proof along these lines, we ﬁrst prove that the vector ﬁeld satisﬁes the con-\nditions of the Picard–Lindelöf theorem. To this end, we need to unfold the locale deﬁnitions,\nthen introduce the Lipschitz constant and call Isabelle’s simpliﬁers. Next, to prove that the\nsolution supplied is a ﬂow and a solution to the IVP , we unfold deﬁnitions and ﬁnish the\nproof by checking that the derivative of the ﬂow in each coordinate coincides with the vector\nﬁeld in that coordinate. The introduction of the ﬂow and these lemmas are shown below.\nabbreviation pend-ﬂow :: real ⇒ realˆ2⇒ realˆ2(ϕ)\nwhere ϕ ts ≡ (χ i. if i = 0t h e ns$0 · cos t + s$1 · sin t else s$1 · cos t − s$0 · sin t)\nlemma local-ﬂow-pend: local-ﬂow f UNIV UNIV ϕ\n⟨proof⟩\nThe proof of the correctness speciﬁcation requires only an application of the wlp rule\nlocal-ﬂow.ffb-g-ode (wlp-evl) and Isabelle’s simpliﬁer.\nlemma pendulum:{ s. r2 = (s$0)2 + (s$1)2}≤ fbF (x´ =f & G) {s. r2 = (s$0)2 + (s$1)2}\nby (force simp: local-ﬂow.ffb-g-ode[OF local-ﬂow-pend])\n⊓⊔\nAll four examples have been based on the categorical approach and the state transformer\nsemantics. Alternative formalisations for the other predicate transformer algebras and the\nrelational semantics can be found in other veriﬁcation components [ 25]. In the MKA-based\ncomponent, the proofs using the relational and the state transformer semantics are precisely\nthe same, which underpins the modularity of our approach. In the other components, we\ncould certainly achieve the same effect by simply rewriting names and adjusting some types.\nTranscendental functions cannot be expressed directly in d\nL’s term language, yet we can\nuse them smoothly and easily with Isabelle with the tactic outlined in Sect. 15. Both the\ndifferential invariant workﬂow and the ﬂow-based workﬂow beneﬁt from these rules. In fact,\nboth approaches are very similar for the pendulum example: both need a handful of lemmas\nto prove the partial correctness speciﬁcation I =| x\n′ = f & ⊤] I , and both require a creative\nstep in the form of introducing a differential invariant or the ﬂow for the system.\nWe have presented the pendulum example in matrix notation as this points to a common\nfeature of many applications: their dynamics can be described by linear systems of ODEs that\nare representable by matrices and have uniform solutions given by a matrix exponential that\ncan be computed with standard methods from linear algebra. The development of domain-\nspeciﬁc techniques for linear systems with Isabelle has been the subject of a successor article\n[26]. Beyond these simple examples, our approach has successfully tackled a large set of\nbenchmarks from a systems competition [ 45] and been ﬁne-tuned for proof automation,\nso that the size of proofs and level of user interaction reported in this article is no longer\nrepresentative. More information about the background theory development with Isabelle and\n123\nPredicate Transformer Semantics for Hybrid Systems 133\nthe methods and heuristics programmed can be found in the ﬁrst author’s doctoral dissertation\n[27]. A more far-reaching integration of solvers and decision procedures, or procedures\nfor invariant learning, as oracles or with correctness guarantees, is of course crucial to the\napplicability of this framework, but beyond the semantic considerations of this article. It is\nleft for future work.\n18 Outlook:AFlow-BasedVeriﬁcationComponent\nThe veriﬁcation components presented so far adhered very much to the pessimistic interactive\ntheorem proving mindset that prefers the internal reconstruction of all external results. This\nsection brieﬂy outlines a fourth, more optimistic veriﬁcation component that deviates entirely\nfrom the vector-ﬁeld-based approach of d\nL and works directly with ﬂows or solutions to IVPs.\nIt shifts responsibility for the correctness of solutions entirely to users—or the computer\nalgebra system they could or should use. This is common practice for instance when working\nwith hybrid automata [ 10], and of course it simpliﬁes proofs considerably.\nFor this third workﬂow supported by our framework, the topological or differentiable\nstructure of the underlying state space is of secondary interest. With Isabelle, this kind\nof structure and additional conditions can always be imposed by instantiating types with\nsort constraints as they arise. Hence, we start from a setting that covers both discrete and\ncontinuous evolutions and use a general type for time instead of real, rat or int. The evolution\ncommands now specify arbitrary guarded ϕ-type functions instead of vector ﬁelds. The type\nof time needs to admit an order relation, which is indicated by the sort constraint ord below,\nyet speciﬁc properties, such as reﬂexivity or transitivity, need not be imposed ab initio.\nApart from that, the deﬁnition of the guarded-orbit semantics and the wlp rule are as before,\nbut side conditions on Lipschitz continuity or the Picard–Lindelöf theorem are superﬂuous.\ndeﬁnition g-evol :: ((′a::ord) ⇒ ′b ⇒ ′b) ⇒ ′bp r e d⇒ ′as e t⇒ (′b ⇒ ′bs e t)( EVOL)\nwhere EVOL ϕ GT = (λs. g-orbit (λt.ϕ ts ) GT )\nlemma fbox-g-evol[simp]:\nﬁxes ϕ :: (′a::preorder) ⇒ ′b ⇒ ′b\nshows fbF (EVOL ϕ GT ) Q ={ s.( ∀t∈T.( ∀τ∈down T t. G (ϕ τ s)) −→(ϕ ts ) ∈ Q)}\nunfolding g-evol-def g-orbit-eq ffb-eq by auto\nUsing the ﬂows of the bouncing ball and the circular pendulum from previous examples,\nveriﬁcation proofs are now fully automatic.\nlemma pendulum-dyn:\n{s. r2 = (s$0)2 + (s$1)2}≤ fbF (EVOL ϕ GT ) {s. r2 = (s$0)2 + (s$1)2}\nby force\nlemma bouncing-ball-dyn: g < 0 /equal1⇒h ≥ 0 /equal1⇒\n{s. s$0 = h ∧ s$1 = 0}≤ fbF\n(LOOP (\n(EVOL (ϕ g)( λs. s$0 ≥ 0) T) ;\n(IF (λ s. s$0 = 0) THEN (1 ::= (λs. − s$1)) ELSE skip))\nINV (λs. 0 ≤ s$0 ∧2 · g · s$0 − 2 · g · h − s$1 · s$1 = 0))\n{s. 0 ≤ s$0 ∧ s$0 ≤ h}\nby (rule ffb-loopI)( auto simp: bb-real-arith)\n123\n134 J. J. Huerta y Munive, G. Struth\nThese examples no longer link ﬂows with initial speciﬁcations in terms of system of ODEs,\nfrom which a user might have started. Hence, there is no longer any formal guarantee from\nIsabelle that the function ϕ speciﬁed satisﬁes any continuity of differentiability assumptions\nsuch as those of local-ﬂow.\nFurther elaboration of this approach, in particular towards discrete systems or in the\ndirection of hybrid automata, is left for future work.\n19 RelatedWork\nMethods for automated veriﬁcation condition generation for partial and total correctness\nassertions with proof assistants date back to the early days of hardware and software veriﬁ-\ncation by Gordon and colleagues [ 19]. Discussions on the beneﬁts of shallow embeddings\nof veriﬁcation methods in proof assistants—among them faster developments and increased\nmodularity—can be traced back to the same group of researchers. We generally follow an\napproach described in [ 2] that starts from algebras of programs to generate veriﬁcation con-\nditions for the structural commands of programs, while developing those for basic commands\nin concrete semantics of the program store dynamics.\nMathematical components for classical real analysis have been developed for the Coq\nproof assistant in the Coquelicot library [ 7], others for constructive analysis in the CoRN\nlibrary [ 8]. The Picard–Lindelöf theorem seems to be available only in the latter [ 42]. The\nproof assistant HOL-light includes a library with formalised n-dimensional Euclidean spaces.\nThe ﬁrst formalisation of the Picard–Lindelöf theorem in Isabelle, which we rewrite for our\npurposes and specialise to local ﬂows, can be found in the AFP entry for ordinary differential\nequations [ 30].\nHybrid systems veriﬁcation in general-purpose proof assistants has also been investigated.\nExamples in PVS include semantic invariant reasoning with hybrid automata [ 1] and, after\nsubmission of this article and publication of its precursor [ 28], d\nL-style veriﬁcation with semi-\nalgebraic sets and real analytic functions [ 59]. An earlier formalisation of the control function\nof an inverted pendulum [ 57] uses the Coquelicot library. Also in Coq, the robot operating\nsystem (ROSCoq) framework uses a shallowly embedded logic of events to reason about\nhybrid systems but only with d\nL’s differential induction rule. The HHL prover [ 67] formalises\na Hoare-logic for hybrid systems veriﬁcation within its calculus of hybrid communicating\nsequential processes in Isabelle [ 38]; part of their approach has been deeply embedded. Their\nsemantics is very different from ours. An integration of their LZZ method [ 39] for ﬁnding\nsemi-algebraic invariants for polynomial dynamical systems could probably be integrated\ninto our framework to increase proof automation. Finally, a term-checker for KeYmaera X\n[6] and, after submission of this article, a formalisation of differential game logic ( d\nGL)[ 50]\nhave been deeply embedded recently in Isabelle/HOL. None of them aim at hybrid program\nveriﬁcation.\nFor an in-depth description of d\nL see [ 49], a thorough study of differential invariants has\nbeen pursued in [ 46].\nIn theory, our own framework should therefore allow the integration of much of the\nrelated work mentioned, so long as it is consistent with our hybrid store semantics. It is\nnot even necessary to delegate every task to the proof assistant. One can use external tools\nimplementing decision procedures as oracles or at least certify their outputs with Isabelle.\nThe oracle-based approach, however, may jeopardise the desirable conservative extension\nproperty relative to Isabelle’s own kernel. Translations between different proof assistants may\n123\nPredicate Transformer Semantics for Hybrid Systems 135\nnot always be straightforward. For instance, it is yet to be seen if dependent types or multi-\nparameter type classes are needed for more ﬂexible implementations of functions spaces\n(bounded, linear and continuous) or complex vector spaces, or if alternative formalisations\nof Picard–Lindelöf theorem and other existence theorems might help us to alleviate some of\nthe requirements in our workﬂows.\n20 Conclusion\nWe have presented a new semantic framework for the deductive veriﬁcation of hybrid systems\nwith the Isabelle/HOL proof assistant. The approach is inspired by differential dynamic logic,\nbut the design of our veriﬁcation components, the focus of our framework and the workﬂows\nfor verifying hybrid systems are different.\nFirst of all, as we use a shallow embedding, the basic veriﬁcation components generated\nare quite minimalist and conceptually simple. They merely require the integration of a wlp\nsemantics for basic evolution commands of hybrid programs into standard predicate trans-\nformer algebras. Our preferred semantics for such commands are state transformers, which in\nmost cases simply map states to the guarded orbits of their temporal evolutions. Beyond that,\nno domain-speciﬁc inference rules are needed, veriﬁcation condition generation is fully auto-\nmatic, and even our approach to differential invariants is based entirely on general purpose\nalgebraic invariance laws. Our examples show that mathematical reasoning about differential\nequations follows standard textbook style and hence comes close to the way mathematicians,\nphysicists or control engineers have been trained to reason about such systems. Whether this\nis preferable to the proof-theoretic approach advocated by KeYmaera X remains to be seen.\nSecondly, our approach aims at an open experimental platform that is only limited by\nIsabelle’s ODE and analysis components, the expressivity of its higher-order logic and type\nsystem and the proof methods it provides. We could, for instance, have developed our seman-\ntics for time-dependent vector ﬁelds, but the restriction to autonomous systems, which does\nnot affect generality, seems preferable in practice. The integration of internal or external\nsolvers for differential algebras, transcendental functions or computer algebra systems for\ncomputing Lipschitz constants or ﬂows in the style of Isabelle’s Sledgehammer tactic is cer-\ntainly interesting and a very important avenue for future work, but not a main concern in this\narticle. So far, our open approach simply offers semantic alternatives that users may explore,\nadapt and extend.\nTwo specialisations of our framework are the topic of successor papers. The ﬁrst one\nrestricts our approach to linear systems of differential equations, where exponential solu-\ntions exist and can be computed with standard methods from linear algebra [ 26]. The second\none [11] specialises the predicate transformer semantics to algebraic variants of Hoare logics\nand to reﬁnement calculi for hybrid programs along the lines of previous components for\ntraditional while programs [ 2]. This shows that our denotational semantics for hybrid pro-\ngrams are compatible with any Hoare logic, which constitutes another signiﬁcant conceptual\nsimpliﬁcation relative to d\nL and KeYmaera X.\nBeyond that we expect that a recent formalisation of Poincaré maps with Isabelle [ 31]\nmight allow us to extend our framework to discrete dynamical systems and more computa-\ntional approaches to hybrid systems.\nMoreover, differential-algebraic systems of equations [ 20], which mix differential equa-\ntions and algebraic equations, and partial differential equations [ 34] are important for many\napplications in control engineering and physics. Extending our approach is likely to require\n123\n136 J. J. Huerta y Munive, G. Struth\nsigniﬁcant background work on mathematical components with Isabelle. While, in both set-\ntings, some simple cases can be reduced to systems of ODEs, numerical methods are usually\nneeded for working with such systems. Whether the workﬂow of mathematicians, physicists\nand engineers with such more computational approaches can be approximated easily with\nIsabelle remains to be seen.\nFinally, much work is needed to transform our framework into an applicable veriﬁcation\ntool for hybrid systems. First steps have meanwhile been taken [ 12] with respect to more\nreﬁned hybrid stores and a more user-friendly speciﬁcation language for hybrid programs\nand their correctness properties, as already mentioned. More important, however, seems\nthe integration of external solvers and decision procedures, to which much work in the\nhybrid systems community has already been devoted [ 13,39,54,58,60]. Such procedures\nalready increase the proof automation of KeYmaera X, and we foresee no reason why similar\nintegrations should not lead to similar beneﬁts within our own framework.\nAcknowledgements We are grateful to Ana Cavalcanti, Achim Brucker, Thao Dang, Simon Foster, Sergey\nGoncharov, Peter Höfner, Sergio Mover, André Platzer, Andrei Popescu, Dmitriy Traytel as well as the partic-\nipants of the RAMiCS 2018 conference and our Oslo lecture series on Isabelle/HOL for fruitful discussions.\nWe would also like to thank our referees for pointers to related work and many suggestions that helped us to\nimprove the presentation of this work and reﬂect on its contributions. The ﬁrst author acknowledges support\nby scholarship no. 440404 of the Mexican Consejo Nacional de Ciencia y Tecnología (CONACyT).\nOpen Access This article is licensed under a Creative Commons Attribution 4.0 International License, which\npermits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give\nappropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence,\nand indicate if changes were made. The images or other third party material in this article are included in the\narticle’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is\nnot included in the article’s Creative Commons licence and your intended use is not permitted by statutory\nregulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder.\nTo view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/ .\nA Cross-ReferencestoIsabelleLemmas\nResult in article Formalisation in Isabelle [ 25]\nProposition 2.1 Implied by interpretation rel-aka in Sect. 15\nProposition 2.2 Implied by instantiation nd-fun in Sect. 15\nProposition 3.1 interpretation rel-aka in Sect. 15\nProposition 3.2 instantiation nd-fun in Sect. 15\nwlp for sequential composition ( wlp-seq) ffb-kcomp in Sect. 15\nwlp rule for if-then-else ( wlp-cond) ffb-if-then-else in Sect. 15\nwlp rule for ﬁnite iterations ( wlp-while) In the proof of ffb-loopI in Sect. 15\nLemma 4.1 Part of named-theorems diff-invariant-rules of Sect. 15\nUpdate functions from Sect. 7 deﬁnition vec-upd in Sect. 15\nSemantics for assignments from Sect. 7 deﬁnition assign in Sect. 15\nwlp for assignments from Sects. 7 (wlp-asgn) ffb-assign in Sect. 15\nOrbits in Sect. 8 deﬁnition orbit in Sect. 15\nPicard–Lindelöf Theorem 8.2 picard-lindeloef-closed-ivl.unique-solution in Sect. 14\nMonoid action identities for ﬂows from Sect. 8 local-ﬂow.is-monoid-action in Sect. 14\n123\nPredicate Transformer Semantics for Hybrid Systems 137\nResult in article Formalisation in Isabelle [ 25]\nG-guarded orbit ( γϕ\nG ) in Sect. 9 instance of deﬁnition g-orbit of Sect. 14\nLemma 9.1 g-orbital-collapses in Sect. 14\nSemantics for evolution commands in Sect. 9 notation g-orbital of Sect. 15\nProposition 9.2 implied by ffb-g-ode in Sect. 15\nLemma 9.3 (wlp-evl) ffb-g-ode in Sect. 15\nExample 9.4 Example 17.1\nSols ft 0 s in Sect. 10 deﬁnition ivp-sols in Sect. 14\nG-guarded orbit γ X\nG of X along T in Sect. 10 deﬁnition g-orbit of Sect. 14\nG-guarded orbital γ f\nG of f along T in Sect. 10 deﬁnition g-orbital of Sect. 14\nLemma 10.1 ffb-g-orbital-eq in Sect. 14\nSemantics for evolution commands in Sect. 10 notation g-orbital of Sect. 15\nProposition 10.2 ffb-g-orbital of Sect. 15\nInvariant of IVP ( f , s) deﬁnition diff-invariant in Sect. 15\nProposition 11.1 ffb-diff-inv in Sect. 15\nProposition 11.3 named-theorems diff-invariant-rules of Sect. 15\nExample 11.5 Example 17.2\ndL-axiom ( DS) in Sect. 12 DS in Sect. 16\nProposition 9.2 (dL-rule ( dSolve)) solve in Sect. 16\nLemma 12.2 (DC) DC in Sect. 16\nLemma 12.2 (dC) dC in Sect. 16\nLemma 12.2 (DW) DW in Sect. 16\nLemma 12.2 (dW) dW in Sect. 16\nLemma 12.2 (dI) dI in Sect. Sect. 16\nReferences\n1. Ábrahám-Mumm, E., Steffen, M., Hannemann, U.: V eriﬁcation of hybrid systems: Formalization and\nproof rules in PVS. In: ICECCS 2001, pp. 48–57. IEEE Computer Society (2001)\n2. Armstrong, A., Gomes, V .B.F., Struth, G.: Building program construction and veriﬁcation tools from\nalgebraic principles. Formal Aspects Comput. 28(2), 265–293 (2016)\n3. Armstrong, A., Struth, G., Weber, T.: Kleene algebra. Archive of Formal Proofs (2013). https://isa-afp.\norg/entries/Kleene_Algebra.html\n4. Arnol’d, V .I.: Ordinary Differential Equations. Springer, New Y ork (1992)\n5. Back, R., von Wright, J.: Reﬁnement Calculus—A Systematic Introduction. Springer, New Y ork (1998)\n6. Bohrer, B., Rahli, V ., Vukotic, I., Völp, M., Platzer, A.: Formally veriﬁed differential dynamic logic. In:\nCPP 2017, pp. 208–221. ACM (2017)\n7. Boldo, S., Lelay, C., Melquiond, G.: Coquelicot: a user-friendly library of real analysis for Coq. MCS\n9(1), 41–62 (2015)\n8. Cruz-Filipe, L., Geuvers, H., Wiedijk, F.: C-corn, the constructive Coq repository at Nijmegen. In: MKM\n2004, volume 3119 of LNCS, pp. 88–103. Springer (2004)\n9. Desharnais, J., Struth, G.: Internal axioms for domain semirings. Sci. Comput. Program. 76(3), 181–203\n(2011)\n10. Doyen, L., Frehse, G., Pappas, G.J., Platzer, A.: V eriﬁcation of hybrid systems. In: Handbook of Model\nChecking., pp. 1047–1110. Springer (2018)\n11. Foster, S., Huerta y Munive, J.J., Struth, G.: Differential Hoare logics and reﬁnement calculi for hybrid\nsystems with Isabelle/HOL. In: RAMiCS 2020, pp. 169–186 (2020)\n12. Foster, S., y Munive, J.J.H., Gleirscher, M., Struth, G.: Hybrid systems veriﬁcation with isabelle/HOL:\nsimpler syntax, better models, faster proofs. CoRR, abs/2106.05987 (2021)\n13. Fulton, N., Mitsch, S., Bohrer, B., Platzer, A.: Bellerophon: Tactical theorem proving for hybrid systems.\nIn: ITP 2017, LNCS, pp. 207–224. Springer (2017)\n14. Fulton, N., Mitsch, S., Quesel, J., Völp, M., Platzer, A.: KeYmaera X: an axiomatic tactical theorem\nprover for hybrid systems. In: CADE-25, volume 9195 of LNCS, pp. 527–538. Springer (2015)\n15. Gierz, G., Hofmann, K.H., Lawson, J.D., Mislove, M., Scott, D.S.: A Compendium of Continuous Lattices.\nSpringer, New Y ork (1980)\n123\n138 J. J. Huerta y Munive, G. Struth\n16. Gomes, V .B.F., Guttmann, W., Höfner, P ., Struth, G., Weber, T.: Kleene algebras with domain. Archive\nof Formal Proofs (2016). https://isa-afp.org/entries/KAD.html\n17. Gomes, V .B.F., Struth, G.: Modal Kleene algebra applied to program correctness. In: FM 2016, volume\n9995 of LNCS, pp. 310–325 (2016)\n18. Gomes, V .B.F., Struth, G.: Program construction and veriﬁcation components based on Kleene algebra.\nIn: Archive of Formal Proofs (2016)\n19. Gordon, M.J.C.: Mechanizing Programming Logics in Higher Order Logic, pp. 387–439. Springer, New\nY ork (1989)\n20. Hairer, E., Wanner, G.: Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Prob-\nlems. Springer, New Y ork (1996)\n21. Harel, D., Kozen, D., Tiuryn, J.: Dynamic Logic. MIT Press, Cambridge (2000)\n22. Hirsch, M.W., Smale, S., Devaney, R.L.: Differential Equations, Dynamical Systems, and Linear Algebra.\nAcademic Press, London (1974)\n23. Hölzl, J., Immler, F., Huffman, B.: Type classes and ﬁlters for mathematical analysis in Isabelle/HOL. In:\nITP 2013, volume 7998 of LNCS, pp. 279–294. Springer (2013)\n24. Hubbard, J.H., West, B.H.: Differential Equations: A Dynamical Systems Approach. Springer, New Y ork\n(1991)\n25. Huerta y Munive, J.J.: V eriﬁcation components for hybrid systems. Archive of Formal Proofs (2019).\nhttps://isa-afp.org/entries/Hybrid_Systems_VCs.html\n26. Huerta y Munive, J.J.: Afﬁne systems of ODEs in Isabelle/HOL for hybrid-program veriﬁcation. In:\nSEFM 2020, volume 12310 of LNCS, pp. 77–92. Springer (2020)\n27. Huerta y Munive, J.J.: Algebraic veriﬁcation of hybrid systems in Isabelle/HOL . PhD thesis, University\nof Shefﬁeld (2021)\n28. Huerta y Munive, J.J., Struth, G.: V erifying hybrid systems with modal Kleene algebra. In: Desharnais, J.,\nGuttmann, W., Joosten, S. (eds.) Relational and Algebraic Methods in Computer Science, pp. 225–243.\nSpringer (2018)\n29. Immler, F., Hölzl, J.: Numerical analysis of ordinary differential equations in Isabelle/HOL. In: ITP 2012,\nvolume 7406 of LNCS, pp. 377–392. Springer (2012)\n30. Immler, F., Hölzl, J.: Ordinary differential equations. Archive of Formal Proofs (2012). https://isa-afp.\norg/entries/Ordinary_Differential_Equations.html\n31. Immler, F., Traut, C.: The ﬂow of ODEs: formalization of variational equation and Poincaré map. J.\nAutom. Reason. 62(2), 215–236 (2019)\n32. Jacobs, B.: A recipe for state-and-effect triangles. In: Logical Methods in Computer Science, vol. 13, no.\n2 (2017)\n33. Jeannin, J., Ghorbal, K., Kouskoulas, Y ., Schmidt, A., Gardner, R., Mitsch, S., Platzer, A.: A formally\nveriﬁed hybrid system for safe advisories in the next-generation airborne collision avoidance system.\nSTTT 19(6), 717–741 (2017)\n34. John, F.: Partial Differential Equations. Springer, New Y ork (1986)\n35. Jónsson, B., Tarski, A.: Boolean algebras with operators, Part I. Americal. J. Math. 73(4), 207–215 (1951)\n36. Kneser, H.: Über die Lösungen eines Systems gewöhnlicher Differentialgleichungen, das der Lips-\nchitzschen Bedingung nicht genügt. Sitz.ber. Preuß, pp. 58–61 (1923)\n37. Kozen, D.: Kleene algebra with tests. ACM TOPLAS 19(3), 427–443 (1997)\n38. Liu, J., Lv, J., Quan, Z., Zhan, N., Zhao, H., Zhou, C., Zou, L.: A calculus for hybrid CSP . In: APLAS\n2010, volume 6461 of LNCS, pp. 1–15. Springer (2010)\n39. Liu, J., Zhan, N., Zhao, H.: Computing semi-algebraic invariants for polynomial dynamical systems.\nIn: Chakraborty, S., Jerraya, A., Baruah, S.K., Fischmeister, S. (eds) EMSOFT 2011, pp. 97–106. ACM\n(2011)\n40. Loos, S.M., Platzer, A., Nistor, L.: Adaptive cruise control: Hybrid, distributed, and now formally veriﬁed.\nIn: FM 2011, volume 6664 of LNCS, pp. 42–56. Springer (2011)\n41. MacLane, S.: Categories for the Working Mathematician. Springer, New Y ork (1971)\n42. Makarov, E., Spitters, B.: The Picard algorithm for ordinary differential equations in Coq. In: ITP 2013,\nvolume 7998 of LNCS, pp. 463–468. Springer (2013)\n43. Manes, E.G.: Predicate Transformer Semantics. Cambridge University Press, Cambridge (1992)\n44. Meijer, E., Fokkinga, M.M., Paterson, R.: Functional programming with bananas, lenses, envelopes and\nbarbed wire. In: Functional Programming Languages and Computer Architecture 1991, volume 523 of\nLNCS. Springer (1991)\n45. Mitsch, S., Huerta y Munive, J.J., Jin, X., Zhan, B., Wang, S., Zhan, N.: ARCH-COMP20 category report:\nHybrid systems theorem proving. In: ARCH20, pp. 141–161 (2019)\n46. Platzer, A.: The structure of differential invariants and differential cut elimination. In: LMCS, vol. 8, no.\n4 (2008)\n123\nPredicate Transformer Semantics for Hybrid Systems 139\n47. Platzer, A.: Logical Analysis of Hybrid Systems. Springer, New Y ork (2010)\n48. Platzer, A.: A complete uniform substitution calculus for differential dynamic logic. J. Autom. Reason.\n59(2), 219–265 (2017)\n49. Platzer, A.: Logical Foundations of Cyber-Physical Systems. Springer, New Y ork (2018)\n50. Platzer, A.: Differential game logic. Archive of Formal Proofs (2019). https://isa-afp.org/entries/\nDifferential_Game_Logic.html\n51. Platzer, A., Tan, Y .K.: Differential equation axiomatization: the impressive power of differential ghosts.\nIn: LICS, pp. 819–828. ACM (2018)\n52. Preoteasa, V .: Algebra of monotonic Boolean transformers. Archive of Formal Proofs (2011). https://isa-\nafp.org/entries/MonoBoolTranAlgebra.html\n53. Preoteasa, V .: Algebra of monotonic boolean transformers. In: Archive of Formal Proofs (2011)\n54. Rebiha, R., Moura, A.V ., Matringe, N.: Generating invariants for non-linear hybrid systems. Theor. Com-\nput. Sci. 594, 180–200 (2015)\n55. Rosenthal, K.I.: The Theory of Quantaloids. Chapman and Hall/CRC, London (1996)\n56. Rosenthal, K.L.: Quantales and Their Applications. Longman Scientiﬁc & Technical, Essex (1990)\n57. Rouhling, D.: A formal proof in Coq of a control function for the inverted pendulum. In: CPP 2018, pp.\n28–41. ACM (2018)\n58. Sassi, M. A. B., Girard, A., Sankaranarayanan, S.: Iterative computation of polyhedral invariants sets for\npolynomial dynamical systems. In: CDC 2014, pp. 6348–6353. IEEE (2014)\n59. Slagel, J.T., White, L., Dutle, A.: Formal veriﬁcation of semi-algebraic sets and real analytic functions.\nIn: CPP 21, pp. 278–290. ACM (2021)\n60. Sogokon, A., Mitsch, S., Tan, Y .K., Cordwell, K., Platzer, A.: Pegasus: A framework for sound continuous\ninvariant generation. In: FM 2019, LNCS, pp. 138–157. Springer (2019)\n61. Struth, G.: On the expressive power of Kleene algebra with domain. Inf. Process. Lett. 116(4), 284–288\n(2016)\n62. Struth, G.: Hoare semigroups. Math. Struct. Comput. Sci. 28(6), 775–799 (2018)\n63. Struth, G.: Properties of orderings and lattices. In: Archive of Formal Proofs (2018)\n64. Struth, G.: Quantales. In: Archive of Formal Proofs (2018)\n65. Struth, G.: Transformer semantics. Archive of Formal Proofs (2018). https://isa-afp.org/entries/\nTransformer_Semantics.html\n66. Teschl, G.: Ordinary Differential Equations and Dynamical Systems. AMS (2012)\n67. Wang, S., Zhan, N., Zou, L.: An improved HHL prover: an interactive theorem prover for hybrid systems.\nIn: ICFEM 2015, pp. 382–399 (2015)\nPublisher’s Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and\ninstitutional afﬁliations.\n123",
  "topic": "HOL",
  "concepts": [
    {
      "name": "HOL",
      "score": 0.9092628955841064
    },
    {
      "name": "Computer science",
      "score": 0.708103597164154
    },
    {
      "name": "Predicate (mathematical logic)",
      "score": 0.6535234451293945
    },
    {
      "name": "Programming language",
      "score": 0.6189709305763245
    },
    {
      "name": "Hybrid system",
      "score": 0.45078977942466736
    },
    {
      "name": "Predicate transformer semantics",
      "score": 0.4499746263027191
    },
    {
      "name": "Operational semantics",
      "score": 0.42183277010917664
    },
    {
      "name": "Invariant (physics)",
      "score": 0.41364508867263794
    },
    {
      "name": "Theoretical computer science",
      "score": 0.4100794494152069
    },
    {
      "name": "Semantics (computer science)",
      "score": 0.3478665351867676
    },
    {
      "name": "Mathematics",
      "score": 0.15937688946723938
    },
    {
      "name": "Machine learning",
      "score": 0.0
    },
    {
      "name": "Mathematical physics",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I91136226",
      "name": "University of Sheffield",
      "country": "GB"
    }
  ],
  "cited_by": 9
}