{
  "title": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages",
  "url": "https://openalex.org/W3008088841",
  "year": 2022,
  "authors": [
    {
      "id": "https://openalex.org/A4221545360",
      "name": "Feng, Zhangyin",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A4221592771",
      "name": "Guo, Daya",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A4221545359",
      "name": "Tang, Duyu",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2370849483",
      "name": "Duan, Nan",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2223857219",
      "name": "Feng, Xiaocheng",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2130808479",
      "name": "Gong-ming",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2951745844",
      "name": "Shou, Linjun",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2106887709",
      "name": "Qin Bing",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A1966340437",
      "name": "Liu Ting",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2358495019",
      "name": "Jiang, Daxin",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2102363648",
      "name": "Zhou, Ming",
      "affiliations": []
    }
  ],
  "references": [
    "https://openalex.org/W2963341956",
    "https://openalex.org/W2971869958",
    "https://openalex.org/W2130942839",
    "https://openalex.org/W2725049817",
    "https://openalex.org/W2995333547",
    "https://openalex.org/W2950813464",
    "https://openalex.org/W2973529529",
    "https://openalex.org/W2948384082",
    "https://openalex.org/W2142112143",
    "https://openalex.org/W2794601162",
    "https://openalex.org/W2963355447",
    "https://openalex.org/W1522301498",
    "https://openalex.org/W1843891098",
    "https://openalex.org/W2931316642",
    "https://openalex.org/W2981852735",
    "https://openalex.org/W2787560479",
    "https://openalex.org/W2963403868",
    "https://openalex.org/W2951861246",
    "https://openalex.org/W2949541494",
    "https://openalex.org/W2516621648",
    "https://openalex.org/W2970608575",
    "https://openalex.org/W2124807415",
    "https://openalex.org/W2525778437",
    "https://openalex.org/W2965373594",
    "https://openalex.org/W2982399380",
    "https://openalex.org/W2157331557",
    "https://openalex.org/W3111372685"
  ],
  "abstract": "We present CodeBERT, a bimodal pre-trained model for programming language (PL) and nat-ural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language codesearch, code documentation generation, etc. We develop CodeBERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both bimodal data of NL-PL pairs and unimodal data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation tasks. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing.",
  "full_text": "CodeBERT:\nA Pre-Trained Model for Programming and Natural Languages\nZhangyin Feng1âˆ—, Daya Guo2âˆ—, Duyu Tang3, Nan Duan3, Xiaocheng Feng1\nMing Gong4, Linjun Shou4, Bing Qin1, Ting Liu1, Daxin Jiang4, Ming Zhou3\n1 Research Center for Social Computing and Information Retrieval, Harbin Institute of Technology, China\n2 The School of Data and Computer Science, Sun Yat-sen University, China\n3 Microsoft Research Asia, Beijing, China\n4 Microsoft Search Technology Center Asia, Beijing, China\n{zyfeng,xcfeng,qinb,tliu}@ir.hit.edu.cn\nguody5@mail2.sysu.edu.cn\n{dutang,nanduan,migon,lisho,djiang,mingzhou}@microsoft.com\nAbstract\nWe present CodeBERT, a bimodal pre-trained\nmodel for programming language (PL) and\nnatural language (NL). CodeBERT learns\ngeneral-purpose representations that support\ndownstream NL-PL applications such as nat-\nural language code search, code documen-\ntation generation, etc. We develop Code-\nBERT with Transformer-based neural architec-\nture, and train it with a hybrid objective func-\ntion that incorporates the pre-training task of\nreplaced token detection, which is to detect\nplausible alternatives sampled from generators.\nThis enables us to utilize both â€œ bimodalâ€ data\nof NL-PL pairs and â€œ unimodalâ€ data, where\nthe former provides input tokens for model\ntraining while the latter helps to learn bet-\nter generators. We evaluate CodeBERT on\ntwo NL-PL applications by ï¬ne-tuning model\nparameters. Results show that CodeBERT\nachieves state-of-the-art performance on both\nnatural language code search and code docu-\nmentation generation. Furthermore, to inves-\ntigate what type of knowledge is learned in\nCodeBERT, we construct a dataset for NL-PL\nprobing, and evaluate in a zero-shot setting\nwhere parameters of pre-trained models are\nï¬xed. Results show that CodeBERT performs\nbetter than previous pre-trained models on NL-\nPL probing.1\n1 Introduction\nLarge pre-trained models such as ELMo (Peters\net al., 2018), GPT (Radford et al., 2018), BERT\n(Devlin et al., 2018), XLNet (Yang et al., 2019)\nâˆ—Work done while this author was an intern at Microsoft\nResearch Asia.\n1 All the codes and data are available at https://\ngithub.com/microsoft/CodeBERT\nand RoBERTa (Liu et al., 2019) have dramati-\ncally improved the state-of-the-art on a variety of\nnatural language processing (NLP) tasks. These\npre-trained models learn effective contextual repre-\nsentations from massive unlabeled text optimized\nby self-supervised objectives, such as masked\nlanguage modeling, which predicts the original\nmasked word from an artiï¬cially masked input\nsequence. The success of pre-trained models in\nNLP also drives a surge of multi-modal pre-trained\nmodels, such as ViLBERT (Lu et al., 2019) for\nlanguage-image and VideoBERT (Sun et al., 2019)\nfor language-video, which are learned from bi-\nmodal data such as language-image pairs with bi-\nmodal self-supervised objectives.\nIn this work, we present CodeBERT, abimodal\npre-trained model for natural language (NL) and\nprogramming language (PL) like Python, Java,\nJavaScript, etc. CodeBERT captures the seman-\ntic connection between natural language and pro-\ngramming language, and produces general-purpose\nrepresentations that can broadly support NL-PL\nunderstanding tasks (e.g. natural language code\nsearch) and generation tasks (e.g. code documen-\ntation generation). It is developed with the multi-\nlayer Transformer (Vaswani et al., 2017), which is\nadopted in a majority of large pre-trained models.\nIn order to make use of both bimodal instances\nof NL-PL pairs and large amount of available uni-\nmodal codes, we train CodeBERT with a hybrid\nobjective function, including standard masked lan-\nguage modeling (Devlin et al., 2018) and replaced\ntoken detection (Clark et al., 2020), where uni-\nmodal codes help to learn better generators for\nproducing better alternative tokens for the latter\nobjective.\nWe train CodeBERT from Github code reposito-\narXiv:2002.08155v4  [cs.CL]  18 Sep 2020\nries in 6 programming languages, where bimodal\ndatapoints are codes that pair with function-level\nnatural language documentations (Husain et al.,\n2019). Training is conducted in a setting similar\nto that of multilingual BERT (Pires et al., 2019),\nin which case one pre-trained model is learned for\n6 programming languages with no explicit mark-\ners used to denote the input programming lan-\nguage. We evaluate CodeBERT on two down-\nstream NL-PL tasks, including natural language\ncode search and code documentation generation.\nResults show that ï¬ne-tuning the parameters of\nCodeBERT achieves state-of-the-art performance\non both tasks. To further investigate what type of\nknowledge is learned in CodeBERT, we construct\na dataset for NL-PL probing, and test CodeBERT\nin a zero-shot scenario, i.e. without ï¬ne-tuning the\nparameters of CodeBERT. We ï¬nd that CodeBERT\nconsistently outperforms RoBERTa, a purely natu-\nral language-based pre-trained model. The contri-\nbutions of this work are as follows:\nâ€¢CodeBERT is the ï¬rst large NL-PL pre-\ntrained model for multiple programming lan-\nguages.\nâ€¢Empirical results show that CodeBERT is ef-\nfective in both code search and code-to-text\ngeneration tasks.\nâ€¢We further created a dataset which is the ï¬rst\none to investigate the probing ability of the\ncode-based pre-trained models.\n2 Background\n2.1 Pre-Trained Models in NLP\nLarge pre-trained models (Peters et al., 2018; Rad-\nford et al., 2018; Devlin et al., 2018; Yang et al.,\n2019; Liu et al., 2019; Raffel et al., 2019) have\nbrought dramatic empirical improvements on al-\nmost every NLP task in the past few years. Suc-\ncessful approaches train deep neural networks on\nlarge-scale plain texts with self-supervised learning\nobjectives. One of the most representative neural\narchitectures is the Transformer (Vaswani et al.,\n2017), which is also the one used in this work. It\ncontains multiple self-attention layers, and can be\nconventionally learned with gradient decent in an\nend-to-end manner as every component is differen-\ntiable. The terminology â€œself-supervisedâ€ means\nthat supervisions used for pre-training are auto-\nmatically collected from raw data without manual\nannotation. Dominant learning objectives are lan-\nguage modeling and its variations. For example,\nin GPT (Radford et al., 2018), the learning objec-\ntive is language modeling, namely predicting the\nnext word wk given the preceding context words\n{w1,w2,...,w kâˆ’1}. As the ultimate goal of pre-\ntraining is not to train a good language model, it is\ndesirable to consider both preceding and following\ncontexts to learn better general-purpose contextual\nrepresentations. This leads us to the masked lan-\nguage modeling objective used in BERT (Devlin\net al., 2018), which learns to predict the masked\nwords of a randomly masked word sequence given\nsurrounding contexts. Masked language modeling\nis also used as one of the two learning objectives\nfor training CodeBERT.\n2.2 Multi-Modal Pre-Trained Models\nThe remarkable success of the pre-trained model\nin NLP has driven the development of multi-modal\npre-trained model that learns implicit alignment\nbetween inputs of different modalities. These mod-\nels are typically learned from bimodal data, such\nas pairs of language-image or pairs of language-\nvideo. For example, ViLBERT (Lu et al., 2019)\nlearns from image caption data, where the model\nlearns by reconstructing categories of masked im-\nage region or masked words given the observed\ninputs, and meanwhile predicting whether the cap-\ntion describes the image content or not. Simi-\nlarly, VideoBERT (Sun et al., 2019) learns from\nlanguage-video data and is trained by video and\ntext masked token prediction. Our work belongs\nto this line of research as we regard NL and PL\nas different modalities. Our method differs from\nprevious works in that the fuels for model train-\ning include not only bimodal data of NL-PL pairs,\nbut larger amounts of unimodal data such as codes\nwithout paired documentations.\nA concurrent work (Kanade et al., 2019) uses\nmasked language modeling and next sentence pre-\ndiction as the objective to train a BERT model on\nPython source codes, where a sentence is a log-\nical code line as deï¬ned by the Python standard.\nIn terms of the pre-training process, CodeBERT\ndiffers from their work in that (1) CodeBERT is\ntrained in a cross-modal style and leverages both\nbimodal NL-PL data and unimodal PL/NL data, (2)\nCodeBERT is pre-trained over six programming\nlanguages, and (3) CodeBERT is trained with a\nnew learning objective based on replaced token\ndetection.\n3 CodeBERT\nWe describe the details about CodeBERT in this\nsection, including the model architecture, the input\nand output representations, the objectives and data\nused for training CodeBERT, and how to ï¬ne-tune\nCodeBERT when it is applied to downstream tasks.\n3.1 Model Architecture\nWe follow BERT (Devlin et al., 2018) and\nRoBERTa (Liu et al., 2019), and use multi-layer\nbidirectional Transformer (Vaswani et al., 2017) as\nthe model architecture of CodeBERT. We will not\nreview the ubiquitous Transformer architecture in\ndetail. We develop CodeBERT by using exactly the\nsame model architecture as RoBERTa-base. The\ntotal number of model parameters is 125M.\n3.2 Input/Output Representations\nIn the pre-training phase, we set the input as the\nconcatenation of two segments with a special sepa-\nrator token, namely [CLS],w1,w2,..wn,[SEP],\nc1,c2,...,c m,[EOS]. One segment is natural lan-\nguage text, and another is code from a certain pro-\ngramming language. [CLS] is a special token in\nfront of the two segments, whose ï¬nal hidden repre-\nsentation is considered as the aggregated sequence\nrepresentation for classiï¬cation or ranking. Follow-\ning the standard way of processing text in Trans-\nformer, we regard a natural language text as a se-\nquence of words, and split it as WordPiece (Wu\net al., 2016). We regard a piece of code as a se-\nquence of tokens.\nThe output of CodeBERT includes (1) contextual\nvector representation of each token, for both natural\nlanguage and code, and (2) the representation of\n[CLS], which works as the aggregated sequence\nrepresentation.\n3.3 Pre-Training Data\nWe train CodeBERT with bothbimodal data, which\nrefers to parallel data of natural language-code\npairs, and unimodal data, which stands for codes\nwithout paired natural language texts and natural\nlanguage without paired codes.\nWe use datapoints from Github repositories,\nwhere each bimodal datapoint is an individual\nfunction with paired documentation, and each uni-\nmodal code is a function without paired documen-\ntation. Speciï¬cally, we use a recent large dataset\nTRAINING DATA bimodal DATA unimodal CODES\nGO 319,256 726,768\nJAVA 500,754 1,569,889\nJAVASCRIPT 143,252 1,857,835\nPHP 662,907 977,821\nPYTHON 458,219 1,156,085\nRUBY 52,905 164,048\nALL 2,137,293 6,452,446\nTable 1: Statistics of the dataset used for training Code-\nBERT.\nprovided by Husain et al. (2019), which includes\n2.1M bimodal datapoints and 6.4Munimodal codes\nacross six programming languages (Python, Java,\nJavaScript, PHP, Ruby, and Go). Data statistics is\nshown in Table 1.2\nThe data comes from publicly available open-\nsource non-fork GitHub repositories and are ï¬l-\ntered with a set of constraints and rules. For ex-\nample, (1) each project should be used by at least\none other project, (2) each documentation is trun-\ncated to the ï¬rst paragraph, (3) documentations\nshorter than three tokens are removed, (4) func-\ntions shorter than three lines are removed, and (5)\nfunction names with substring â€œtestâ€ are removed.\nAn example of the data is given in Figure 1 3.\nFigure 1: An example of the NL-PL pair, where NL is\nthe ï¬rst paragraph (ï¬lled in red) from the documenta-\ntion (dashed line in black) of a function.\n3.4 Pre-Training CodeBERT\nWe describe the two objectives used for training\nCodeBERT here. The ï¬rst objective is masked\nlanguage modeling (MLM), which has proven ef-\nfective in literature (Devlin et al., 2018; Liu et al.,\n2Since we will evaluate on the natural language code\nsearch task, we only use the training data of Husain et al.\n(2019) to train CodeBERT with no access to the dev and test-\ning data.\n3The source of the illustrating example comes from\nhttps://github.com/apache/spark/blob/\n618d6bff71073c8c93501ab7392c3cc579730f0b/\npython/pyspark/rdd.py#L125-L138\n6\nNL Generator\nNL-Code \nDiscriminator\n[ð‘€ð´ð‘†ð¾]ð‘¤\nCodeBERT V2:\nA Pre-trained Model for NL-Code Understanding and Generation \nð‘¤2\nð‘¤3\nð‘¤4\n[ð‘€ð´ð‘†ð¾]ð‘¤\nð‘¤1\nð‘¤2\nð‘¤3\nð‘¤4\nð‘¤5\n[ð‘€ð´ð‘†ð¾]ð‘\nð‘5\nð‘3\nð‘4\n[ð‘€ð´ð‘†ð¾]ð‘\nð‘1\nð‘2\nð‘3\nð‘4\nð‘5\nð‘6\nð‘1\nð‘¤51\nð‘¤2\nð‘¤3\nð‘¤4\nð‘¤5\nð‘29\nð‘5\nð‘3\nð‘4\nð‘162\nð‘1\noriginal\nreplaced\nCode Generator\noriginal\noriginal\noriginal\nreplaced\noriginal\noriginal\noriginal\noriginal\nreplaced\nsample\nsample\nsample\nsample\nFigure 2: An illustration about the replaced token detection objective. Both NL and code generators are language\nmodels, which generate plausible tokens for masked positions based on surrounding contexts. NL-Code discrimi-\nnator is the targeted pre-trained model, which is trained via detecting plausible alternatives tokens sampled from\nNL and PL generators. NL-Code discriminator is used for producing general-purpose representations in the ï¬ne-\ntuning step. Both NL and code generators are thrown out in the ï¬ne-tuning step.\n2019; Sun et al., 2019). We apply masked language\nmodeling on bimodal data of NL-PL pairs. The sec-\nond objective is replaced token detection (RTD),\nwhich further uses a large amount ofunimodal data,\nsuch as codes without paired natural language texts.\nDetailed hyper-parameters for model pre-training\nare given in Appendix B.1.\nObjective #1: Masked Language Modeling\n(MLM) Given a datapoint of NL-PL pair (x =\n{w, c}) as input, where w is a sequence of NL\nwords and c is a sequence of PL tokens, we ï¬rst\nselect a random set of positions for both NL and PL\nto mask out (i.e. mw and mc, respectively), and\nthen replace the selected positions with a special\n[MASK] token. Following Devlin et al. (2018),\n15% of the tokens from x are masked out.\nmw\ni âˆ¼unif{1,|w|}for i= 1to |w| (1)\nmc\ni âˆ¼unif{1,|c|}for i= 1to |c| (2)\nwmasked = REPLACE(w,mw,[MASK]) (3)\ncmasked = REPLACE(c,mc,[MASK]) (4)\nx = w + c (5)\nThe MLM objective is to predict the original to-\nkens which are masked out, formulated as follows,\nwhere pD1 is the discriminator which predicts a\ntoken from a large vocabulary.\nLMLM(Î¸)=\nâˆ‘\niâˆˆmwâˆªmc\nâˆ’log pD1 (xi|wmasked,cmasked)\n(6)\nObjective #2: Replaced Token Detection (RTD)\nIn the MLM objective, only bimodal data (i.e. data-\npoints of NL-PL pairs) is used for training. Here we\npresent the objective of replaced token detection.\nThe RTD objective (Clark et al., 2020) is origi-\nnally developed for efï¬ciently learning pre-trained\nmodel for natural language. We adapt it in our sce-\nnario, with the advantage of using both bimodal\nand unimodal data for training. Speciï¬cally, there\nare two data generators here, an NL generator pGw\nand a PL generator pGc , both for generating plau-\nsible alternatives for the set of randomly masked\npositions.\nË†wi âˆ¼pGw (wi|wmasked) for iâˆˆmw (7)\nË†ci âˆ¼pGc (ci|cmasked) for iâˆˆmc (8)\nwcorrupt = REPLACE(w,mw, Ë†w) (9)\nccorrupt = REPLACE(c,mc,Ë†c) (10)\nxcorrupt = wcorrupt + ccorrupt (11)\nThe discriminator is trained to determine whether\na word is the original one or not, which is a binary\nclassiï¬cation problem. It is worth noting that the\nRTD objective is applied to every position in the\ninput, and it differs from GAN (generative adver-\nsarial network) in that if a generator happens to\nproduce the correct token, the label of that token\nis â€œrealâ€ instead of â€œfakeâ€ (Clark et al., 2020). The\nloss function of RTD with regard to the discrimina-\ntor parameterized by Î¸is given below, whereÎ´(i) is\nan indicator function and pD2 is the discriminator\nthat predicts the probability of the i-th word being\noriginal.\nLRTD(Î¸) =\n|w|+|c|âˆ‘\ni=1\n(\nÎ´(i)log pD2 (xcorrupt,i)+\n(\n1 âˆ’Î´(i)\n)(\n1 âˆ’log pD2 (xcorrupt,i)\n))\n(12)\nÎ´(i) =\n{\n1, if xcorrupt\ni = xi.\n0, otherwise. (13)\nThere are many different ways to implement the\ngenerators. In this work, we implement two ef-\nï¬cient n-gram language models (Jurafsky, 2000)\nwith bidirectional contexts, one for NL and one\nfor PL, and learn them from corresponding uni-\nmodel datapoints, respectively. The approach is\neasily generalized to learn bimodal generators or\nuse more complicated generators like Transformer-\nbased neural architecture learned in a joint manner.\nWe leave these to future work. The PL training data\nis the unimodal codes as shown in Table 1, and the\nNL training data comes from the documentations\nfrom bimodal data. One could easily extend these\ntwo training datasets to larger amount. The ï¬nal\nloss function are given below.\nmin\nÎ¸\nLMLM(Î¸) +LRTD(Î¸) (14)\n3.5 Fine-Tuning CodeBERT\nWe have different settings to use CodeBERT in\ndownstream NL-PL tasks. For example, in natural\nlanguage code search, we feed the input as the\nsame way as the pre-training phase and use the\nrepresentation of [CLS] to measure the semantic\nrelevance between code and natural language query,\nwhile in code-to-text generation, we use an encoder-\ndecoder framework and initialize the encoder of\na generative model with CodeBERT. Details are\ngiven in the experiment section.\n4 Experiment\nWe present empirical results in this section to verify\nthe effectiveness of CodeBERT. We ï¬rst describe\nthe use of CodeBERT in natural language code\nsearch (Â§4.1), in a way that model parameters of\nCodeBERT are ï¬ne-tuned. After that, we present\nthe NL-PL probing task (Â§4.2), and evaluate Code-\nBERT in a zero-shot setting where the parameters\nof CodeBERT are ï¬xed. Finally, we evaluate Code-\nBERT on a generation problem, i.e. code documen-\ntation generation (Â§4.3), and further evaluate on a\nprogramming language which is never seen in the\ntraining phase (Â§4.4).\n4.1 Natural Language Code Search\nGiven a natural language as the input, the objec-\ntive of code search is to ï¬nd the most semantically\nrelated code from a collection of codes. We con-\nduct experiments on the CodeSearchNet corpus\n(Husain et al., 2019) 4. We follow the ofï¬cial evalu-\nation metric to calculate the Mean Reciprocal Rank\n(MRR) for each pair of test data (c, w) over a ï¬xed\nset of 999 distractor codes. We further calculate the\nmacro-average MRR for all languages as an overall\nevaluation metric. It is helpful to note that this met-\nric differs from the AVG metric in the original pa-\nper, where the answer is retrieved from candidates\nfrom all six languages. We ï¬ne-tune a language-\nspeciï¬c model for each programming language 5.\nWe train each model with a binary classiï¬cation\nloss function, where a softmax layer is connected\nto the representation of [CLS]. Both training and\nvalidation datasets are created in a way that posi-\ntive and negative samples are balanced. Negative\nsamples consist of balanced number of instances\nwith randomly replaced NL (i.e. ( c, Ë†w)) and PL\n(i.e. (Ë†c, w)). Detailed hyper-parameters for model\nï¬ne-tuning are given in Appendix B.2.\nModel Comparisons Table 2 shows the results\nof different approaches on the CodeSearchNet cor-\npus. The ï¬rst four rows are reported by Husain\net al. (2019), which are joint embeddings of NL and\nPL (Gu et al., 2018; Mitra et al., 2018). NBOW\nrepresents neural bag-of-words. CNN, BIRNN\nand SELFATT stand for 1D convolultional neu-\nral network (Kim, 2014), bidirectional GRU-based\nrecurrent neural network (Cho et al., 2014), and\nmulti-head attention (Vaswani et al., 2017), respec-\ntively.\nWe report the remaining numbers in Table 2.\nWe train all these pre-trained models by regarding\ncodes as a sequence of tokens. We also continu-\nously train RoBERTa only on codes from Code-\nSearchNet with masked language modeling. Re-\nsults show that CodeBERT consistently performs\n4More details about the dataset are given in Appendix A.\n5We have ï¬ne-tuned a multi-lingual model for six program-\nming languages, but ï¬nd that it performs worse that ï¬ne-tuning\na language-speciï¬c model for each programming language.\nMODEL RUBY JAVASCRIPT GO PYTHON JAVA PHP MA-AVG\nNBOW 0.4285 0.4607 0.6409 0.5809 0.5140 0.4835 0.5181\nCNN 0.2450 0.3523 0.6274 0.5708 0.5270 0.5294 0.4753\nBIRNN 0.0835 0.1530 0.4524 0.3213 0.2865 0.2512 0.2580\nSELF ATT 0.3651 0.4506 0.6809 0.6922 0.5866 0.6011 0.5628\nROBERTA 0.6245 0.6060 0.8204 0.8087 0.6659 0.6576 0.6972\nPT W/ CODE ONLY (INIT =S) 0.5712 0.5557 0.7929 0.7855 0.6567 0.6172 0.6632\nPT W/ CODE ONLY (INIT =R) 0.6612 0.6402 0.8191 0.8438 0.7213 0.6706 0.7260\nCODE BERT (MLM, INIT =S) 0.5695 0.6029 0.8304 0.8261 0.7142 0.6556 0.6998\nCODE BERT (MLM, INIT =R) 0.6898 0.6997 0.8383 0.8647 0.7476 0.6893 0.7549\nCODE BERT (RTD, INIT =R) 0.6414 0.6512 0.8285 0.8263 0.7150 0.6774 0.7233\nCODE BERT (MLM+RTD, INIT =R) 0.6926 0.7059 0.8400 0.8685 0.7484 0.7062 0.7603\nTable 2: Results on natural language code retrieval. Baselines include four joint embeddings (ï¬rst group) of NL\nand PL, RoBERTa, and RoBERTa which is continuously trained with masked language modeling on codes only\n(second group). PT stands for pre-training. We train CodeBERT (third group) with different settings, including\nusing different initialization (from scratch (INIT =S) or initialized with the parameters of RoBERTa (INIT =R)) and\nusing different learning objectives (MLM, RTD, or the combination of both).\nbetter than RoBERTa and the model pre-trained\nwith code only. CodeBERT (MLM) learned from\nscratch performs better than RoBERTa. Unsur-\nprisingly, initializing CodeBERT with RoBERTa\nimproves the performance 6.\n4.2 NL-PL Probing\nIn the previous subsection, we show the empirical\neffectiveness of CodeBERT in a setting that the\nparameters of CodeBERT are ï¬ne-tuned in down-\nstream tasks. In this subsection, we further inves-\ntigate what type of knowledge is learned in Code-\nBERT without modifying the parameters.\nTask Formulation and Data ConstructionFol-\nlowing the probing experiments in NLP (Petroni\net al., 2019; Talmor et al., 2019), we study NL-\nPL probing here. Since there is no existing work\ntowards this goal, we formulate the problem of\nNL-PL probing and create the dataset by ourselves.\nGiven an NL-PL pair ( c, w), the goal of NL-PL\nprobing is to test modelâ€™s ability to correctly pre-\ndict/recover the masked token of interest (either a\ncode token ci or word token wj) among distractors.\nThere are two major types of distractors: one is the\nwhole target vocabulary used for the masked lan-\nguage modeling objective (Petroni et al., 2019), and\nanother one has fewer candidates which are ï¬lter or\ncurated based on expertsâ€™ understanding about the\nability to be tested (Talmor et al., 2019). We follow\nthe second direction and formulate NL-PL probing\nas a multi-choice question answering task, where\nthe question is cloze-style in which a certain token\n6We further give a learning curve of different pre-trained\nmodels in the ï¬ne-tuning process in Appendix C.\nis replaced by [MASK] and distractor candidate\nanswers are curated based on our expertise.\nSpeciï¬cally, we evaluate on the NL side and PL\nside, respectively. To ease the effort of data col-\nlection, we collect data automatically from NL-PL\npairs in both validation and testing sets of Code-\nSearchNet, both of which are unseen in the pre-\ntraining phase. To evaluate on the NL side, we\nselect NL-PL pairs whose NL documentations in-\nclude one of the six keywords (max, maximize, min,\nminimize, less, greater), and group them to four\ncandidates by merging ï¬rst two keywords and the\nmiddle two keywords. The task is to ask pre-trained\nmodels to select the correct one instead of three\nother distractors. That is to say, the input in this\nsetting includes the complete code and a masked\nNL documentation. The goal is to select the correct\nanswer from four candidates. For the PL side, we\nselect codes containing keywordsmax and min, and\nformulate the task as a two-choice answer selection\nproblem. Here, the input includes complete NL\ndocumentation and a masked PL code, and the goal\nis to select the correct answer from two candidates.\nSince code completion is an important scenario,\nwe would like to test modelâ€™s ability in predicting\nthe correct token merely based on preceding PL\ncontexts. Therefore, we add an additional setting\nfor PL side, where the input includes the complete\nNL documentation and preceding PL codes. Data\nstatistics is given in the top two rows in Table 3.\nModel Comparisons Results are given in Table\n3. We report accuracy, namely the number of cor-\nrectly predicted instances over the number of all\ninstances, for each programming language. Since\nRUBY JAVASCRIPT GO PYTHON JAVA PHP ALL\nNUMBER OF DATAPOINTS FOR PROBING\nPL (2 CHOICES ) 38 272 152 1,264 482 407 2,615\nNL (4 CHOICES ) 20 65 159 216 323 73 856\nPL PROBING\nROBERTA 73.68 63.97 72.37 59.18 59.96 69.78 62.45\nPRE-TRAIN W / CODE ONLY 71.05 77.94 89.47 70.41 70.12 82.31 74.11\nCODE BERT (MLM) 86.84 86.40 90.79 82.20 90.46 88.21 85.66\nPL PROBING WITH PRECEDING CONTEXT ONLY\nROBERTA 73.68 53.31 51.32 55.14 42.32 52.58 52.24\nPRE-TRAIN W / CODE ONLY 63.16 48.53 61.84 56.25 58.51 58.97 56.71\nCODE BERT (MLM) 65.79 50.74 59.21 62.03 54.98 59.95 59.12\nNL PROBING\nROBERTA 50.00 72.31 54.72 61.57 61.61 65.75 61.21\nPRE-TRAIN W / CODE ONLY 55.00 67.69 60.38 68.06 65.02 68.49 65.19\nCODE BERT (MLM) 65.00 89.23 66.67 76.85 73.37 79.45 74.53\nTable 3: Statistics of the data for NL-PL probing and the performance of different pre-trained models. Accuracies\n(%) are reported. Best results in each group are in bold.\ndatasets in different programming languages are\nextremely unbalanced, we report the accumulated\nmetric with the same way. We use CodeBERT\n(MLM) here because its output layer naturally ï¬ts\nfor probing. Results show that CodeBERT per-\nforms better than baselines on almost all languages\non both NL and PL probing. The numbers with\nonly preceding contexts are lower than that with\nbidirectional contexts, which suggests that code\ncompletion is challenging. We leave it as a future\nwork.\nWe further give a case study on PL-NL probing.\nWe mask NL token and PL token separately, and\nreport the predicted probabilities of RoBERTa and\nCodeBERT. Figure 3 illustrates the example of a\npython code7. We can see that RoBERTa fails in\nboth cases, whereas CodeBERT makes the correct\nprediction in both NL and PL settings.\n4.3 Code Documentation Generation\nAlthough the pre-training objective of Code-\nBERT does not include generation-based objectives\n(Lewis et al., 2019), we would like to investigate\nto what extent does CodeBERT perform on gen-\neration tasks. Speciï¬cally, we study code-to-NL\ngeneration, and report results for the documenta-\ntion generation task on CodeSearchNet Corpus in\nsix programming languages. Since the generated\ndocumentations are short and higher order n-grams\nmay not overlap, we remedy this problem by using\nsmoothed BLEU score (Lin and Och, 2004).\n7The example comes from https://\ngithub.com/peri-source/peri/blob/\n61beed5deaaf978ab31ed716e8470d86ba639867/\nperi/comp/psfcalc.py#L994-L1002\ndef vec_to_halfvec(vec):\nd = vec[1:] - vec[:-1]\nif ((d/d.mean()).std() > 1e-14) or (d.mean() < 0):\nraise ValueError('vec must be np.arange() in increasing order')\ndx = d.mean()\nlowest = np.abs(vec). min ()\nhighest = np.abs(vec).max()\nreturn np.arange(lowest, highest + 0.1*dx, dx).astype(vec.dtype)\n\"Transforms a vector np.arange(-N, M, dx) to np.arange( min (|vec|), \nmax(N,M),dx)]\"\nmasked NL token\nmasked PL token\nmax min less greater\nNL\nRoberta 96.24% 3.73% 0.02% 0.01%\nCodeBERT (MLM) 39.38% 60.60% 0.02% 0.0003%\nPL\nRoberta 95.85% 4.15% - -\nCodeBERT (MLM) 0.001% 99.999% - -\nFigure 3: Case study on python language. Masked to-\nkens in NL (in blue) and PL (in yellow) are separately\napplied. Predicted probabilities of RoBERTa and Code-\nBERT are given.\nModel Comparisons We compare our model\nwith several baselines, including a RNN-based\nmodel with attention mechanism (Sutskever et al.,\n2014), the Transformer (Vaswani et al., 2017),\nRoBERTa and the model pre-trained on code only.\nTo demonstrate the effectiveness of CodeBERT\non code-to-NL generation tasks, we adopt various\npre-trained models as encoders and keep the hyper-\nparameters consistent. Detailed hyper-parameters\nare given in Appendix B.3.\nTable 4 shows the results with different mod-\nels for the code-to-documentation generation task.\nAs we can see, models pre-trained on program-\nming language outperform RoBERTa, which illus-\ntrates that pre-trainning models on programming\nMODEL RUBY JAVASCRIPT GO PYTHON JAVA PHP OVERALL\nSEQ 2SEQ 9.64 10.21 13.98 15.93 15.09 21.08 14.32\nTRANSFORMER 11.18 11.59 16.38 15.81 16.26 22.12 15.56\nROBERTA 11.17 11.90 17.72 18.14 16.47 24.02 16.57\nPRE -TRAIN W / CODE ONLY 11.91 13.99 17.78 18.58 17.50 24.34 17.35\nCODE BERT ( RTD ) 11.42 13.27 17.53 18.29 17.35 24.10 17.00\nCODE BERT ( MLM ) 11.57 14.41 17.78 18.77 17.38 24.85 17.46\nCODE BERT ( RTD +MLM ) 12.16 14.90 18.07 19.06 17.65 25.16 17.83\nTable 4: Results on Code-to-Documentation generation, evaluated with smoothed BLEU-4 score.\nlanguage could improve code-to-NL generation.\nBesides, results in the Table 4 show that CodeBERT\npre-trained with RTD and MLM objectives brings\na gain of 1.3 BLEU score over RoBERTa overall\nand achieve the state-of-the-art performance8.\n4.4 Generalization to Programming\nLanguages NOT in Pre-training\nWe would like to evaluate CodeBERT on the pro-\ngramming language which is never seen in the pre-\ntraining step. To this end, we study the task of gen-\nerating a natural language summary of a C# code\nsnippet. We conduct experiments on the dataset\nof CodeNN (Iyer et al., 2016)9, which consists of\n66,015 pairs of questions and answers automati-\ncally collected from StackOverï¬‚ow. This dataset\nis challenging since the scale of dataset is orders\nof magnitude smaller than CodeSearchNet Corpus.\nWe evaluate models using smoothed BLEU-4 score\nand use the same evaluation scripts as Iyer et al.\n(2016).\nMODEL BLEU\nMOSES (K OEHN ET AL ., 2007) 11.57\nIR 13.66\nSUM-NN (R USH ET AL ., 2015) 19.31\n2-LAYER BILSTM 19.78\nTRANSFORMER (VASWANI ET AL ., 2017) 19.68\nTREE LSTM (T AI ET AL ., 2015) 20.11\nCODE NN (I YER ET AL ., 2016) 20.53\nCODE 2SEQ (ALON ET AL ., 2019) 23.04\nROBERTA 19.81\nPRE -TRAIN W / CODE ONLY 20.65\nCODE BERT (RTD) 22.14\nCODE BERT (MLM) 22.32\nCODE BERT (MLM+RTD) 22.36\nTable 5: Code-to-NL generation on C# language.\nModel Comparisons Table 5 shows that our\nmodel with MLM and RTD pre-training objectives\nachieves 22.36 BLEU score and improves by 2.55\npoints over RoBERTa, which illustrates CodeBERT\n8We further give some output examples in Appendix E.\n9https://github.com/sriniiyer/codenn\ncould generalize better to other programming lan-\nguage which is never seen in the pre-training step.\nHowever, our model achieve slightly lower results\nthan code2seq (Alon et al., 2019). The main reason\ncould be that code2seq makes use of compositional\npaths in its abstract syntax tree (AST) while Code-\nBERT only takes original code as the input. We\nhave trained a version of CodeBERT by traversing\nthe tree structure of AST following a certain order,\nbut applying that model does not bring improve-\nments on generation tasks. This shows a potential\ndirection to improve CodeBERT by incorporating\nAST.\n5 Conclusion\nIn this paper, we present CodeBERT, which to the\nbest of our knowledge is the ï¬rst large bimodal\npre-trained model for natural language and pro-\ngramming language. We train CodeBERT on both\nbimodal and unimodal data, and show that ï¬ne-\ntuning CodeBERT achieves state-of-the-art perfor-\nmance on downstream tasks including natural lan-\nguage code search and code-to-documentation gen-\neration. To further investigate the knowledge em-\nbodied in pre-trained models, we formulate the task\nof NL-PL probing and create a dataset for probing.\nWe regard the probing task as a cloze-style answer\nselection problem, and curate distractors for both\nNL and PL parts. Results show that, with model\nparameters ï¬xed, CodeBERT performs better than\nRoBERTa and a continuously trained model using\ncodes only.\nThere are many potential directions for further\nresearch on this ï¬eld. First, one could learn better\ngenerators with bimodal evidence or more compli-\ncated neural architecture to improve the replaced to-\nken detection objective. Second, the loss functions\nof CodeBERT mainly target on NL-PL understand-\ning tasks. Although CodeBERT achieves strong\nBLEU scores on code-to-documentation genera-\ntion, the CodeBERT itself could be further im-\nproved by generation-related learning objectives.\nHow to successfully incorporate AST into the pre-\ntraining step is also an attractive direction. Third,\nwe plan to apply CodeBERT to more NL-PL re-\nlated tasks, and extend it to more programming\nlanguages. Flexible and powerful domain/language\nadaptation methods are necessary to generalize\nwell.\nAcknowledgments\nXiaocheng Feng is the corresponding author of this\nwork. We thank the anonymous reviewers for their\ninsightful comments. Zhangyin Feng, Xiaocheng\nFeng, Bing Qin and Ting Liu are supported by the\nNational Key R&D Program of China via grant\n2018YFB1005103 and National Natural Science\nFoundation of China (NSFC) via grant 61632011\nand 61772156.\nReferences\nUri Alon, Shaked Brody, Omer Levy, and Eran Yahav.\n2019. code2seq: Generating sequences from struc-\ntured representations of code. International Confer-\nenceon Learning Representations.\nKyunghyun Cho, Bart Van Merri Â¨enboer, Caglar Gul-\ncehre, Dzmitry Bahdanau, Fethi Bougares, Holger\nSchwenk, and Yoshua Bengio. 2014. Learning\nphrase representations using rnn encoder-decoder\nfor statistical machine translation. arXiv preprint\narXiv:1406.1078.\nKevin Clark, Minh-Thang Luong, Quoc V . Le, and\nChristopher D. Manning. 2020. {ELECTRA}: Pre-\ntraining text encoders as discriminators rather than\ngenerators. In International Conference on Learn-\ning Representations.\nJacob Devlin, Ming-Wei Chang, Kenton Lee, and\nKristina Toutanova. 2018. Bert: Pre-training of deep\nbidirectional transformers for language understand-\ning. arXiv preprint arXiv:1810.04805.\nXiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018.\nDeep code search. In 2018 IEEE/ACM 40th Interna-\ntional Conference on Software Engineering (ICSE),\npages 933â€“944. IEEE.\nHamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis\nAllamanis, and Marc Brockschmidt. 2019. Code-\nsearchnet challenge: Evaluating the state of seman-\ntic code search. arXiv preprint arXiv:1909.09436.\nSrinivasan Iyer, Ioannis Konstas, Alvin Cheung, and\nLuke Zettlemoyer. 2016. Summarizing source code\nusing a neural attention model. In Proceedings\nof the 54th Annual Meeting of the Association for\nComputational Linguistics (Volume 1: Long Papers),\npages 2073â€“2083.\nDan Jurafsky. 2000. Speech & language processing.\nPearson Education India.\nAditya Kanade, Petros Maniatis, Gogul Balakrish-\nnan, and Kensen Shi. 2019. Pre-trained contex-\ntual embedding of source code. arXiv preprint\narXiv:2001.00059.\nYoon Kim. 2014. Convolutional neural net-\nworks for sentence classiï¬cation. arXiv preprint\narXiv:1408.5882.\nPhilipp Koehn, Hieu Hoang, Alexandra Birch, Chris\nCallison-Burch, Marcello Federico, Nicola Bertoldi,\nBrooke Cowan, Wade Shen, Christine Moran,\nRichard Zens, et al. 2007. Moses: Open source\ntoolkit for statistical machine translation. In Pro-\nceedings of the 45th annual meeting of the associ-\nation for computational linguistics companion vol-\nume proceedings of the demo and poster sessions,\npages 177â€“180.\nMike Lewis, Yinhan Liu, Naman Goyal, Mar-\njan Ghazvininejad, Abdelrahman Mohamed, Omer\nLevy, Ves Stoyanov, and Luke Zettlemoyer. 2019.\nBart: Denoising sequence-to-sequence pre-training\nfor natural language generation, translation, and\ncomprehension. arXiv preprint arXiv:1910.13461.\nChin-Yew Lin and Franz Josef Och. 2004. Orange: a\nmethod for evaluating automatic evaluation metrics\nfor machine translation. In Proceedings of the 20th\ninternational conference on Computational Linguis-\ntics, page 501. Association for Computational Lin-\nguistics.\nYinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Man-\ndar Joshi, Danqi Chen, Omer Levy, Mike Lewis,\nLuke Zettlemoyer, and Veselin Stoyanov. 2019.\nRoberta: A robustly optimized bert pretraining ap-\nproach. arXiv preprint arXiv:1907.11692.\nJiasen Lu, Dhruv Batra, Devi Parikh, and Stefan\nLee. 2019. Vilbert: Pretraining task-agnostic visi-\nolinguistic representations for vision-and-language\ntasks. In Advances in Neural Information Process-\ning Systems, pages 13â€“23.\nBhaskar Mitra, Nick Craswell, et al. 2018. An intro-\nduction to neural information retrieval. Foundations\nand TrendsRâƒin Information Retrieval, 13(1):1â€“126.\nMatthew E Peters, Mark Neumann, Mohit Iyyer, Matt\nGardner, Christopher Clark, Kenton Lee, and Luke\nZettlemoyer. 2018. Deep contextualized word repre-\nsentations. arXiv preprint arXiv:1802.05365.\nFabio Petroni, Tim Rockt Â¨aschel, Patrick Lewis, Anton\nBakhtin, Yuxiang Wu, Alexander H Miller, and Se-\nbastian Riedel. 2019. Language models as knowl-\nedge bases? arXiv preprint arXiv:1909.01066.\nTelmo Pires, Eva Schlinger, and Dan Garrette. 2019.\nHow multilingual is multilingual bert? arXiv\npreprint arXiv:1906.01502.\nAlec Radford, Karthik Narasimhan, Tim Salimans,\nand Ilya Sutskever. 2018. Improving language\nunderstanding by generative pre-training. URL\nhttps://s3-us-west-2. amazonaws. com/openai-\nassets/researchcovers/languageunsupervised/language\nunderstanding paper. pdf.\nColin Raffel, Noam Shazeer, Adam Roberts, Katherine\nLee, Sharan Narang, Michael Matena, Yanqi Zhou,\nWei Li, and Peter J Liu. 2019. Exploring the limits\nof transfer learning with a uniï¬ed text-to-text trans-\nformer. arXiv preprint arXiv:1910.10683.\nAlexander M Rush, Sumit Chopra, and Jason We-\nston. 2015. A neural attention model for ab-\nstractive sentence summarization. arXiv preprint\narXiv:1509.00685.\nChen Sun, Austin Myers, Carl V ondrick, Kevin Mur-\nphy, and Cordelia Schmid. 2019. Videobert: A joint\nmodel for video and language representation learn-\ning. arXiv preprint arXiv:1904.01766.\nIlya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.\nSequence to sequence learning with neural networks.\nIn Advances in neural information processing sys-\ntems, pages 3104â€“3112.\nKai Sheng Tai, Richard Socher, and Christopher D\nManning. 2015. Improved semantic representations\nfrom tree-structured long short-term memory net-\nworks. arXiv preprint arXiv:1503.00075.\nAlon Talmor, Yanai Elazar, Yoav Goldberg, and\nJonathan Berant. 2019. olmpicsâ€“on what lan-\nguage model pre-training captures. arXiv preprint\narXiv:1912.13283.\nAshish Vaswani, Noam Shazeer, Niki Parmar, Jakob\nUszkoreit, Llion Jones, Aidan N Gomez, Åukasz\nKaiser, and Illia Polosukhin. 2017. Attention is all\nyou need. In Advances in neural information pro-\ncessing systems, pages 5998â€“6008.\nYonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V\nLe, Mohammad Norouzi, Wolfgang Macherey,\nMaxim Krikun, Yuan Cao, Qin Gao, Klaus\nMacherey, et al. 2016. Googleâ€™s neural machine\ntranslation system: Bridging the gap between hu-\nman and machine translation. arXiv preprint\narXiv:1609.08144.\nZhilin Yang, Zihang Dai, Yiming Yang, Jaime Car-\nbonell, Ruslan Salakhutdinov, and Quoc V Le.\n2019. Xlnet: Generalized autoregressive pretrain-\ning for language understanding. arXiv preprint\narXiv:1906.08237.\nA Data Statistic\nData statistics of the training/validation/testing data\nsplits for six programming languages are given in\nTable 6.\nCODE SEARCH TRAINING DEV TESTING\nGO 635,635 28,483 14,291\nJAVA 908,886 30,655 26,909\nJAVASCRIPT 247,773 16,505 6,483\nPHP 1,047,406 52,029 28,391\nPYTHON 824,342 46,213 22,176\nRUBY 97,580 4,417 2,279\nTable 6: Data statistics about the CodeSearchNet Cor-\npus for natural language code search.\nB Train Details\nB.1 Pre-training\nWe train CodeBERT on one NVIDIA DGX-2 ma-\nchine using FP16. It combines 16 interconnected\nNVIDIA Tesla V100 with 32GB memory. We use\nthe following set of hyper-parameters to train mod-\nels: batchsize is 2,048 and learning rate is 5e-4. We\nuse Adam to update the parameters and set the num-\nber of warmup steps as 10K. We set the max length\nas 512 and the max training step is 100K. Training\n1,000 batches of data costs 600 minutes with MLM\nobjective, 120 minutes with RTD objective.\nB.2 CodeSearch\nIn the ï¬ne-turning step, we set the learning rate as\n1e-5, the batch size as 64, the max sequence length\nas 200 and the max ï¬ne-tuning epoch as 8. As the\nsame with pre-training, We use Adam to update the\nparameters. We choose the model performed best\non the development set, and use that to evaluate on\nthe test set.\nB.3 Code Summarization on Six\nProgramming Languages\nWe use Transformer with 6 layers, 768 dimensional\nhidden states and 12 attention heads as our decoder\nin all settings. We set the max length of input\nand inference as 256 and 64, respectively. We use\nthe Adam optimizer to update model parameters.\nThe learning rate and the batch size are 5e-5 and\n64, respectively. We tune hyperparameters and\nperform early stopping on the development set.\nB.4 Code Summarization on C#\nSince state-of-the-art methods use RNN as their de-\ncoder, we choose a 2-layer GRU with an attention\nmechanism as our decoder for a comparison. We\nï¬ne-tune models using a grid search with the fol-\nlowing set of hyper-parameters: batchsize is in{32,\n64}and learning rate is in {2e-5, 5e-5}. We report\nthe number when models achieve best performance\non the development set.\nC Learning Curve of CodeSearch\nFrom Figure 4, we can see that CodeBERT per-\nforms better at the early stage, which reï¬‚ects that\nCodeBERT provides good initialization for learn-\ning downstream tasks.\n1 2 3 4 5 6 7 8\nThe Number of Epoch\n84.5\n85.0\n85.5\n86.0\n86.5\n87.0\n87.5\n88.0\n88.5Dev Accuracy of Python\nRoberta\nCodeBERT\nPre-train w/ code only\n1 2 3 4 5 6 7 8\nThe Number of Epoch\n79.5\n80.0\n80.5\n81.0\n81.5\n82.0\n82.5\n83.0Dev Accuracy of Java\nRoberta\nCodeBERT\nPre-train w/ code only\nFigure 4: Learning curve of different pre-trained mod-\nels in the ï¬ne-tuning step. We show results on Python\nand Java.\nD Late Fusion\nIn section Â§4.1 , we show that CodeBERT per-\nforms well in the setting where natural languages\nand codes have early interactions. Here, we in-\nvestigate whether CodeBERT is good at working\nas a uniï¬ed encoder. We apply CodeBERT for\nnatural language code search in a later fusion set-\nting, where CodeBERT ï¬rst encodes NL and PL\nseparately, and then calculates the similarity by dot-\nproduct. In this way, code search is equivalent to\nï¬nd the nearest codes in the shared vector space.\nThis scenario also facilitates the use of CodeBERT\nin an online system, where the representations of\ncodes are calculated in advance. In the runtime, a\nsystem only needs to compute the representation\nof NL and vector-based dot-product.\nWe ï¬ne-tune CodeBERT with the following ob-\njective, which maximizes the dot-product of the\nground truth while minimizing the dot-product of\ndistractors.\nâˆ’1\nN\nâˆ‘\ni\nlog\n( exp\n(\nEnc(ci)âŠºEnc(wi)\n)\nâˆ‘\nj exp\n(\nEnc(cj)âŠºEnc(wi)\n)\n)\n(15)\nResults are given in Table 7. We just do this\nsetting on two languages with a relatively small\namount of data.\nWe can see that CodeBERT performs better than\nRoBERTa and the model pre-trained with codes\nMODEL RUBY GO\nROBERTA 0.0043 0.0030\nPRE-TRAIN W / CODE ONLY 0.1648 0.4179\nCODE BERT 0.6870 0.8372\nTable 7: Results on natural language code search by\nlate fusion.\nonly. And late fusion performs comparable with\nthe standard way. Whatâ€™s more, late fusion is more\nefï¬cient and this setting could be used in an online\nsystem.\nE Case Study\nTo qualitatively analyze the effectiveness of Code-\nBERT, we give some cases for code search and\ncode documentation generation tasks.\nConsidering the limited space, we only give the\ntop2 results of the query for python programming\nlanguage. As show in Figure 5, search results are\nvery relevant with query.\nFigure 6 and Figure 7 show the outputs with\ndifferent models for the code documentation gen-\neration task. As we can see, CodeBERT performs\nbetter than all baselines.\nFigure 5: Python CodeSearch example. The results are searched from 1,156,085 python code data. We only give\nthe top2 results because space is limited.\nFigure 6: Java code documentation generation output example.\nFigure 7: Python code documentation generation output example.",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.7842699885368347
    },
    {
      "name": "Security token",
      "score": 0.6552194356918335
    },
    {
      "name": "Transformer",
      "score": 0.6420082449913025
    },
    {
      "name": "Natural language processing",
      "score": 0.5916488170623779
    },
    {
      "name": "Documentation",
      "score": 0.5855900049209595
    },
    {
      "name": "Code (set theory)",
      "score": 0.5575430393218994
    },
    {
      "name": "Artificial intelligence",
      "score": 0.554959237575531
    },
    {
      "name": "Natural language",
      "score": 0.5481600165367126
    },
    {
      "name": "Task (project management)",
      "score": 0.5319236516952515
    },
    {
      "name": "Language model",
      "score": 0.528294563293457
    },
    {
      "name": "Programming language",
      "score": 0.5024054050445557
    },
    {
      "name": "Natural language understanding",
      "score": 0.422769695520401
    },
    {
      "name": "Voltage",
      "score": 0.10364046692848206
    },
    {
      "name": "Physics",
      "score": 0.0
    },
    {
      "name": "Economics",
      "score": 0.0
    },
    {
      "name": "Set (abstract data type)",
      "score": 0.0
    },
    {
      "name": "Management",
      "score": 0.0
    },
    {
      "name": "Computer security",
      "score": 0.0
    },
    {
      "name": "Quantum mechanics",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I204983213",
      "name": "Harbin Institute of Technology",
      "country": "CN"
    },
    {
      "id": "https://openalex.org/I4210164937",
      "name": "Microsoft Research (United Kingdom)",
      "country": "GB"
    }
  ],
  "cited_by": 242
}