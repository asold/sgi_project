{
  "title": "A Predicate Transformer for Choreographies",
  "url": "https://openalex.org/W4226047741",
  "year": 2022,
  "authors": [
    {
      "id": "https://openalex.org/A4222344371",
      "name": "Sung-Shik Jongmans",
      "affiliations": [
        "Open University of the Netherlands",
        "Centrum Wiskunde & Informatica"
      ]
    },
    {
      "id": "https://openalex.org/A2755010511",
      "name": "Petra van den Bos",
      "affiliations": [
        "University of Twente"
      ]
    },
    {
      "id": "https://openalex.org/A4222344371",
      "name": "Sung-Shik Jongmans",
      "affiliations": []
    },
    {
      "id": "https://openalex.org/A2755010511",
      "name": "Petra van den Bos",
      "affiliations": []
    }
  ],
  "references": [
    "https://openalex.org/W2991353706",
    "https://openalex.org/W2134200739",
    "https://openalex.org/W4239234361",
    "https://openalex.org/W2746792245",
    "https://openalex.org/W1611165480",
    "https://openalex.org/W2125398300",
    "https://openalex.org/W2886908675",
    "https://openalex.org/W1780016311",
    "https://openalex.org/W1991621238",
    "https://openalex.org/W2114877704",
    "https://openalex.org/W4232794147",
    "https://openalex.org/W3187321874",
    "https://openalex.org/W2046488919",
    "https://openalex.org/W2541923024",
    "https://openalex.org/W2289301276",
    "https://openalex.org/W3037922846",
    "https://openalex.org/W2564875105",
    "https://openalex.org/W3101043415",
    "https://openalex.org/W2962520317",
    "https://openalex.org/W2769566850",
    "https://openalex.org/W3132401016",
    "https://openalex.org/W4240807674",
    "https://openalex.org/W2119992090",
    "https://openalex.org/W2003314287",
    "https://openalex.org/W2144531585",
    "https://openalex.org/W2797038171",
    "https://openalex.org/W1985161650",
    "https://openalex.org/W2948961668",
    "https://openalex.org/W2994908035",
    "https://openalex.org/W2117694222",
    "https://openalex.org/W1784055113",
    "https://openalex.org/W3008328790",
    "https://openalex.org/W7043434818",
    "https://openalex.org/W2122261906",
    "https://openalex.org/W2054364230",
    "https://openalex.org/W4226047741",
    "https://openalex.org/W2023489866",
    "https://openalex.org/W2342200509",
    "https://openalex.org/W2787969571",
    "https://openalex.org/W2132761501",
    "https://openalex.org/W2025827262",
    "https://openalex.org/W2963418352",
    "https://openalex.org/W2296390127",
    "https://openalex.org/W2171592977",
    "https://openalex.org/W2460202555",
    "https://openalex.org/W3107309644",
    "https://openalex.org/W2075426808",
    "https://openalex.org/W3098996028",
    "https://openalex.org/W3005258739",
    "https://openalex.org/W3198885441",
    "https://openalex.org/W2139204893",
    "https://openalex.org/W4247441475"
  ],
  "abstract": "Abstract Construction and analysis of distributed systems is difficult; choreographic programming is a deadlock-freedom-by-construction approach to simplify it. In this paper, we present a new theory of choreographic programming. It supports for the first time: construction of distributed systems that require decentralised decision making (i.e., if/while-statements with multiparty conditions); analysis of distributed systems to provide not only deadlock freedom but also functional correctness (i.e., pre/postcondition reasoning). Both contributions are enabled by a single new technique, namely a predicate transformer for choreographies.",
  "full_text": "A Predicate Transformer for Choreographies\nComputing Preconditions in Choreographic Programming\nSung-Shik Jongmans1;2(\f)\n and Petra van den Bos3\n1 Department of Computer Science, Open University, Heerlen, the Netherlands\n2 CWI, Amsterdam, the Netherlands\n3 Formal Methods and Tools Group, University of Twente, Enschede, the Netherlands\nAbstract. Construction and analysis of distributed systems is diﬃcult;\nchoreographic programming is a deadlock-freedom-by-construction ap-\nproach to simplify it. In this paper, we present a new theory of chore-\nographic programming. It supports for the ﬁrst time: construction of\ndistributed systems that require decentralised decision making (i.e., if/\nwhile-statements with multiparty conditions); analysis of distributed sys-\ntemstoprovidenotonlydeadlockfreedombutalsofunctionalcorrectness\n(i.e., pre/postcondition reasoning). Both contributions are enabled by a\nsingle new technique, namely a predicate transformer for choreographies.\n1 Introduction\nConstruction and analysis of distributed systems that consist of message passing\nprocesses is hard. Typical challenges include providingdeadlock freedom(i.e., the\nprocesses never get stuck) andfunctional correctness (i.e., the processes com-\npute the intended outcome).Choreographic programming[8,9,10] is a deadlock-\nfreedom-by-construction approach to make implementation and veriﬁcation of\ndistributed systems easier. In this paper, to address two limitations of existing\ntheories, we present a new theory of choreographic programming. It supports for\nthe ﬁrst time: construction of distributed systems that requiredecentralised\ndecision making; analysis of distributed systems to provide not only deadlock\nfreedom but alsofunctional correctness.\n1.1 Background: Choreographic Programming by Example\nTo explain choreographic programming, consider a distributed system in which\ntwo processes enactroles Client and Server. First, a username and password are\ncommunicated from Client to Server. Next, Server checks Client’s credentials and\ninforms Client about the outcome: if authentication succeeded, the execution\ncontinues; if it failed, it ends. We construct and analyse this system as follows:\n1.Initially, we write a global programG (“the choreography”); it prescribes\nthe behaviour of all roles, collectively, from their shared perspective.\nC:\"foo\"_S:x ; C:123_S:y ; if S:auth(x,y) (S:SUCC_C ; G0) (S:FAIL_C)\nc⃝ The Author(s) 2022\nI. Sergey (Ed.): ESOP 2022, LNCS 13240, pp. 520–547, 2022.\nhttps://doi.org/10.1007/978-3-030-99336-8_19\nall construction/analysis\nactivities happen here (manual)\nall deployment/execution\nactivities happen there (automatic)\nG\nL1 L2 ···Ln\nglobal program\nprojection\nlocal programs\nFig.1: Workﬂow of choreographic programming\nIn this notation,p:e_q:y prescribes a value communication to share data\nfrom rolep to roleq: expressione is evaluated atp, sent atp, received atq,\nand stored in variabley at q. Similarly,p:`_q prescribes a label communi-\ncation to share decisions: label` is actively selected atp (“internal choice”),\nsent atp, received atq, and passively branched on atq (“external choice”).\nFurthermore,G1 ; G2 andif r:eG1 G2 prescribe a sequence and a conditional\nchoice (i.e., ife is evaluated totrue at r, thenG1 is executed, or elseG2).\nNow, informally, the ﬁrst theorem of choreographic programming is this:\nTheorem 1(Deadlock Freedom). Every global program is deadlock-free.\n2.Subsequently, we decompose global program G into local programs LC\nand LS (“the processes”), using aprojection function; every local program\nprescribes the behaviour of one role, individually, from its own perspective.\nClient: CS!\"foo\" ; CS!123 ; SC?{SUCC : L0\nC ;FAIL : skip}\nServer: CS?x ; CS?y ; if S:auth(x,y) (SC!SUCC ; L0\nS) (SC!FAIL)\nIn this notation,pq!eand pq?yprescribe a send and a receive of a value from\npto q. Similarly,pq!`and pq?{`i : Li}i2I prescribe a send and a receive of a\nlabel (i.e., if`j is received for somej ∈I, thenLj is executed).\nNow, informally, the second theorem of choreographic programming is this:\nTheorem 2(Operational Equivalence). Every well-formed global pro-\ngram is operationally equivalent to the parallel composition of its projections.\n“Well-formedness” is a syntactic condition on global programs; we discuss it\nin more detail later. Here, we just claim thatGabove is indeed well-formed.\n3.Finally, we compose local programs LC and LS in parallel (“the distributed\nsystem”), by deploying them concurrently, and by executing them at their\nown pace; as they run,LC and LS send and receive messages as prescribed.\nNow, Thm.1 and Thm.2 together entail that LC and LS are deadlock-free,\nby construction, without extra analysis. Figure1 summarises the workﬂow.\n1.2 Related Work: State of the Art & Open Problems\nEarly work on choreographic programming was presented by Carbone et al.\n[8,9] (using binary session types [34]) and by Carbone and Montesi [10] (using\nA Predicate T ransformer for Choreographies 521\nmultiparty session types [35]); substantial progress has been made since. For in-\nstance, Montesi and Yoshida developed a theory of compositional choreographic\nprogramming that supports open distributed systems [42]; Carbone et al. stud-\nied connections between choreographic programming and linear logic [11,12,7];\nDalla Preda et al. combined choreographic programming with dynamic adapta-\ntion [48,46,47]; Cruz-Filipe and Montesi developed a minimal Turing-complete\nlanguage of global programs [16,19]; Cruz-Filipe et al. presented a technique to\nextract global programs from families of local programs (“choreography extrac-\ntion”) [14]; and recently, Giallorenzo et al. studied a correspondence between\nchoreographic programming and multitier languages [29]. Other work on chore-\nographic programming includes results on case studies [15], procedural abstrac-\ntions [18], asynchronous communication [17], polyadic communication [20,31],\nimplementability [28], and formalisation/mechanisation in Coq [21,22]. Further-\nmore, theoretical developments are supported in practice by several tools, in-\ncluding Chor [10], AIOCJ [48,47], and Choral [29].\nHowever, all publications cited above have two limitations:\n1.Regarding the constructionof distributed systems, existing work on chore-\nographic programming supports onlycentralised decision making: every if/\nwhile-statement in a global program has aone-party condition, evaluated\nat a single role. For instance, in the example above, the decision to con-\ntinue or end the execution is made by Server alone; Client is duly informed\nafterwards—with a label communication—as it needs to know how to pro-\nceed, but the decision is really Server’s.\nHowever, in many distributed systems, it isimpractical (i.e., unnecessary or\nunnatural), or evenimpossible, for a single role to make decisions.\nFor instance, consider a distributed system in which two processes enact\nroles Player1 and Player2 to simulate a game of chess. The idea is that,\nat the end of every turn, a move is communicated from “active” Playeri to\n“passive” Playerj, after which a decision must be made: should Playerj take\na next turn, or is the game over? The key point here is that every role has\nenough knowledge to check if the latest move is, in fact, the ﬁnal one. So after\nevery turn, every role can privately—without a label communication—decide\nto continue or end the execution; moreover, unanimity is guaranteed. It is,\nthus, unnecessary toadditionally use a label communication to have one role\nexplicitly inform the other one about how to proceed. Yet, all publications\ncitedaboveforcetheusageofalabelcommunicationinthissituationanyway.\n2.Regarding the analysis of distributed systems, existing work on choreo-\ngraphic programming focusses on providing deadlock freedom. In contrast,\nproviding functional correctness has not received due attention. This is sur-\nprising: given the sequential programming style in which global programs are\nexpressed, it seems worthwhile to study how classical veriﬁcation techniques\nfor sequential code can be adapted to choreographic programming.\nBeyond choreographic programming,allotherchoreography-basedapproaches\nthat we know of are limited to centralised decision making, including conversa-\ntionprotocols(e.g.,[ 3,27]),multipartysessiontypes(MPST)(e.g.,[ 35,13,23,24]),\n522 S. Jongmans and P . v an den Bos\nTable 1: State of the art (e.g., [9,10,12,19,29,42,47]) vs. this paper\nstate of the art this paper\nconstruction\ndecisions centralised decentralised\nconditions one-party multiparty\nsyntax if r:eGthen Gelse if V{r:er}r2R Gthen Gelse\nexample\n(global\nprograms)\n1. B:x2_A:y1 ;\n2. if A:x1==y1\n3. A:SUCC_B ; Gthen\n4. A:FAIL_B ; Gelse\n1. B:x2_A:y1 ; A:x1_B:y2 ;\n2. if A:x1==y1 ∧B:x2==y2\n3. Gthen\n4. Gelse\nanalysis deadlock freedom deadlock freedom &\nfunctional correctness\nand MPST extensions to support value-based reasoning using assertions [5], de-\npendent types [51,25], and reﬁnement types [52]. Furthermore, we note that (el-\nements of) deductive veriﬁcation and session types were combined in Actris [32]\nand ParTypes [41]. Actris supports reasoning about functional correctness (us-\ning separation logic [44,36]), but only forbinary sessions. In contrast, ParTypes\nsupports multiparty sessions, but it does not consider functional correctness.\n1.3 Contributions of This Paper\nIn this paper, we address the two limitations described in Sect.1.2 .\n1. Construction: We present a new theory of choreographic programming\nthat supportsdecentralised decision making: every if/while-statement has a\nmultiparty condition, evaluated at multiple roles.\n2. Analysis: The new theory ensures that if theprecondition is true in the\ninitial state of a global program, then after executing the global program,\nthe postcondition is true in theﬁnal state. Similar to deadlock freedom, this\nform of functional correctness is conferred from the global program to the\nparallel composition of its projections, by operational equivalence.\nTable1 summarises our contributions relative to the state of the art; it also\nshows a minimal example to illustrate the essential diﬀerence between centralised\ndecision making and decentralised. With centralised decision making (left global\nprogram), ﬁrst,only Bobshares x2 with Alice; next,only Alicecompares it with\nx1 and shares the outcome with Bob. In contrast, with decentralised decision\nmaking (right global program), ﬁrst,both Alice and Bobshare their values; next,\nboth Alice and Bobcompare them, but they do not need to share the outcomes,\nas their unanimity is guaranteed.\n1.4 Key Challenge: How to Check If Unanimity Is Guaranteed?\nSo far, we have seen two examples of decentralised decision making (i.e., Player1\nand Player2 in Sect.1.2 ; Alice and Bob in Sect.1.3 ). In both examples, we noted\nA Predicate T ransformer for Choreographies 523\nthat “unanimity is guaranteed”; this is crucially important to provide deadlock\nfreedom. As a counterexample of what can go wrong in the absence of unanimity,\nsuppose that Bob’s condition in Tab.1 were x2==true (i.e., he ignores Alice’s\nvalue). In that case, unanimity is not guaranteed, so Alice and Bob candiverge:\nAlice privately decides to enter one branch, while Bob privately decides to enter\nthe other branch. A deadlock subsequently ensues if, for instance, Alice needs\nto await a message from Bob in her branch, while Bob needs to await a message\nfrom Alice in his branch.\nThus, the key challenge to support decentralised decision making in chore-\nographic programming is this: “How to check if unanimity is guaranteed?” The\npivotal insight is that this question can be reduced to a seemingly unrelated one:\n“Given a global program and a postcondition, how to compute a precondition?”\nIt was ﬁrst answered for sequential code by Dijkstra in the 1970s [26], in terms\nof apredicate transformerto computeweakest preconditions. A crucial technical\ncontribution of this paper is a non-trivial adaptation of Dijkstra’s seminal work,\ntailored for choreographic programming, to provide not only functional correct-\nness (i.e., ensure the truth of the postcondition) but also deadlock freedom in\nthe presence of decentralised decision making (i.e., ensure unanimity).\n1.5 Organisation of This Paper\nIn Sect.2 , to further motivate this paper’s new theory, we present more examples\nof real(istic) distributed systems that require decentralised decision making.\nThe new theory is presented in Sects.3 –7: in Sect.3 , we present some pre-\nliminaries; in Sect.4 , we present a base calculus of global programs, without if/\nwhile-statements, but with a main theorem that covers both deadlock freedom\nand functional correctness; in Sect.5 and Sect. 6 , to support decentralised de-\ncision making, we extend the base calculus with if/while-statements; in Sect.7 ,\nwe present a calculus of local programs and projection. Thus, Sect.4 –6cover\nthe upper half of Fig.1 , while only Sect.7 covers the bottom half.\nAppendices appear in the full version of this paper [39]. Detailed deﬁnitions,\nauxiliary lemmas, main theorems, and proofs appear in a technical report [40].\n2 Motivating Examples\nTo further motivate theusefulness and necessity of this paper’s new theory,\nin this section, we present examples of real(istic) distributed systems that re-\nquire decentralised decision making; see Appx. A [39] for additional examples.\nThroughout the section, we adopt a programmer’s perspective and present only\nglobal programs (i.e., all construction and analysis activities that a programmer\ncarries out manually in the workﬂow, happen in the upper half of Fig.1 ).\nRegarding the usefulness of the new theory, the following example shows that\ncentralised decision making can beimpractical (i.e., unnatural or unnecessary).\nExample 1(Chess simulation). From Sect.1.2 , recall the distributed system in\nwhich two processes enact roles Player1 and Player2 to simulate a game of chess.\n524 S. Jongmans and P . v an den Bos\n1. P1:b:=board() ; P2:b:=board() ;\n2. while P1:!done(b)\n3. (P1:CONTINUE_P2 ; G12 ;\n4. if P2:!done(b)\n5. (P2:CONTINUE_P1 ; G21)\n6. (P2:END_P1 ; skip)) ;\n7. P1:END_P2\n(a) Centralised\n1. P1:b:=board() ; P2:b:=board() ;\n2. while P1:!done(b) ∧P2:!done(b)\n3. (G12 ;\n4. if P1:!done(b) ∧P2:!done(b)\n5. G21\n6. skip)\n(b) Decentralised\nFig.2: Global programs for chess simulation (Exmp.1 )\nFigure2 shows two global programs: one that uses centralised decision mak-\ning (at Player1 and Player2, in alternating order), and one that uses the new\ntheory’s decentralised decision making; both have auxiliary global programsG12\n(Player1 is active, Player2 is passive; details omitted) andG21 (vice versa).\nIn Sect.1.2 , we argued for the usefulness of decentralised decision making in\nthis example: the label communications in Fig.2a are actually unnecessary.\nRegarding the necessity of the new theory, the following example shows that\ncentralised decision making can beimpossible. In the example, notationG1 ∥G2\nprescribes an interleaving; it is used to express that the order in whichG1 andG2\nare executed does not matter (i.e., it is not intended to be multi-threading; there\nis no interaction betweenG1 and G2). By convention, sequencing binds stronger\nthan interleaving. For instance,G1 ; G2 ∥G3 should be read as(G1 ; G2) ∥G3.\nExample 2(Probabilistic leader election in anonymous clique networks). Con-\nsider a distributed system in whichk anonymous processes (i.e., they have no\npredeﬁned identiﬁers) need to elect a leader among them. For clique networks\n(i.e., each process has a channel to each other process), a probabilistic version\nof Peleg’s algorithm [45] can be used in the style of Itai and Rodeh [37,38]. The\nalgorithm proceeds in rounds. In every round, every process picks a random iden-\ntiﬁer and sends it to every other process. If there is a unique maximal identiﬁer,\nthen the process that picked it becomes the leader. If not, another round follows.\nFigure3 shows a global program fork=3; it crucially relies on the new the-\nory’s decentralised decision making. We writer:[x1;:::;x n]:=[ e1;:::;e n] to ab-\nbreviate r:x1 :=e1 ; ···; r:xn:=en, while we writep:e_[q1:x1;:::;q n:xn] to ab-\nbreviatep:e_q1:x1 ; ···; p:e_qn:xn. First, the processes initialise ﬁve variables\n(lines 1–3):seed is used to pick random identiﬁers;id1, id2, andid3 are used to\nstore and compare identiﬁers;leader indicates whether or not the process was\nelected. Next, the processes enter the loop (lines 4–7), each of whose iterations\nrepresents one round: in every iteration, every process increments its seed, picks\na random identiﬁer, and shares it. When the maximal identiﬁer is unique, the\nprocesses exit the loop. One process marks itself as leader (lines 8–10).\nThepointofthisexampleisthattheprobabilisticversionofPeleg’salgorithm\nfor cliques—actually, any leader election algorithm—cannot faithfully be imple-\nmented using centralised decision making. The reason is that centralised decision\nA Predicate T ransformer for Choreographies 525\n1. (P1:[seed;id1;id2;id3;leader]:=[ -1;-1;-1;-1;false] ∥\n2. P2:[seed;id1;id2;id3;leader]:=[ -1;-1;-1;-1;false] ∥\n3. P3:[seed;id1;id2;id3;leader]:=[ -1;-1;-1;-1;false]) ;\n4. while V{r:!maxIsUnique(id1,id2,id3)}r2fP1;P2;P3g\n5. (P1:seed:=seed+1 ; P1:id1:=random1(seed) ; P1:id1_[P3:id1;P2:id1] ∥\n6. P2:seed:=seed+1 ; P2:id2:=random2(seed) ; P2:id2_[P1:id2;P3:id2] ∥\n7. P3:seed:=seed+1 ; P3:id3:=random3(seed) ; P3:id3_[P2:id3;P1:id3]) ;\n8. if V{r:id1 == max(id1,id2,id3)}r2fP1;P2;P3g(P1:leader:=true) (skip) ;\n9. if V{r:id2 == max(id1,id2,id3)}r2fP1;P2;P3g(P2:leader:=true) (skip) ;\n10. if V{r:id3 == max(id1,id2,id3)}r2fP1;P2;P3g(P3:leader:=true) (skip)\nFig.3: Global program for probabilistic leader election in anonymous clique net-\nworks (k=3), using decentralised decision making\nmaking inherently requires the presence of a distinguished process (to evaluate\na one-party condition and share the outcome). However, the motivation to run\na leader election algorithm in the ﬁrst place is that such a distinguished process\nis not yet agreed upon. That is, centralised decision making requiresasymmetry\nof processes, whereas leader election algorithms requiresymmetry.\n3 Setting the Stage: Data and Conditions\nThe topic of interest in this paper is “processes that communicate”, rather than\n“data that are communicated”. For this reason, we assume that there exists some\nunderlying calculus of data (Sect.3.1 ), but we omit most of its details; they are\northogonal to this paper’s contributions. On top of it, we adopt a logic to write\npreconditions, postconditions, and conditions in if/while-statements (Sect.3.2 ).\n3.1 Data\nLet R = {A;B;C;::: }denote a universe of roles, ranged over by p;q;r . Let\nX = {x;y;z;::: }denote a universe ofvariables, ranged over byx;y;z . LetV =\n{error;true;false;0;1;2;::: }denote a universe ofvalues, ranged over byv\n(i.e., V contains at least a distinguished valueerror, booleans, and numbers,\nbutwealsouseotherdatatypesinexamples,includingfunctions).Let E denotea\nuniverse ofexpressions, ranged over bye; it is induced by the following grammar:\ne ::= r:x|{z}\nrole-qualiﬁed variable\n\f\f v\n\f\f e1==e2\n\f\f e1<e2\n\f\f e1&&e2\n\f\f !e\n\f\f e1+e2\n\f\f ···| {z }\ncompound expressions\nLet S = R *(X *V) denote a universe ofstates (i.e., partial functions from\nroles to partial functions from variables to values), ranged over byS; the idea is\nthat every state has a separate section for every role of interest, to model disjoint\nmemory spaces. Leteval : S ×E → V denote a totalevaluation function. For\ninstance, evalfA7!fx7!5;y7!6gg(A:x+A:y) =11. We assume that bogus expressions\nare evaluated toerror. For instance,eval;(1+true) =error.\n526 S. Jongmans and P . v an den Bos\nRegarding terminology, we say that every role-qualiﬁed variabler:xis “local\nto r”. If every role-qualiﬁed variable that occurs ineis local tor, theneis “local\nto r”. Regarding notation, ifeis local tor, then we often move all “r:”-qualiﬁers\nthat occur ine to the front. For instance, we writeA:x+y instead ofA:x+A:y.\n3.2 Conditions\nWe adopt the following basic logic over expressions inE. LetΨ denote a universe\nof formulas, ranged over by\u001e;\u001f; ; it is induced by the following grammar:\n\u001e;\u001f; ::= e\n\f\f ¬ \n\f\f  1 ∧ 2\n\f\f ∀ \nInformally, given stateS, formulas have the following meaning relative toS:\n– Formulae is anatom: it is true inSiﬀ e evaluates totrue using S.\n– Formulas ¬ and  1 ∧ 2 are a negation and a conjunction, as usual.\n(Negation and conjunction appear also at the level of formulas, and not just\nat the level of expressions, for technical convenience later on in this paper.)\n– Formula∀ is atautology: it is true inSiﬀ  is true in every state.\nFormally, aninterpretation functionmaps formulas to the sets of states in which\nthey are true, denoted byJ-K; it is induced by the following equations:\nJeK =\n{S|evalS(e) =true}\nJ¬ K = S \\J K\nJ 1 ∧ 2K = J 1K ∩J 2K J∀ K =\n(\nS if: J K = S\n∅ otherwise\nRegarding terminology, if every expression that occurs in is local tor, then\n is “local tor”; if so, the truth of can be checked atr. Regarding notation, we\noften writeV{ r}r2fr1;:::;rng instead of r1 ∧···∧ rn if  r is local torfor every\nr ∈{r1;:::;r n}. Furthermore, we write 1 ∨ 2 and  1 →  2 for disjunction\nand implication. Finally, we write 1 ≡ 2 instead ofJ 1K = J 2K.\n4 Global Programs: Base Calculus\nTo gently introduce the main components of the new theory, in this section, we\npresent a base calculus of global programs,without if/while statements, butwith\na main theorem that covers bothdeadlock freedom andfunctional correctness.\nInitially, we present the syntax and semantics (Sect.4.1 ); subsequently, we\npresent a predicate transformer (Sect.4.2 ); ﬁnally, we present the main theorem,\nwhich relies on the predicate transformer (Sect.4.3 ). In the next sections, we\nextend the base calculus to support decentralised decision making.\n4.1 Syntax and Semantics\nLet Γ and G denote universes ofglobal actionsand global programs, ranged over\nby \r and G; they are induced by the following grammar:\nA Predicate T ransformer for Choreographies 527\n\r ::= q:y:=e\n\f\f p:e_q:y G ::= skip\n\f\f \r\n\f\f G1 ; G2\n\f\f G1 ∥G2\nInformally, these grammar elements have the following meaning:\n– Global actionq:y:=emodels anassignmentof the value of expressioneto\nvariableyatrole q.Asanextraconstraint, eislocalto q.Regardingnotation,\nwe often omit “q:”-qualiﬁers frome. For instance, we writeA:z:=x+y instead\nof A:z:=A:x+A:y. Also, we writeevalS(q:y:=e) instead ofq:y:=evalS(e).\n– Global actionp:e_q:y models a synchronouscommunicationof the value\nof expressione at rolep into variabley at roleq. As extra constraints,e is\nlocal top, andp̸= q. Regarding notation, we often omit “p:”-qualiﬁers from\ne. Also, we writeevalS(p:e_q:y) instead ofp:evalS(e)_q:y.\n– Global programskip prescribes anempty execution.\n– Globalprogram G1 ; G2 prescribesa weak sequenceofG1 andG2.Theidea\nis that it resembles a conventionalstrong sequence (i.e., in-order execution),\nexcept that it also allows global actions inG2 that are independent of those\nin G1 to be executed already beforeG1 is done (i.e., out-of-order).\nFor instance, inA:x:=5 ; B:y:=6, the assignment at Bob is independent of\nthe assignment at Alice, so they maybe executed out-of-order. In contrast,\nin A:x:=5 ; A:x+1_B:y, the communication from Alice to Bob depends on\nthe assignment at Alice, so they mustbe executed in-order. In general, when\ntwo global actions have disjointsubjects (i.e., participating roles), they are\nconsidered independent and may be executed out-of-order.\nOut-of-order execution of global actions with disjoint subjects is common in\nchoreographic programming: it was ﬁrst introduced by Carbone and Montesi\nto deal with latent concurrency among roles in global action sequences [10].\n– Global programG1 ∥G2 prescribes aninterleaving of G1 and G2.\nFormally, we deﬁne the operational semantics of global programs at two “layers”.\n(1) The “top layer” consists of anabstract termination relation, denoted\nby ↓, and anabstract labelled reduction relation, denoted by→ in the style of\nprocess algebra (e.g., [2]). More precisely,G↓means thatGcan terminate, while\nG\n ;\r\n−−→G0 means thatGcan reduce toG0 when  is true (i.e., conditionally) by\nexecuting \r. For instance, the followingabstract executionis possible:\nA:x:=5 ; A:x+1_B:y\ntrue;A:x:=5\n−−−−−−−→skip ; A:x+1_B:y\ntrue;A:x+1_B:y\n−−−−−−−−−−→skip ; skip ↓\nFirst, the global program reduces by executing an assignment; next, it reduces\nby executing a communication; next, it terminates. For simplicity,skips are not\nautomatically cleaned up by the reduction rules (but they could be).\nRelations↓and→ areinducedbytherulesinFig. 4a.Mostrulesarestandard\n[2]. Notably, in this section, every reduction isunconditional (i.e., labelled with\ntrue) due to rule[ →-Act]. The only special rule is rule[ →-Seq2]: it states that\nif G2 can reduce toG0\n2 by executing\r (right premise), and if\r is independent\nof G1 (left premise), thenG1 ; G2 can reduce accordingly (conclusion). We note\nthat independence is deﬁned in terms of disjointness of subjects, as explained\nabove. For instance, the following abstract out-of-order execution is possible:\n528 S. Jongmans and P . v an den Bos\nskip ↓\n[#-Skip]\nG1 ↓ G2 ↓\nG1 ; G2 ↓\n[#-Seq]\nG1 ↓ G2 ↓\nG1 ∥G2 ↓\n[#-Par]\n = true\n\r\n ;\r\n−−→skip\n[!-Act]\nG1\n ;\r\n−−→G0\n1\nG1 ; G2\n ;\r\n−−→G0\n1 ; G2\n[!-Seq1]\nsubj(G1) ∩subj(\r) =∅ G2\n ;\r\n−−→G0\n2\nG1 ; G2\n ;\r\n−−→G1 ; G0\n2\n[!-Seq2]\nG1\n ;\r\n−−→G0\n1\nG1 ∥G2\n ;\r\n−−→G0\n1 ∥G2\n[!-Par1]\nG2\n ;\r\n−−→G0\n2\nG1 ∥G2\n ;\r\n−−→G1 ∥G0\n2\n[!-Par2]\n(a) Base calculus\n = V{er}r2R \r = 1R\nif V{er}r2R G1 G2\n ;\r\n−−→G1\n[!-If1]\n = V{¬er}r2R \r = 2R\nif V{er}r2R G1 G2\n ;\r\n−−→G2\n[!-If2]\n = V{er}r2R \r = 1R\nwhile V{er}r2R { inv}G\n ;\r\n−−→G; while V{er}r2R { inv}G\n[!-While1]\n = V{¬er}r2R \r = 2R\nwhile V{er}r2R { inv}G\n ;\r\n−−→skip\n[!-While2]\n(b) Extension with if/while-statements –explained in Sect.5\nR= R1 ∪R2 R1 ̸= ∅implies G1 ↓ R2 ̸= ∅implies G2 ↓\nif V{er}r2R G1|R1 G2|R2 ↓\n[#-NIf]\nr∈R\\(R1 ∪R2)  = er \r = 1frg\nif V{er}r2R G1|R1 G2|R2\n ;\r\n−−→if V{er}r2R G1|R1[frgG2|R2\n[!-NIf1]\nr∈R\\(R1 ∪R2)  = ¬er \r = 2frg\nif V{er}r2R G1|R1 G2|R2\n ;\r\n−−→if V{er}r2R G1|R1 G2|R2[frg\n[!-NIf2]\nG1\n ;\r\n−−→G0\n1 subj(\r) ⊆R1 \\R2\nif V{er}r2R G1|R1 G2|R2\n ;\r\n−−→if V{er}r2R G0\n1|R1 G2|R2\n[!-NIf3]\nG2\n ;\r\n−−→G0\n2 subj(\r) ⊆R2 \\R1\nif V{er}r2R G1|R1 G2|R2\n ;\r\n−−→if V{er}r2R G1|R1 G0\n2|R2\n[!-NIf4]\nif V{er}r2R (G; while V{er}r2R { inv}G|;)|;skip|;\n ;\r\n−−→G0\nwhile V{er}r2R { inv}G|;\n ;\r\n−−→G0\n[!-NWhile]\n(c) Extension with non-blocking if/while-statements –explained in Sect.6\nFig.4: Abstract operational semantics of global programs (“top layer”)\nA Predicate T ransformer for Choreographies 529\nG↓\n(G;S) ↓\n[#]\nG\n ;\r\n−−→G0 S∈ J K \rc = evalS(\r)\n(G;S)\n\rc\n−→(G0;e\u000bect(\rc;S))\n[!]\ne\u000bect(q:y:=v;S) = S[v=q:y]\ne\u000bect(p:v_q:y;S) =S[v=q:y]\nS[v=q:y] ={r↦→S(r) |q̸= r}∪{q↦→{x↦→S(q)(x) |x̸= y}∪{y↦→v}}\nFig.5: Concrete operational semantics of global programs (“bottom layer”)\nA:x:=5 ; B:y:=6\ntrue;B:y:=6\n−−−−−−−→A:x:=5 ; skip\ntrue;A:x:=5\n−−−−−−−→skip ; skip ↓\n(2) The “bottom layer” consists of aconcrete termination predicate, denoted\nby ↓(same symbol as before), and aconcrete labelled reduction relation, denoted\nby → (ditto). The idea is that the bottom layer enriches the top layer by taking\ninto account states, in terms ofconﬁgurationsof the form(G;S). More precisely,\n(G;S) ↓means thatG can terminate inS, while(G;S)\n\rc\n−→(G0;S0) means that\nG can reduce to G0 by executing \rc in S to obtain S0. We write\rc—with a\nsuperscript “c”—to indicate that it is a “concrete” global action in which every\nexpression has been evaluated to a value (usingS). For instance, the following\nconcrete executionis possible:\n(A:x:=5 ; A:x+1_B:y;{A ↦→{x ↦→0};B ↦→{y ↦→0}})\nA:x:=5\n−−−−→ (skip ; A:x+1_B:y;{A ↦→{x ↦→5};B ↦→{y ↦→0}})\nA:6_B:y\n−−−−−→ (skip ; skip;{A ↦→{x ↦→5};B ↦→{y ↦→6}}) ↓\nRelations ↓and → are induced by the rules in Fig.5 . Rule[ ↓]states that ifG\ncan terminate, then so can(G;S), regardless ofS. More interestingly, rule[ →]\nstates that ifG can reduce toG0 when  is true by executing\r (left premise),\nand if is indeed true inS(middle premise), and if\rc is the “concretisation” of\r\nsuch that every expression is ﬁrst evaluated usingS(right premise), then(G;S)\ncanreduceaccordingly,andthe eﬀect of\rc isappliedto S(conclusion);thelatter\nmeans that a variable is bound to a new value inS, formalised using “substitution\nnotation”. For instance (cf. second reduction in the concrete execution above),\nif S = {A ↦→{x ↦→5};B ↦→{y ↦→0}}, then e\u000bect(evalS(A:x+1_B:y);S) =\ne\u000bect(A:6_B:y;S) ={A ↦→{x ↦→5};B ↦→{y ↦→6}}.\nOur formalisation of the operational semantics has two novelties:\n– Two-layered approach– In existing work on stateful choreographic program-\nming (e.g., [14,19]), abstract and concrete operational semantics are merged\ninto one. An advantage of keeping them separate is that it enables us to\nprove the main theorems also in a layered fashion; this simpliﬁes our proofs.\n– Semantic reordering– In existing work on choreographic programming (e.g.,\n[10,42]), weak sequencing is formalised using a structural congruence rela-\ntion in the style of pi-calculus (e.g., [50]), including special “swap rules” to\nsyntactically reorder independent global actions. In contrast, rule[ →-Seq2]\nsemantically reorders them; this simpliﬁes our proofs. Our approach, inspired\nby Rensink and Wehrheim [49], essentially generalises the formalisation of\nasynchronous action preﬁxing in multiparty session types [24].\n530 S. Jongmans and P . v an den Bos\nR̸= ∅\nXR(skip)\n[X-Skip]\nq∈R\nXR(q:y:=e)\n[X-Act1]\np;q ∈R\nXR(p:e_q:y)\n[X-Act2]\nXR(G1) XR(G2)\nXR(G1 ; G2)\n[X-Seq]\nXR(G1) XR(G2) chan(G1) ∩chan(G2) =∅\nXR(G1 ∥G2)\n[X-Par]\n(a) Base calculus\nXR(G1) XR(G2)\nXR(if V{er}r2R G1 G2)\n[X-If]\nXR(G)\nXR(while V{er}r2R { inv}G)\n[X-While]\n(b) Extension with if/while-statements –explained in Sect.5\nXR(G1) XR(G2) R1;R2 ⊆R\nR1 ̸= ∅implies R2 = ∅\nR2 ̸= ∅implies R1 = ∅\nXR(if V{er}r2R G1|R1 G2|R2 )\n[X-NIf]\nXR(G)\nXR(while V{er}r2R { inv}G|;)\n[X-NWhile]\n(c) Extension with non-blocking if/while-statements –explained in Sect.6\nFig.6: Well-formedness of global programs\nWe end this subsection with awell-formedness relation, denoted by X, to\ncheck a few basic syntactic properties of global programs; it is induced by the\nrules in Fig.6a . For now, there are two aims (to be extended in subsequent\nsections for if/while-statements):\n1.Rules [ X-Act1]and [ X-Act2]ensure that R contains all roles that occur\nin G. The idea is that when we projectG onto every role inR (Sect.7 ),\nwe get a local program for every remaining subject ofG(i.e., whenGis the\nremaining global program,Rmay contain roles that participated in the past,\nbut no longer in the future). Thus,R spans the whole distributed system.\n2.Rule [ X-Par]ensures that thechannels (i.e., sender–receiver pairs) that oc-\ncur inG1 and G2 are disjoint; this is a common assumption in choreographic\nprogramming (e.g., [8]). The idea is that when a communication happens in\nG1 ∥G2, it must be unambiguously clear whether it happened inG1 or inG2;\notherwise, the operational equivalence theorem cannot be proved (Sect.7 ).\n4.2 Predicate Transformer\nIn the next subsection, the main theorem for global programs will be as follows\n(informally): if the global program is well-formed, and if the precondition is\ntrue in the initial state, thendeadlock freedom and functional correctness are\nprovided. In this subsection, we present a technique to automatically compute\npreconditions such that the main theorem can indeed be formulated and proved.\nA Predicate T ransformer for Choreographies 531\n\u001e(skip;\u001f) = \u001f\n\u001e(q:y:=e;\u001f) = \u001f[e=q:y]\n\u001e(p:e_q:y;\u001f) =\u001f[e=q:y]\n\u001e(G1 ; G2;\u001f) = \u001e(G1;\u001e(G2;\u001f))\n\u001e(G1 ∥G2;\u001f) =\n8\n>>>><\n>>>>:\n\u001e(G1;\u001e(G2;\u001f))\nif: G1 # G2\nfalse\notherwise\n(a) Base calculus\n\u001e(if V{er}r2R G1 G2;\u001f) =\n(V{er}r2R → \u001e(G1;\u001f)) ∧\n(V{¬er}r2R → \u001e(G2;\u001f)) ∧\n(V{er1 → er2 }r1;r22R)\n\u001e(while V{er}r2R { inv}G;\u001f) =\n inv ∧∀( inv → (\n(V{er}r2R → \u001e(G; inv)) ∧\n(V{¬er}r2R → \u001f) ∧\n(V{er1 → er2 }r1;r22R)))\n(b) Extension with if/while-statements\n– explained in Sect.5\n\u001e(if V{er}r2R G1|R1 G2|R2 ;\u001f) =\n8\n>>>><\n>>>>:\n\u001e(if V{er}r2R G1 G2;\u001f) if: R1 = ∅= R2\n\u001e(G2;\u001f) ∧V{¬er}r2RnR2 if: R1 = ∅̸= R2\n\u001e(G1;\u001f) ∧V{er}r2RnR1 if: R1 ̸= ∅= R2\nfalse if: R1 ̸= ∅̸= R2\n\u001e(while V{er}r2R { inv}G|;;\u001f) =\u001e(while V{er}r2R { inv}G;\u001f)\n(c) Extension with non-blocking if/while-statements –explained in Sect.6\nFig.7: Predicate transformer to compute preconditions\nLet \u001e denote apredicate transformer function; it is deﬁned by the equations\nin Fig.7a , where \u001f[e=q:y] denotes substitution of e for q:y in \u001f. In words, \u001e\nconsumes a global programGand a postcondition\u001fas input, and it produces a\nprecondition \u001e(G;\u001f) as output. The idea is that\u001e is sound: if\u001e(G;\u001f) is true in\nthe initial state, then after executingG, \u001f is true in the ﬁnal state. Essentially,\nFig.7a is an adaptation of Dijkstra’s predicate transformer to computeweakest\npreconditions for sequential code [26], denoted bywp. More precisely:\n– For q:y:=e, the deﬁnitions of\u001e and wp are the same; forp:e_q:y (absent\nin Dijkstra’s work),\u001e works similarly. Figure8a shows an example: ifA:x is\n5 (computed precondition), then after the communication ofA:x+1 at Alice\ninto B:y at Bob (global program), the sum ofA:x and B:y is 11 (postcon-\ndition). We note that the postcondition relates variablesat diﬀerent roles;\nthis is straightforwardly supported by\u001e, without extra manual eﬀort.\n– ForG1 ; G2, the deﬁnitions of\u001e and wp are the same as well: ﬁrst,\u001fis used\nas a postcondition ofG2 to compute a precondition\u001e(G2;\u001f); next,\u001e(G2;\u001f)\nis used as a postcondition ofG1 to compute a precondition\u001e(G1;\u001e(G2;\u001f)).\nSuch a “backwards” computation of a precondition corresponds to the “for-\nwards” execution of the sequence: initially,\u001e(G1;\u001e(G2;\u001f)) is true; subse-\nquently,\u001e(G2;\u001f) is true after executingG1; ﬁnally,\u001fis true after executing\n532 S. Jongmans and P . v an den Bos\n\u001e(A:x+1_B:y;A:x+B:y==11)\n= A:x+A:x+1==11\n≡A:x+A:x==10 ≡A:x==5\n(a) Communication\n\u001e(\r; A:x+1_B:y;A:x+B:y==11)\n= \u001e(\r;\u001e(A:x+1_B:y;A:x+B:y==11))\n= \u001e(\r;A:x+A:x+1==11) =5+5+1==11 ≡true\n(b) Sequence\n\u001e(\r; if (A:x==5 ∧B:y==6) B:y:=7 skip;\u001f)\n= \u001e(\r;\u001e(if (A:x==5 ∧B:y==6) B:y:=7 skip;\u001f))\n= \u001e(\r;(A:x==5 ∧B:y==6 → \u001e1) ∧(¬A:x==5 ∧¬B:y==6 → \u001e2) ∧(A:x==5 ↔ B:y==6))\n= (5==5 ∧B:y==6 → \u001e1[5=A:x]) ∧(¬5==5 ∧¬B:y==6 → \u001e2[5=A:x]) ∧(5==5 ↔ B:y==6)\n≡(B:y==6 → \u001e1[5=A:x]) ∧(false → \u001e2[5=A:x]) ∧B:y==6 ≡\u001e1[5=A:x] ∧B:y==6\n(c) Conditional choice –explained in Sect.5 . Let\u001e1 = \u001e(B:y:=7;\u001f), \u001e2 = \u001e(skip;\u001f).\nFig.8: Examples of\u001e. Let\r = A:x:=5.\nG2. Figure8b shows an example: iftrue is true (i.e., unconditionally), after\nexecuting the global program, the sum ofA:x and B:y is 11.\nHowever, unlike Dijkstra’s setting (i.e., strong sequencing), there is a caveat\nin our setting (i.e., weak):G1 and G2 may be executed out-of-order. This\nmakes proving the soundness of\u001e more challenging than in Dijkstra’s work\n(notably: establishing the correspondence between backwards computation\nof a precondition and forwards execution of the sequence).\n– For G1 ∥G2 (absent in Dijkstra’s work), the deﬁnition of\u001e is inspired by\nthe notion ofdisjoint parallelismin Hoare logic [33,1]. There are two cases.\nIf G1 and G2 are non-interfering, which means that the variables that occur\nin G1 and G2 are disjoint, denoted asG1 # G2, then the order in whichG1\nandG2 are executed does not aﬀect the truth/falsehood of the postcondition;\nin that case, a precondition is computed by assuming, arbitrarily, in-order\nexecution ofG1 and G2 (but any other interleaving would work as well).\nIfG1 andG2 are interfering, then\u001e yieldsfalse, so no state satisﬁes the pre-\ncondition. This is sound but not complete (i.e., there exist deadlock-free and\nfunctionally-correct global programs for which the computed precondition\nis nevertheless false). For our present purposes, however,\u001e is “complete\nenough” (e.g., all examples in Sect.2 and Appx. A [39] are supported).4\nThe following proposition follows almost directly from the deﬁnitions. It states\nthat if\u001e(\r;\u001f) is true inS, then\u001f is true inS0, after executing\r.\nProposition 1. If S∈ J\u001e(\r;\u001f)K and S0 = e\u000bect(evalS(\r);S), thenS0 ∈J\u001fK.\n4 Even though\u001e requires non-interference, interleaving (∥) oﬀers additional expressive\npower beyond weak sequencing (;). This is because non-interference (for∥) is deﬁned\nin terms of disjointnessof variables, whereas independence (for;) is deﬁned in terms\nof disjointness of roles. For instance,A:x:=5 and A:y:=6 are non-interfering, but\nnot independent. Consequently,A:x:=5 ∥A:y:=6 allows the assignments to happen\nin any order, whereasA:x:=5 ; A:y:=6 requires them to happen from left to right.\nA Predicate T ransformer for Choreographies 533\n4.3 Deadlock Freedom and Functional Correctness\nThe aim of this subsection is to formulate and prove the main theorem for global\nprograms, which covers both deadlock freedom and functional correctness.\nTo give a uniform presentation across Sects.4 –6, we formulate the lemmas\nandtheoremforthebasecalculusinthissectioninawaythattheyarereusable—\nverbatim—for the extensions in the next sections. As a result, some formulations\nare more restrictive than necessary for the base calculus, but this is ﬁne.\nThe ﬁrst two lemmas pertain to\u001e’s soundness. The ﬁrst lemma states that if\nGis well-formed and can terminate, thenthe truth of\u001e(G;\u001f) implies the truth\nof \u001f (i.e., the postconditionhas beenbrought about). The second lemma states\nthat if G is well-formed and can reduce toG0 when  is true by executing\r,\nthen the truth of\u001e(G;\u001f) ∧ implies the truth of\u001f, after executing\r; G0 (i.e.,\nthe postconditionis beingbrought about by executing\r).\nLemma 1. If XR(G) and G↓, thenJ\u001e(G;\u001f)K ⊆J\u001fK.\nProof. By induction on the derivation ofG↓.\nLemma 2. If XR(G) and G\n ;\r\n−−→G0, thenJ\u001e(G;\u001f) ∧ K ⊆J\u001e(\r; G0;\u001f)K.\nProof. By induction on the derivation ofG\n ;\r\n−−→G0. The interesting case is rule\n[→-Seq2], withG= G1 ; G2. We need to prove the following inclusions:\nJ\u001e(G1;\u001e(G2;\u001f)) ∧ K ⊆J\u001e(G1 ; \r; G0\n2;\u001f)K ⊆J\u001e(\r; G1 ; G0\n2;\u001f)K\nThe ﬁrst inclusion can be proved using the induction hypothesis andG2\n ;\r\n−−→G0\n2\n(right premise of rule[ →-Seq2]). The second inclusion can be proved using\nsubj(G1) ∩subj(\r) =∅(left premise) andXR(G), to establish thatthe variables\nthatoccurin G1 and\raredisjointaswell(i.e., G1 and\rarenon-interfering).\nThe next lemma states that well-formedness is preserved by reduction.\nLemma 3. If XR(G) and J\u001e(G;\u001f)K ̸= ∅and G\n ;\r\n−−→G0, thenXR(G0).\nProof. By induction on the derivation ofG\n ;\r\n−−→G0.\nThe next lemma states that ifG is well-formed, and if\u001e(G;\u001f) is true inS,\nthen eitherG can terminate, orG can reduce toG0 (i.e., G is not stuck).\nLemma 4. If XR(G) and S∈ J\u001e(G;\u001f)K, then eitherG↓, or there exist ;\r;G 0\nsuch thatG\n ;\r\n−−→G0 and S∈ J K.\nProof. By induction on the derivation ofXR(G).\nNow, our main theorem for global programs states that ifG is well-formed,\nand if\u001e(G;\u001f) is true inS, and if(G;S) has a sequence of reductions to(Gy;Sy),\nthen either(Gy;Sy) can terminate and\u001f is true inSy, or(Gy;Sy) can reduce.\nThus, an execution of(G;S) consists of either ﬁnitely many reductions, followed\nby termination, or inﬁnitely many (i.e.,deadlock freedom); in the former case,\nupon termination, the postcondition is true (i.e.,functional correctness).\n534 S. Jongmans and P . v an den Bos\nTheorem 3. If XR(G) and S∈ J\u001e(G;\u001f)K and (G;S)\n\rc\n1\n−→···\n\rc\nn\n−→(Gy;Sy), then:\n1.Either (Gy;Sy) ↓, or there exist\rc;Gz;Sz such that(Gy;Sy)\n\rc\n−→(Gz;Sz).\n2.If (Gy;Sy) ↓, thenSy ∈J\u001fK.\nProof. First, we inductively apply Prop.1 and Lems. 2 –3, along the reduction\nsequence to proveXR(Gy) and Sy ∈J\u001e(Gy;\u001f)K. Next, we apply Lem.4 to prove\ndeadlock freedom and Lem.1 to prove functional correctness, using Fig.5 .\n5 Global Programs: If/While-Statements\nIn the previous section, to gently introduce the main components of our theory,\nwe presented a base calculus of global programs. In this section, we extend it\nwith if/while-statement to support decentralised decision making.\n5.1 Syntax and Semantics\nRecall that Γ and G denote universes of global actions and global programs,\nranged over by\r and G; they are induced by the following extended grammar:\n\r ::= ···(page8 )\n\f\f iR\nG ::= ···(page8 )\n\f\f if V{er}r2R G1 G2\n\f\f while V{er}r2R { inv}G\nInformally, the new grammar elements have the following meaning:\n– Global actioniR, withi∈{1;2}, models acollection of private decisions\nat all roles inR together (i.e., at the same time). In case of an if-statement,\ni=1 and i=2 indicate entering the then-branch and else-branch; in case of a\nwhile-statement, i=1 and i=2 indicate (re)entering the loop and exiting it.\n– Global programif V{er}r2R G1 G2 prescribes aconditional choiceof G1\nandG2. The idea is that every roler∈Rprivately evaluates its own conjunct\ner of multiparty conditionV{er}r2R and, based on the outcome, privately\ndecides to enterG1 or G2. As a result, we havethree casesto consider:\n•Case A:If er is true for everyr∈R, then everyone entersG1.\n•Case B:If er is false for everyr∈R, then everyone entersG2.\n•Case C:If er1 is true, buter2 is false, for somer1;r2 ∈R, then someone\nenters G1, but someone else entersG2.\nCases A and B are the “good” situations in which the roles are unanimous.\nIn contrast, case C is the “bad” situation that leads to deadlock.\nFor simplicity, in this section, we assume that roles make private decisions\ntogether (i.e., at the same time), using twosynchronisation barriers. Intu-\nitively,inoperationalterms,thismeans thatforeveryrole r:ﬁrst,itprivately\nevaluates its own conjuncter; next, it reaches one of two barriers, depending\non the truth/falsehood ofer; next, it waits until every other role has pri-\nvately evaluated a conjunct and reached a barrier as well. In cases A and B,\nA Predicate T ransformer for Choreographies 535\nall roles eventually reach the same barrier, so it breaks, and all roles enter\none branch together; in case C, the roles never reach the same barrier—they\nare divided—so neither one of them breaks, and the roles get stuck.\n(We note that barriers are often undesirable in distributed systems. In the\nnext section, therefore, we also extend the base calculus with barrier-free\nif/while-statements. However, as the technical details of the barrier-free ver-\nsions are considerably more complicated than the barrier-based versions, but\npartly rely on similar principles, we present the barrier-based ones ﬁrst.)\nAn if-statement cannot terminate: a decision must be made.\n– Global program while V{er}r2R { inv}G prescribes a conditional loop\nof G. The idea is similar toif V{er}r2R G1 G2, including non-termination.\nCondition  inv is the loop invariant; it does not aﬀect the operational se-\nmantics of while-statements, but it is used to compute preconditions.\nFormally, for if/while-statements,→ is induced by the rules in Fig.4b (page 10 ).\nThepresenceofrules[→-If1]and[→-If2]correspondstocasesAandB,whereas\nthe absence of other rules corresponds to case C (i.e., there are no reductions\nwhen roles are not unanimous). For instance, whenG = A:x:=5 ; if (A:x==5 ∧\nB:y==6) B:y:=7 skip, the following two abstract executions are possible:\nG\ntrue;\nA:x:=5−−−−→•\nA:x==5^B:y==6;\n1fA;Bg\n−−−−−−−−−→•\ntrue;\nB:y:=7−−−−→•↓ G\ntrue;\nA:x:=5−−−−→•\n:A:x==5^:B:y==6;\n2fA;Bg\n−−−−−−−−−−−→•↓\nFirst, G reduces by executing an assignment at Alice (both executions); next,\nit reduces by executing private decisions at Alice and Bob together to enter the\nthen-branch (left execution) or else-branch (right); next, in the former case, it\nreduces by executing an assignment at Bob and terminates, whereas in the latter\ncase, it terminates. Regarding concrete executions, two situations are possible:\n– If B:y is initially6, then the left abstract executioncan induce a deadlock-\nfree concrete one: after the ﬁrst concrete reduction,A:x is 5, andB:y is still\n6, soA:x==5 ∧B:y==6 is true (i.e., case A, unanimity),enabling the sequel.\n– If B:y is initially not 6, then both abstract executions cannot induce a\ndeadlock-free concrete one: after the ﬁrst concrete reduction,A:x is 5, but\nB:y is still not6, so bothA:x==5 ∧B:y==6 and ¬A:x==5 ∧¬B:y==6 are false\n(i.e., case C, non-unanimity),disabling the sequel and causing a deadlock.\nThis example shows that we need a technique to infer thatB:y must initially be\n6 to ensure unanimity for deadlock freedom; we present it in the next subsection.\nWe end this subsection with an extension ofXfor if/while-statements; it is\ninduced by the rules in Fig.6b (page 12 ). There is a third aim now (cf. page12 ):\n3.Rules [ X-If]and [ X-While]ensure that every role (inR) has its own con-\njunct in every multiparty condition. The idea is that every role always needs\nto know which branch to enter, so it must participate in every decision.5;6\n5 Well-formedness (every role has its own conjunct) and the grammar of if/while-state-\nments (every conjunct is local to a role) are jointly similar to thevariable-knowledge-\ncondition of Neykova et al. [43]; they ensure that formulas are projectable (Fig.10b ).\n6 It is possible to encode choices in which only a few—not all—roles participate using\nextravariables;theideaisoutlinedattheendofAppx.A[ 39].However,thisencoding\n536 S. Jongmans and P . v an den Bos\n5.2 Predicate Transformer\nWe proceed with an extension of \u001e for if/while-statements; it is deﬁned by\nthe equations in Fig.7b (page 13 ). As before, the deﬁnition of\u001e for if/while-\nstatements is an adaptation of the deﬁnition ofwp (i.e., Dijkstra’s original pred-\nicate transformer [26]), but it diﬀers on crucial points as well. More precisely:\n– For if V{er}r2R G1 G2, the deﬁnition of\u001e has three conjuncts. The ﬁrst\n(resp. second) conjunct states that if everyer is true (resp. false), then the\nprecondition of the then-branch (resp. else-branch) is true. This is similar to\nthe deﬁnition ofwp, and it includes case A (resp. B) on page16 .\nThe third conjunct states that everyer1 must imply everyer2 (i.e., they are\neither all true or all false); this is new relative to the deﬁnition ofwp, and it\nexcludes case C on page16 . (i.e., if the precondition computed by\u001e is true,\nthen case C will never arise). The following proposition makes this precise.\nProposition 2. JV{er1 → er2 }r1;r22RK ⊆JV{er}r2R ∨V{¬er}r2RK.\nThus,\u001e accumulates logical requirements not only to ensure the truth of the\npostcondition for functional correctness (i.e., the ﬁrst and second conjunct),\nbut also to ensure unanimity for deadlock freedom (i.e., the third conjunct).\nFigure8c (page 14 ) shows an example, featuring the same global program\nas G on page17 : if \u001e1[5=A:x] is true (to ensure the truth of\u001f) and B:y is\n6 (to ensure unanimity), then after executing the global program,\u001f is true.\nThus, \u001e mechanises our reasoning aboutG on page17 .\n– Forwhile V{er}r2R { inv}G, the deﬁnition of\u001e has an “outer conjunction”\nand an “inner conjunction”. The inner conjunction is similar to\u001e for if-state-\nments: eithereveryer and the precondition of the body are true, to (re-)enter\nthe loop, orevery ¬er and the postcondition are true, to exit it.\nThe second outer conjunct states thatalways (i.e., in every state, i.e., before\nand after executing the body), if the invariant is true, then the inner con-\njunction is true; the ﬁrst outer conjunct states that the invariant is indeed\ntrue (i.e., before executing the body). This is similar to the deﬁnition ofwp.\n5.3 Deadlock Freedom and Functional Correctness\nTo extend the main theorem for global programs (Thm.3 , page16 ) to cover\nif/while-statements, we need to extend the auxiliary lemmas (Lem.1 –4, page15\nonwards); the proof of the theorem relies on the lemmas and is the same.\nLemma 5. Lemmas1 –4hold for this section’s extension.\nProof. For Lem.1 there are no new cases (i.e., no new termination rules in\nFig.4b ). For Lems.2 –3, the new cases (i.e., new reduction rules in Fig.4b ) can\nbe proved directly. For Lem.4 , the new cases (i.e., new well-formedness rules\nin Fig.6b ) can be proved using Prop.2 , to establish that rule[ →-If1]or rule\n[→-If2]is applicable in such a way thatS∈ J K holds as well.\nis not always practical/user-friendly. We therefore aim to oﬀer “native” support for\nsuch choices too, using a form ofmerging [8,9,10]; see also Appx. D [39].\nA Predicate T ransformer for Choreographies 537\nTheorem 4. Theorem3 holds for this section’s extension.\nProof. The same as the proof of Thm.3 , using Lem.5 instead of Lems.1 –4.\n6 Global Programs: Non-Blocking If/While-Statements\nIn the previous section, we extended the base calculus of global programs with\nblocking if/while-statements;theyrequirerolestomakeprivatedecisions together\n(i.e., at the same time), using barriers. In this section, we extend the base calcu-\nlus also withnon-blocking if/while-statements; they allow roles to make private\ndecisions alone (i.e., at their own pace). This is often preferable.\n6.1 Syntax and Semantics\nRecall that G denotes a universe of global programs, ranged over byG; it is\ninduced by the following extended grammar:\nG ::= ···(page16 )\n\f\f if V{er}r2R G1|R1 G2|R2\n\f\f while V{er}r2R { inv}G|;\nInformally, the new grammar elements have the following meaning:7\n– Global programif V{er}r2R G1|R1 G2|R2 prescribes anon-blocking con-\nditional choiceof G1 and G2. It relies on similar principles as the blocking\nversion; notably, the same cases A, B, C on page16 are applicable.\nThe key diﬀerence with the blocking version is that roles make private deci-\nsions alone (i.e., at their own pace), without using synchronisation barriers.\nIntuitively, in operational terms, this means that for every roler: ﬁrst, it pri-\nvately evaluates its own conjuncter; next, it immediately enters a branch.\nTo accommodate this, extra syntactic bookkeeping—in the form of the “|R1 ”\nand “|R2 ” notation—is needed to keep track of roles’ decisions.\nMore precisely, at any time,Ri contains every role that has already made a\nprivate decision to enterGi. Initially, bothR1 and R2 are empty. In case A\n(resp. B),R1 (resp.R2) eventually becomes “full” and contains all roles, while\nR2 (resp. R1) always remains empty. In case C, bothR1 and R2 eventually\nbecome non-empty, but they always remain “non-full” as well.\nAnon-blockingif-statementcanterminatewhenallroleshavemadeaprivate\ndecision and every entered branch can terminate.\n– Global programwhile V{er}r2R { inv}G|; prescribes anon-blocking\nconditional loop of G. The idea is similar toif V{er}r2R G1|R1 G2|R2 ,\nexcept that no extra bookkeeping is needed (i.e., a ﬁxed∅in “|;”): non-\nblocking while-statements will be unfolded into non-blocking if-statements.\n(The reason for the seemingly redundant “|;” notation is to give non-blocking\nwhile-statements a diﬀerent grammatical form than blocking ones.)\n7 Blocking and non-blocking if/while-statements have diﬀerent syntax. This makes it\npossible to mix the blocking and non-blocking versions in the same global program\n(we have not encountered a compelling use case for this yet, though).\n538 S. Jongmans and P . v an den Bos\nFormally, for non-blocking if/while-statements,↓and → are induced by the rules\nin Fig.4c (page 10 ). Rule[ ↓-NIf]states that if every role has made a private\ndecision (left premise), and ifG1 and G2 can terminate when at least one role\nhas entered it (middle and right premise), thenthe non-blocking if-statement can\nterminate. The eﬀect of the “Ri ̸= ∅” conditions is that a non-entered branch\ndoes not need to be able to terminate for the whole if-statement to be able to\nterminate. We note that rule[ ↓-NIf]also covers the case in which bothR1 and\nR2 are non-empty, which should never have happened in the ﬁrst place; shortly,\nwe will rule it out using well-formedness and the predicate transformer.\nRules[ →-NIf1]and [ →-NIf2]state that ifrhas not made a private decision\nyet (left premise), thenthe non-blocking if-statement can reduce by executing\none. For instance, whenG= A:x:=5 ; if (A:x==5 ∧B:y==6) B:y:=7|; skip|; and\n = A:x==5 ∧B:y==6, the following two abstract executions are possible:\nG\ntrue;\nA:x:=5−−−−→•\nA:x==5;\n1fAg\n−−−−→•\nB:y==6;\n1fBg\n−−−−→•\ntrue;\nB:y:=7\n−−−−→skip ; if  skip|fA;Bg skip|; ↓\nG\ntrue;\nA:x:=5−−−−→•\nA:x==5;\n1fAg\n−−−−→•\n:B:y==6;\n2fBg\n−−−−−→skip ; if  B:y:=7|fAg skip|fBg\nFirst, Greduces twice by executing an assignment and a private decision at Alice\nalone to enter the then-branch (both executions); next, it reduces by executing\na private decision at Bob alone to enter the then-branch (top execution) or\nelse-branch (bottom); next, in the latter case, it is stuck. Regarding concrete\nexecutions, ifB:y is initially not6, then a deadlock-free one does not exist: the\ntop abstract executioncannot be enriched (i.e., after the second reduction, the\nsequel is disabled); the bottom abstract executioncan be enriched but gets stuck.\nWe note that unlike rules[ →-If1]and [ →-If2], there is no direct correspondence\nbetween rules[ →-NIf1]and [ →-NIf2]and cases A, B, C on page16 .\nRules[ →-NIf3]and [ →-NIf4]state that ifG1 or G2 can reduce by executing\n\r (left premise), and ifthe subjects of\r have previously enteredG1 or G2 (right\npremise), then the non-blocking if-statement can reduce accordingly. This means\nthat global actions in the branches can be executed already before all private\ndecisions have been made, out-of-order. We note that the set diﬀerences in the\npremises of these rules are needed, because in general (but undesirably),R1 and\nR2 may overlap; shortly, we will rule out this possibility using well-formedness\nand the predicate transformer. For instance, with the sameGas above, also the\nfollowing abstract execution is possible (due to rule[ →-Seq2]as well):\nG\ntrue;\nA:x:=5−−−−→•\nB:y==6;\n1fBg\n−−−−→•\ntrue;\nB:y:=7\n−−−−→•\nA:x==5;\n1fAg\n−−−−→skip ; if  skip|fA;Bg skip|; ↓\nRule[ →-NWhile]unfolds the non-blocking while-statement.\nWe end this subsection with an extension ofXfor non-blocking if/while-\nstatements; it is induced by the rules in Fig.6c (page 12 ). There is a fourth aim\nnow (cf. page12 and page17 ):\n4.Rule [ X-NIf]ensures that case A or B on page16 applies, but not case C:\nwhen roles make private decisions alone, they must still be unanimous.\nA Predicate T ransformer for Choreographies 539\n6.2 Predicate Transformer\nFor non-blocking if/while-statements,\u001e is deﬁned by the equations in Fig.7c\n(page13 ). It is based on the extension for the blocking variants in Fig.7b :\n– For if V{er}r2R G1|R1 G2|R2 , the deﬁnition of\u001e has four cases.\nIf R1 and R2 are both empty, then no role has made a private decision\nto enter a branch yet, so the precondition is the same as for blocking if-\nstatements (i.e., either choice is still possible). This shows that blocking\nand non-blocking if-statements are functionally equivalent in the following\nsense: to ensure that the same postcondition is true in the end, the same\nprecondition must be true in the beginning.\nIf Ri and Rj are empty and non-empty, then the roles inRj have privately\ndecided to enterGj. Thus, the precondition ofGj must be true. Moreover,\nto ensure that the remaining roles inR\\Rj will privately make the same\ndecision to enterGj, their conjuncts must be all true (ifj=1) or all false (if\nj=2) as well. In this way, cases A and B on page16 are included.\nIf R1 and R2 are both non-empty, then roles have privately decided to enter\nboth G1 and G2, which should never have happened. Thus, the precondition\nis false. In this way, case C on page16 is excluded.\n– For while V{er}r2R { inv}G|;, no role has made a private decision to\n(re)enter the loop or exit it yet, so the precondition is the same as for block-\ning while-statements. When the ﬁrst role privately decides, the non-blocking\nwhile-statement is unfolded into a non-blocking if-statement.\n6.3 Main Theorem: Deadlock Freedom and Functional Correctness\nTo extend the main theorem for global programs (Thm.3 , page16 ) to cover non-\nblocking if/while-statements, we need to extend the auxiliary lemmas (Lem.1 –4,\npage15 onwards); the proof of the theorem relies on the lemmas and is the same.\nLemma 6. Lemmas1 –4hold for this section’s extension.\nProof. For Lem.1 , the new case (i.e., rule[ ↓-NIf]in Fig. 4c ) can be proved\nusing XR(G), to rule out the degenerate case that a non-blocking if-statement\nwith the “empty” multiparty conditionV{er}r2; can terminate. For Lem.2 , the\nnew cases (i.e., new reduction rules in Fig.4c ) can be proved directly. For Lem.3 ,\nthe new cases (i.e., new reduction rules in Fig.4c ) can be proved usingXR(G)\nand J\u001e(G;\u001f)K ̸= ∅(ﬁrst and second premise of Lem.3 ), to establish thatR1 or\nR2 is empty before the reduction, and remains empty after it (i.e., case C on\npage16 never arises). For Lem.4 , the new cases (i.e., new well-formedness rules\nin Fig.6b ) can be proved using Prop.2 , to establish that rule[ →-NIf1]or rule\n[→-NIf2]is applicable in such a way thatS∈ J K holds as well.\nTheorem 5. Theorem3 holds for this section’s extension.\nProof. The same as the proof of Thm.3 , using Lem.6 instead of Lems.1 –4.\n540 S. Jongmans and P . v an den Bos\n7 Local Programs and Projection\nIn the previous sections, to cover the upper half of Fig.1 , we incrementally\npresented a calculus of global programs with blocking and non-blocking if/while-\nstatements.Inthissection,tocoverthebottomhalf,wepresentacomplementary\ncalculus of local programs and a projection function.\n7.1 Syntax and Semantics\nLet Λ and L denote universes oflocal actions and local programs, ranged over\nby \u0015 and G; they are induced by the following grammar:\n\u0015 ::= q:y:=e\n\f\f pq!e\n\f\f pq?e\n\f\f iR\nr\n\f\f \u001c\nL ::= skip\n\f\f \u0015\n\f\f L1 ; L2\n\f\f L1 ∥L2\n\f\f\nR:if eL1 L2\n\f\f R:while eL\n\f\f if e|n L1|R1 L2|R2\n\f\f while e|n L|;\nInformally, these grammar elements have the following meaning:\n– Local actionq:y:=e models anassignment, as before.\n– Local actions pq!e and pq?q model a send and a receive of the value of\nexpression e at rolep into variabley at roleq.\n– Local action iR\nr , with i ∈{1;2}, models a private decisionat role r, as\npart of a collection of private decisions at all roles inR together.\n– Local action\u001c models adelay(i.e., passage of time in which a role sits idle).\n– The local programs have largely the same meaning as their global counter-\nparts. There are two diﬀerences. First, the extra “R:” notation in blocking\nif/while-statements allows a role to know which other roles to wait for be-\nfore entering a branch. Second, the extra “|n” notation in non-blocking if/\nwhile-statements allows a role to delayn times (motivated below).\nFormally, the abstract termination and reduction relations for local programs\nare induced by the same rules as in Fig.4 (page 10 ), mutatis mutandis, except:\n– In the rules for if/while-statements: every “V{er}r2R” and “V{¬er}r2R” is\nreplaced with “e” and “¬e”, while every “iR” and “ifrg” is replaced with “iR\nr ”\nand “ifrg\nr ” such thate is local tor. See Appx. B [39] for details.\n– There is an extra rule for non-blocking if-statements to execute a delay and\ndecrement n if n>0 (motivated below, when discussing projection).\nLet R *L denote a universe offamilies of local programs(i.e., partial func-\ntions roles to local programs), ranged over by L. Informally, Lprescribes a\nparallel composition of the k local programs in its imageL(r1);:::; L(rk).\nFormally, the abstract termination and reduction relations are induced by the\nrules in Fig.9 . They state that an assignment and a delay are executed alone,\nwhile a send–receive pair and a collection of private decisions are executed to-\ngether. We note that forn=1, the bottom-left rule to executeifr1;:::;rng covers\nthe case of non-blocking if/while-statements. Furthermore, the mechanisms by\nA Predicate T ransformer for Choreographies 541\nL(r1) ↓ ··· L(rn) ↓\nL↓\nL(q)\n ;q:y:=e\n−−−−−→L0\nq\nL\n ;q:y:=e\n−−−−−→L[q↦→L0\nq]\nL(p)\n p;pq!e\n−−−−−→L0\np L(q)\n q;pq?y\n−−−−−→L0\nq\nL\n p^ q;p:e_q:y\n−−−−−−−−−−→L[p↦→L0\np;q ↦→L0\nq]\nL(r1)\n\u0018r1 ;ifr1;:::;rng\nr1−−−−−−−−−−→L0\nr1 ··· L(rn)\n\u0018rn;ifr1;:::;rng\nrn−−−−−−−−−−→L0\nrn\nL\n\u0018r1 ^\u0001\u0001\u0001^\u0018rn;ifr1;:::;rng\n−−−−−−−−−−−−−−−→L[r1 ↦→L0\nr1 ;:::;r n ↦→L0\nrn]\nL(r)\n ;\u001c\n−−→L0\nr\nL\n ;\u001c\n−−→L[r↦→L0\nr]\nFig.9: Abstract operational semantics of families of local programs.\nL[r↦→L0\nr] denotes the update of the image ofr in Lto L0\nr.\nq:y:=e\u0016r=\n(\nq:y:=e if: r= q\n\u001c otherwise\np:e_q:y\u0016r=\n8\n>><\n>>:\npq!e if: r= p\npq?y if: r= q\n\u001c otherwise\niR \u0016r=\n(\niR\nr if: r∈R\n\u001c otherwise\n(a) Global actions\nskip \u0016r= skip\nG1 ◦G2 \u0016r= (G1 \u0016r) ◦(G2 \u0016r)\nV{e^r}^r2R \u0016r=\n(\ner if: r∈R\ntrue otherwiseif  G1 G2 \u0016r= R:if ( \u0016r) (G1 \u0016r) (G2 \u0016r)\nwhile  { inv}G\u0016r= R:while ( \u0016r) (G\u0016r)\nif  G1|R1 G2|R2 \u0016r= if ( \u0016r)|jRn(R1[R2[frg)j(G1 \u0016r)|R1\\frg(G2 \u0016r)|R2\\frg\nwhile  { inv}G|;\u0016r= while ( \u0016r)|jRnfrgj(G\u0016r)|;\n(b) Global programs. Let◦∈{;;∥}and r∈R.\nFig.10: Decomposition of global actions/programs into local actions/programs\nwhich “togetherness” arises (i.e., channels and barriers) are left implicit; they\nare implementation details. The concrete termination and reduction relations\nare induced by the same rules as in Fig.5 (page 11 ), mutatis mutandis.\nTo decompose global actions and programs into local ones, let\u0016denote apro-\njection function; it is induced by the equations in Fig.10 . In words,\u0016consumes\na global programGand a roler as input, and it produces a local programG\u0016r\nas output. The idea is that\u0016is sound and complete: roughly,G can terminate\nor reduce by executing\r if, and only if,G\u0016r can similarly terminate or reduce\nby executing\r\u0016r. The interesting cases of Fig.10 are as follows:\n– For\r(any global action), there are basically two possibilities. Ifrisa subject\nof \r, then \r \u0016r is the contribution ofr to \r (i.e., an assignment remains\nan assignment; a communication is split into a separate send and receive; a\ncollection of private decisions is split into separate ones). Ifris nota subject\nof \r, then\r\u0016r is a delay (i.e.,r sits idle, without contributing to\r).\n– ForG= if  G1|R1 G2|R2 , thedeﬁnition of\u0016is mostcomplicated. Weexplain\nit from the perspective of soundness. There are three situations to consider.\n542 S. Jongmans and P . v an den Bos\nFirst, suppose thatGreduces by executing a global action\r in whichrdoes\nparticipate. To ensure thatG\u0016r can similarly reduce by executing\r\u0016r, it\nwill be suﬃcient to register inG\u0016r whether or notr has already entered a\nbranch inG (and which one). This is achieved by “|R1\\frg” and “|R2\\frg”.\nSecond, suppose thatGreduces by executing a global actionifr0g in whichr\ndoes notparticipate, using rule[ →-NIf1]or rule[ →-NIf2], so another role\nr0 enters G1 or G2. To ensure thatG\u0016rcan similarly reduce by executing\u001c,\nit will be suﬃcient to register inG\u0016r the number of roles that have not yet\nentered a branch inG, excludingr. This is achieved by “|jRn(R1[R2[frg)j”.\nThird, suppose that G reduces by executing a global action\r in which r\ndoes notparticipate using rule[ →-NIf3]or rule[ →-NIf4]. To ensure that\nG\u0016r can similarly reduce, no additional information needs to be registered.\n7.2 Operational Equivalence\nInformally, our main theorem for local programs and projection is as follows:\nif the global program is well-formed, and ifthe computed precondition is true\nin the initial state, thenoperational equivalence is provided. In the rest of this\nsection, we ﬁrst present auxiliary lemmas; next, we present the main theorem.\nThe ﬁrst lemma pertains to soundness of\u0016. It states that ifGis well-formed\nand can terminate or reduce, thenG\u0016r can similarly terminate or reduce.\nLemma 7.\n1.If XR(G) and r∈R and G↓, then(G\u0016r) ↓.\n2.If XR(G) and r∈R and G\n ;\r\n−−→G0, then(G\u0016r)\n \u0016r;\r\u0016r\n−−−−−→(G0 \u0016r).\nProof. By induction on the derivation ofG↓(item 1) andG\n ;\r\n−−→G0 (item 2).\nTheinterestingcasesarerules [→-If1],[→-If2],[→-While1],and[→-While2]:\nin those cases, we use premisesXR(G) and r ∈R to establish thatr must have\nits own conjunct in the multiparty condition, so it must contribute to\r.\nThe second lemma pertains to completeness of\u0016. It states that ifG is well-\nformed, and ifG\u0016rcan terminate, thenGcan similarly terminate. Furthermore,\nit states that ifGis well-formed, and ifevery G\u0016rcan reduce by executing\r\u0016r,\nfor every subjectr of \r, thenG can similarly reduce.\nLemma 8.\n1.If XR(G) and (G\u0016r) ↓, thenG↓.\n2.If XR(G) and (G\u0016r)\n r;\r\u0016r\n−−−−→L0\nr, for everyr ∈subj(\r), thenG\n ;\r\n−−→G0 and\n r =  \u0016r and L0\nr = G0 \u0016r, for everyr, for some ;G0.\nProof. By induction on the derivation of(G\u0016r) ↓(item 1) and the derivations\nof (G\u0016r)\n r;\r\u0016r\n−−−−→L0\nr, for everyr ∈subj(\r) (item 2). The interesting cases are\n[→-Par1]and [ →-Par2]: we use premiseXR(G) to establish that either the LHS\nis reduced in everyG\u0016r, or the RHS (otherwise, there is no uniqueG0).\nA Predicate T ransformer for Choreographies 543\nThus, the previous lemmas show that a global program and its family of projec-\ntions can simulate each other’s behaviour, at the abstract “top layer” of the oper-\national semantics. The following theorem shows that this result can be extended\nto the concrete “bottom layer”: it states that ifGis well-formed, and if\u001e(G;\u001f) is\ntruein S,then (G;S) and({G\u0016r}r2R;S) areweakly bisimilar(e.g.,[30]),denoted\nwith ≈. This means that(G;S) and ({G\u0016r}r2R;S) can coinductively simulate\neach other’s behaviour, modulo delays (i.e.,operational equivalence).\nTheorem 6. If XR(G) and S∈ J\u001e(G;\u001f)K, then(G;S) ≈({G\u0016r}r2R;S).\nProof. We prove the theorem using Lems.7 –8and Fig.5 . See Appx. C [39] for a\nmore detailed overview of the steps, including aweak bisimulation relation.\n8 Conclusion\nWe presented a new theory of choreographic programming. It supports for the\nﬁrst time: construction of distributed systems that requiredecentralised de-\ncision making; analysis of distributed systems to provide not only deadlock\nfreedom but alsofunctional correctness. Both contributions are enabled by a\nsingle new technique, namelya predicate transformer for choreographies.\nThe following corollary summarises our main theorems (Thms.3 –6):\nCorollary 1. If global programG(with multiparty conditionsin if/while-state-\nments) is well-formed, and ifprecondition\u001e(G;\u001f) is true in initial stateS, then\nthe family of projections({G\u0016r}r2R;S) is deadlock-free and functionally-correct.\nFor instance, in Sect.2 , we presented a deadlock-free global program for leader\nelection; in Appx. E [39], we demonstrate how to prove its functional correctness;\nby Cor.1 , these properties are preserved by projection.\nWe implemented the new theory on top of the existingVerCors tool for\ndeductive veriﬁcation [4]; we present this implementation elsewhere.\nIn future work, we aim to extend the new theory with:(1) asynchronous\ncommunication; (2) a new version ofmerging [8,9,10] for decentralised decision\nmaking (see also footnote6 ); (3) more ﬂexible interleaving by relaxing the dis-\njointness requirement for interleaving to support shared variables (e.g., using\nconcurrent separation logic [6,44]).\nAcknowledgments Funded by the Netherlands Organisation of Scientiﬁc Re-\nsearch (NWO): 016.Veni.192.103.\n544 S. Jongmans and P . v an den Bos\nReferences\n1.Apt, K.R., Olderog, E.: Fifty years of hoare’s logic. Formal Aspects Comput.31(6),\n751–807 (2019)\n2.Baeten,J.C.M.,Bravetti,M.:Aground-completeaxiomatisationofﬁnite-statepro-\ncesses in a generic process algebra. Mathematical Structures in Computer Science\n18(6), 1057–1089 (2008)\n3.Basu, S., Bultan, T., Ouederni, M.: Deciding choreography realizability. In: POPL.\npp. 191–202. ACM (2012)\n4.Blom, S., Darabi, S., Huisman, M., Oortwijn, W.: The vercors tool set: Veriﬁcation\nof parallel and concurrent software. In: IFM. Lecture Notes in Computer Science,\nvol. 10510, pp. 102–110. Springer (2017)\n5.Bocchi, L., Honda, K., Tuosto, E., Yoshida, N.: A theory of design-by-contract\nfor distributed multiparty interactions. In: CONCUR. Lecture Notes in Computer\nScience, vol. 6269, pp. 162–176. Springer (2010)\n6.Brookes, S.: A semantics for concurrent separation logic. Theor. Comput. Sci.\n375(1-3), 227–270 (2007)\n7.Carbone, M., Cruz-Filipe, L., Montesi, F., Murawska, A.: Multiparty classical\nchoreographies. In: LOPSTR. Lecture Notes in Computer Science, vol. 11408, pp.\n59–76. Springer (2018)\n8.Carbone, M., Honda, K., Yoshida, N.: Structured communication-centred program-\nming for web services. In: ESOP. Lecture Notes in Computer Science, vol. 4421,\npp. 2–17. Springer (2007)\n9.Carbone, M., Honda, K., Yoshida, N.: Structured communication-centered pro-\ngramming for web services. ACM Trans. Program. Lang. Syst.34(2), 8:1–8:78\n(2012)\n10.Carbone, M., Montesi, F.: Deadlock-freedom-by-design: multiparty asynchronous\nglobal programming. In: POPL. pp. 263–274. ACM (2013)\n11.Carbone, M., Montesi, F., Schürmann, C.: Choreographies, logically. In: CONCUR.\nLecture Notes in Computer Science, vol. 8704, pp. 47–62. Springer (2014)\n12.Carbone, M., Montesi, F., Schürmann, C.: Choreographies, logically. Distributed\nComput. 31(1), 51–67 (2018)\n13.Coppo, M., Dezani-Ciancaglini, M., Yoshida, N., Padovani, L.: Global progress for\ndynamically interleaved multiparty sessions. Mathematical Structures in Computer\nScience 26(2), 238–302 (2016)\n14.Cruz-Filipe, L., Larsen, K.S., Montesi, F.: The paths to choreography extraction.\nIn: FoSSaCS. Lecture Notes in Computer Science, vol. 10203, pp. 424–440 (2017)\n15.Cruz-Filipe, L.,Montesi, F.:Choreographiesin practice.In: FORTE. LectureNotes\nin Computer Science, vol. 9688, pp. 114–123. Springer (2016)\n16.Cruz-Filipe, L., Montesi, F.: A core model for choreographic programming. In:\nFACS. Lecture Notes in Computer Science, vol. 10231, pp. 17–35 (2016)\n17.Cruz-Filipe, L., Montesi, F.: Encoding asynchrony in choreographies. In: SAC. pp.\n1175–1177. ACM (2017)\n18.Cruz-Filipe, L., Montesi, F.: Procedural choreographic programming. In: FORTE.\nLecture Notes in Computer Science, vol. 10321, pp. 92–107. Springer (2017)\n19.Cruz-Filipe, L., Montesi, F.: A core model for choreographic programming. Theor.\nComput. Sci.802, 38–66 (2020)\n20.Cruz-Filipe, L., Montesi, F., Peressotti, M.: Communications in choreographies,\nrevisited. In: SAC. pp. 1248–1255. ACM (2018)\nA Predicate T ransformer for Choreographies 545\n21.Cruz-Filipe, L., Montesi, F., Peressotti, M.: Certifying choreography compilation.\nIn: ICTAC. Lecture Notes in Computer Science, vol. 12819, pp. 115–133. Springer\n(2021)\n22.Cruz-Filipe, L., Montesi, F., Peressotti, M.: Formalising a turing-complete choreo-\ngraphic language in coq. In: ITP. LIPIcs, vol. 193, pp. 15:1–15:18. Schloss Dagstuhl\n- Leibniz-Zentrum für Informatik (2021)\n23.Deniélou, P., Yoshida, N.: Dynamic multirole session types. In: POPL. pp. 435–446.\nACM (2011)\n24.Deniélou, P., Yoshida, N.: Multiparty compatibility in communicating automata:\nCharacterisation and synthesis of global session types. In: ICALP (2). Lecture\nNotes in Computer Science, vol. 7966, pp. 174–186. Springer (2013)\n25.Deniélou, P., Yoshida, N., Bejleri, A., Hu, R.: Parameterised multiparty session\ntypes. Logical Methods in Computer Science8(4) (2012)\n26.Dijkstra, E.W.: A Discipline of Programming. Prentice-Hall (1976)\n27.Fu, X., Bultan, T., Su, J.: Conversation protocols: a formalism for speciﬁcation\nand veriﬁcation of reactive electronic services. Theor. Comput. Sci.328(1-2), 19–\n37 (2004)\n28.Giallorenzo, S., Montesi, F., Gabbrielli, M.: Applied choreographies. In: FORTE.\nLecture Notes in Computer Science, vol. 10854, pp. 21–40. Springer (2018)\n29.Giallorenzo, S., Montesi, F., Peressotti, M., Richter, D., Salvaneschi, G., Weisen-\nburger, P.: Multiparty languages: The choreographic and multitier cases (pearl).\nIn: ECOOP. LIPIcs, vol. 194, pp. 22:1–22:27. Schloss Dagstuhl - Leibniz-Zentrum\nfür Informatik (2021)\n30.van Glabbeek, R.J., Weijland, W.P.: Branching time and abstraction in bisimula-\ntion semantics. J. ACM43(3), 555–600 (1996)\n31.Hildebrandt, T.T., Slaats, T., López, H.A., Debois, S., Carbone, M.: Declarative\nchoreographies and liveness. In: FORTE. Lecture Notes in Computer Science, vol.\n11535, pp. 129–147. Springer (2019)\n32.Hinrichsen, J.K., Bengtson, J., Krebbers, R.: Actris: session-type based reasoning\nin separation logic. Proc. ACM Program. Lang.4(POPL), 6:1–6:30 (2020)\n33.Hoare, C.A.R.: Parallel programming: An axiomatic approach. Comput. Lang.\n1(2), 151–160 (1976)\n34.Honda, K., Vasconcelos, V.T., Kubo, M.: Language primitives and type discipline\nfor structured communication-based programming. In: ESOP. Lecture Notes in\nComputer Science, vol. 1381, pp. 122–138. Springer (1998)\n35.Honda, K., Yoshida, N., Carbone, M.: Multiparty asynchronous session types. In:\nPOPL. pp. 273–284. ACM (2008)\n36.Hurlin, C.: Speciﬁcation and Veriﬁcation of Multithreaded Object-Oriented Pro-\ngrams with Separation Logic. (Spéciﬁcation et vériﬁcation de programmes orientés\nobjets en logique de séparation). Ph.D. thesis, University of Nice Sophia Antipolis,\nFrance (2009)\n37.Itai, A., Rodeh, M.: Symmetry breaking in distributive networks. In: FOCS. pp.\n150–158. IEEE Computer Society (1981)\n38.Itai, A., Rodeh, M.: Symmetry breaking in distributed networks. Inf. Comput.\n88(1), 60–87 (1990)\n39.Jongmans, S.S., van den Bos, P.: A Predicate Transformer for Choreographies\n(Full Version). Tech. Rep. OUNL-CS-2022-01, Open University of the Netherlands\n(2022)\n40.Jongmans, S.S., van den Bos, P.: A Predicate Transformer for Choreographies\n(Technical Report). Tech. Rep. OUNL-CS-2022-02, Open University of the Nether-\nlands (2022)\n546 S. Jongmans and P . v an den Bos\n41.López, H.A., Marques, E.R.B., Martins, F., Ng, N., Santos, C., Vasconcelos, V.T.,\nYoshida, N.: Protocol-based veriﬁcation of message-passing parallel programs. In:\nOOPSLA. pp. 280–298. ACM (2015)\n42.Montesi, F., Yoshida, N.: Compositional choreographies. In: CONCUR. Lecture\nNotes in Computer Science, vol. 8052, pp. 425–439. Springer (2013)\n43.Neykova, R., Hu, R., Yoshida, N., Abdeljallal, F.: A session type provider: compile-\ntime API generation of distributed protocols with reﬁnements in f#. In: CC. pp.\n128–138. ACM (2018)\n44.O’Hearn, P.W.: Resources, concurrency, and local reasoning. Theor. Comput. Sci.\n375(1-3), 271–307 (2007)\n45.Peleg, D.: Time-optimal leader election in general networks. J. Parallel Distributed\nComput. 8(1), 96–99 (1990)\n46.Preda, M.D., Gabbrielli, M., Giallorenzo, S., Lanese, I., Mauro, J.: Dynamic chore-\nographies-saferuntimeupdatesofdistributedapplications.In:COORDINATION.\nLecture Notes in Computer Science, vol. 9037, pp. 67–82. Springer (2015)\n47.Preda, M.D., Gabbrielli, M., Giallorenzo, S., Lanese, I., Mauro, J.: Dynamic chore-\nographies: Theory and implementation. Log. Methods Comput. Sci.13(2) (2017)\n48.Preda, M.D., Giallorenzo, S., Lanese, I., Mauro, J., Gabbrielli, M.: AIOCJ: A\nchoreographic framework for safe adaptive distributed applications. In: SLE. Lec-\nture Notes in Computer Science, vol. 8706, pp. 161–170. Springer (2014)\n49.Rensink, A., Wehrheim, H.: Process algebra with action dependencies. Acta Infor-\nmatica 38(3), 155–234 (2001)\n50.Sangiorgi, D., Walker, D.: The Pi-Calculus - a theory of mobile processes. Cam-\nbridge University Press (2001)\n51.Toninho, B., Yoshida, N.: Certifying data in multiparty session types. J. Log.\nAlgebraic Methods Program.90, 61–83 (2017)\n52.Zhou, F., Ferreira, F., Hu, R., Neykova, R., Yoshida, N.: Statically veriﬁed reﬁne-\nments for multiparty protocols. Proc. ACM Program. Lang.4(OOPSLA), 148:1–\n148:30 (2020)\nOpen Access This chapter is licensed under the terms of the Creative Commons\nAttribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/),\nwhich permits use, sharing, adaptation, distribution and reproduction in any medium\nor format, as long as you give appropriate credit to the original author(s) and the\nsource, provide a link to the Creative Commons license and indicate if changes were\nmade.\nThe images or other third party material in this chapter are included in the\nchapter’s Creative Commons license, unless indicated otherwise in a credit line to the\nmaterial. If material is not included in the chapter’s Creative Commons license and\nyour intended use is not permitted by statutory regulation or exceeds the permitted\nuse, you will need to obtain permission directly from the copyright holder.\nA Predicate T ransformer for Choreographies 547",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.8467056751251221
    },
    {
      "name": "Correctness",
      "score": 0.7920809984207153
    },
    {
      "name": "Predicate (mathematical logic)",
      "score": 0.6927276253700256
    },
    {
      "name": "Programming language",
      "score": 0.5781951546669006
    },
    {
      "name": "Deadlock",
      "score": 0.5503666400909424
    },
    {
      "name": "Transformer",
      "score": 0.5150880217552185
    },
    {
      "name": "Logic programming",
      "score": 0.4816266894340515
    },
    {
      "name": "Distributed computing",
      "score": 0.47120019793510437
    },
    {
      "name": "Theoretical computer science",
      "score": 0.38076862692832947
    },
    {
      "name": "Voltage",
      "score": 0.0
    },
    {
      "name": "Quantum mechanics",
      "score": 0.0
    },
    {
      "name": "Physics",
      "score": 0.0
    }
  ],
  "institutions": [
    {
      "id": "https://openalex.org/I7876267",
      "name": "Open University of the Netherlands",
      "country": "NL"
    },
    {
      "id": "https://openalex.org/I94624287",
      "name": "University of Twente",
      "country": "NL"
    }
  ],
  "cited_by": 18
}