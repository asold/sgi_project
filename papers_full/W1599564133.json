{
  "title": "Predicate Transformers and Linear Logic: Yet Another Denotational Model",
  "url": "https://openalex.org/W1599564133",
  "year": 2004,
  "authors": [
    {
      "id": "https://openalex.org/A5081262354",
      "name": "Pierre Hyvernat",
      "affiliations": [
        "Institut de Mathématiques de Marseille",
        "Chalmers University of Technology"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W2911865844",
    "https://openalex.org/W2088376608",
    "https://openalex.org/W2033920397",
    "https://openalex.org/W2173455755",
    "https://openalex.org/W4253748132",
    "https://openalex.org/W4299453112",
    "https://openalex.org/W1987454422",
    "https://openalex.org/W1965630431",
    "https://openalex.org/W1599564133",
    "https://openalex.org/W1511826042",
    "https://openalex.org/W2618896829",
    "https://openalex.org/W2079412176",
    "https://openalex.org/W2911874855",
    "https://openalex.org/W2104255279"
  ],
  "abstract": null,
  "full_text": "arXiv:0905.3998v1  [cs.LO]  25 May 2009\nPredicate transformers and Linear Logic\nyet another Denotational Model\nPierre Hyvernat 1, 2\n1 Institut math´ ematique de Luminy, Marseille, France\n2 Chalmers Institute of Technology, G¨ oteborg, Sweden\nhyvernat@iml.univ-mrs.fr\nAbstract. In the reﬁnement calculus, monotonic predicate transforme rs\nare used to model speciﬁcations for (imperative) programs. Together\nwith a natural notion of simulation, they form a category enj oying many\nalgebraic properties.\nWe build on this structure to make predicate transformers in to a de-\nnotational model of full linear logic: all the logical const ructions have a\nnatural interpretation in terms of predicate transformers (i.e. in terms of\nspeciﬁcations). We then interpret proofs of a formula by a sa fety property\nfor the corresponding speciﬁcation.\nIntroduction\nThe ﬁrst denotational model for linear logic was the category of coherent spaces\n([1]). In this model, formulas are interpreted by graphs; and proof s by cliques\n(complete subgraphs). This forms a special case of domain ` a la Scott.\nFrom a conceptual point of view, the construction of interfaces is a little\ndiﬀerent: ﬁrst, the model looks a little more dynamic; then, seeds —the notion\ncorresponding to cliques— are not closed under substructures; a nd ﬁnally, they\nare closed under arbitrary unions (usually, only directed unions are allowed).\nWhat was a little unexpected is that the interpretation of linear proo fs used in\nthe relational model can be lifted directly to this structure to yield a denotational\nmodel of full linear logic in the spirit of\n/hyper/multi-coherence or ﬁniteness\nspaces.\nA promising direction for further research is to explore the links bet ween the\nmodel presented below and non-determinism as it appears both in th e diﬀerential\nlambda-calculus ([2,3]) and diﬀerent kind of process calculi. We expect such a\nlink because of the following remarks: this model comes from the sem antics of\nimperative languages; it can be extended to a model of the diﬀerent ial lambda\ncalculus (which can be seen as a variant of “lambda calculus with resou rce”)\nand there is a completely isomorphic category in which predicate tran sformers\nare replaced by (two-sided) transition systems. In particular, all of the logical\noperations presented below have natural interpretations in term s of processes...\n2\n1 Relations and Predicate Transformers\nDeﬁnition 1. A relation r between two sets is a subset of their cartesian prod-\nuct. We write r∼ for the converse relation: r∼ =\n{\n(b,a ) | (a,b ) ∈ r\n}\n.\nThe composition of two relations r ⊆ A× B and r′ ⊆ B × C is deﬁned by\nr′ · r=\n{\n(a,c ) | (∃b∈ B) ( a,b ) ∈ r∧ (b,c ) ∈ r′}\n.\nIf X is a set, IdX denotes the identity on X, i.e. IdX = {(a,a ) | a∈ X}.\nThere seems to be three main notions of morphisms between sets. T hese give\nrise to three important categories in computer science:\n– Set , where morphisms are functions;\n– Rel , where morphisms are (binary) relations;\n– Pow , where morphisms are monotonic predicate transformers.\nOne can go from Set to Rel and from Rel to Pow using the same categorical\nconstruction ([4]) which cannot be applied further.\nDeﬁnition 2. A predicate transformer from Ato B is a function from P(A) to\nP(B). A predicate transformer P is monotonic if x⊆ x′ implies P(x) ⊆ P(x′).\nFrom now on, we will consider only monotonic predicate transformer s. The ad-\njective “monotonic” is thus implicit everywhere.\nThe term “predicate” might not be the most adequate but the term inology\nwas introduced by E. Dijkstra some decades ago, and has been use d extensively\nby computer scientists since then. Formally, a predicate on a set Acan be iden-\ntiﬁed with a subset of Aby the separation axiom of ZF set theory; the confusion\nis thus harmless.\nDeﬁnition 3. If r is a relation between A and B, we write ⟨r⟩ : P(A) → P (B)\nfor the following predicate transformer: (called the direct image ofr)\n⟨r⟩(x) =\n{\nb∈ B | (∃a∈ A) ( a,b ) ∈ r∧ a∈ x\n}\n.\nNote that in the traditional version of the reﬁnement calculus ([5]), our ⟨r⟩ is\nwritten {r∼}, but this notation clashes with set theoretic notation and would\nmake our formulas very verbose with\n∼ everywhere.\n2 Interfaces\nSeveral denotational models of linear logic can be seen as “reﬁneme nts” of the\nrelational model. This very crude model interprets formulas by set s; and proofs\nby subsets. It is degenerate in the sense that any formula is identiﬁ ed with\nits linear negation! Coherent spaces ([1]), hypercoherent spaces ([6]), ﬁniteness\nspaces ([7]) remove (part of) this degeneracy by adding structur e on top of the\nrelational model. We follow the same approach:\nDeﬁnition 4. An interface X is given by a set |X| (called the state space ) and\na predicate transformer PX on |X| (called the speciﬁcation).\n3\nThe term “speciﬁcation” comes from computer science, where a sp eciﬁcation\nusually takes the form:\nif the program is started in a state satisfying φ, it will\nterminate; and the ﬁnal state will satisfy ψ.\nSuch a speciﬁcation can be identiﬁed with the (monotonic) predicate transformer\nψ ↦→“biggest such φ”. This point of view is that of the wp calculus, introduced\nby Dijkstra (“ wp” stands for “weakest precondition”). Note that the speciﬁca-\ntion “goes backward in time”: it associates to a set of ﬁnal states ( which we want\nto reach) a set of initial states (which guarantee that we will reach our goal). 3\nFor a complete introduction to the ﬁeld of predicate transformers in relation\nto speciﬁcations, we refer to [5].\nIn the coherence semantics, a “point” is a complete subgraph, 4 called a clique.\nSince the intuitions behind our objects are quite diﬀerent, we chang e the termi-\nnology.\nDeﬁnition 5. Let X be an interface, a subset x⊆ | X| is called a seed of X if\nx⊆ PX (x). We write S(X) for the collection of seeds of X.\nMore traditional names for seeds are safety properties, or P-invariant properties:\nif some initial state is in x, no matter what, after each execution of a program\nsatisfying speciﬁcation P, the ﬁnal state will still be in x. In other words, P\nmaintains an invariant, namely “staying in x”. In particular, there can be no\nprogram deadlock when starting from x.\nThe collection of cliques in the (hyper)coherent semantics forms a c .p.o.: the\nsup of any directed family exists. The collection of seeds in an interfa ce satisﬁes\nthe stronger property:\nLemma 1. For any interface X,\n(\nS(X), ⊆\n)\nis a complete sup-lattice.\nProof. ∅ is trivially a seed; and by monotonicity of P, a union of seeds is a seed.\n⊓ ⊔\nThe fact that seeds are closed under union may seem counter-intu itive at ﬁrst;\nbut one possible interpretation is that we allow for non-deterministic data. For\nexample, all denotational models of linear logic have an object for th e booleans:\nits state space is {t,f }, and the cliques are always ∅, {t} and {f}. The union of\n{t} and {f} is usually not itself a clique because “one cannot get both true and\nfalse”. However, if one interprets union as a non-deterministic sum , then {t,f }\nis a perfectly sensible set of data.\nHowever, nothing guarantees that a seed is the unions of all its ﬁnit e subseeds;\na given seed needs not even contain any ﬁnite seed!. (The canonical example\nbeing PX (x) = X, with X inﬁnite.)\n3 In a previous version, interfaces also had to enjoy the prope rty P (∅) = ∅ and\nP (|X|) = |X|. This condition doesn’t interact well with second order int erpreta-\ntion and has thus been dropped.\n4 The intuition is that a set of data is coherent iﬀ it is pairwis e coherent.\n4\n3 Constructions on Interfaces\nA denotational model interprets formulas as objects in a categor y (and proofs\nas morphisms). We thus need to deﬁne all the constructions of linea r logic at\nthe level of interfaces. The most interesting cases are the linear n egation and the\ntensor product (and the exponentials, but they will be treated in s ection 6).\nNote that there will always be an “ambient” set A for predicates. We write\nx for the A-complement of x.\nLet X = ( |X|,P X ) and Y = ( |Y|,P Y ) be two interfaces;\nDeﬁnition 6. The dual of X is deﬁned as (|X|,P ⊥\nX ) where P⊥\nX (x) = PX (x).\nWe write it X⊥. An antiseed of X is a seed in X⊥.\nIn terms of speciﬁcations, a∈ P⊥(x) means “if the program is started in a, and\nif execution terminates, the ﬁnal state will be in x”. If P is concerned with wp\ncalculus, then P⊥ is concerned with wlp calculus. (Weakest liberal precondition,\nalso introduced by Dijkstra.)\nThis operation of “negation” is the reason we do not ask for any pro perties\non the predicate transformer. It respects neither continuity no r commutation\nproperties! In many respects, this operation is not very well-beha ved.\nDeﬁnition 7. The tensor of X and Y is the interface (|X| × | Y|,P X ⊗ PY )\nwhere PX ⊗ PY (r) is the predicate transformer\nr↦→\n⋃\nx×y⊆r\nPX (x) × PY (y) .\nWe write it X⊗ Y.\nPX ⊗ PY is the most natural transformer to construct on |X| × | Y|. It was\nused in [8] to model parallel execution of independent pieces of prog rams. The\nintuition is the following: a program satisﬁes PX ⊗ PY if, when you start it\nin the pair ( ai,b i) ∈ PX ⊗ PY (r) of initial states, the two ﬁnal states will be\nrelated through r. In particular, this means that execution is synchronous: both\nexecutions need to terminate.\nDeﬁnition 8. The with of X and Y is the interface (|X|+ |Y|,P X & PY ) where\nPX & PY (x,y ) =\n(\nPX (x),P Y (y)\n)\n.5 We write it X& Y.\nThis operation is not very interesting from the speciﬁcation point of view: it is\na kind of disjoint union.\nDeﬁnition 9. The other connectives are deﬁned as usual:\n– 0 = ( ∅, Id); ⊤ = 0⊥; 1 = ( {∗}, Id); ⊥ = 1⊥;\n– X⊕ Y ( plus) is the interface\n(\nX⊥ & Y⊥) ⊥\n;\n5 it uses implicitly the fact that P(|X| + |Y |) ≃ P (|X|) × P (|Y |)\n5\n– X &Y ( par) is the interface\n(\nX⊥ ⊗ Y⊥) ⊥\n;\n– X− ◦Y is the interface X⊥ &Y.\nWe have:\nLemma 2. ⊥ = 1; ⊤ = 0 and X⊕ Y = X& Y.\nThe proof is immediate. The ﬁrst two equalities are satisﬁed in severa l of the\ndenotational models of LL; the second one is a little less common. (Fo r example,\nit is satisﬁed in ﬁniteness spaces, but in no ...-coherence spaces.)\nAs an application of the deﬁnitions, let’s massage the deﬁnition of A− ◦B into\nsomething readable:\n(a,b ) ∈ A− ◦B(r)\n⇔ { deﬁnition }\n(a,b ) ∈\n(\nA⊥\n&B\n)\n(r)\n⇔ { deﬁnition, involutivity of ⊥ }\n(a,b ) ∈\n(\nA⊗ B⊥) ⊥\n(r)\n⇔ { deﬁnition of ⊥ }\n(a,b ) /∈ A⊗ B⊥(r)\n⇔ { deﬁnition of ⊗ }\n¬\n(\n(∃x× y⊆ r) a∈ A(x) ∧ b∈ B⊥(y)\n)\n⇔ { logic }\n(∀x× y⊆ r) a /∈ A(x) ∨ b /∈ B⊥(y)\n⇔ { logic }\n(∀x× y⊆ r) a∈ A(x) ⇒ b∈ B(y)\n⇔ { lemma: x × y ⊆ r iﬀ ⟨r⟩x ⊆ y }\n(∀⟨r⟩x⊆ y) a∈ A(x) ⇒ b∈ B(y)\n⇔ { change of variable: y ↦→y }\n(∀⟨r⟩x⊆ y) a∈ A(x) ⇒ b∈ B(y).\nFrom this, we derive:\nLemma 3. (a,b ) ∈ A− ◦B(r) iﬀ a∈ A(x) ⇒ b∈ B(⟨r⟩x) for all x⊆ | X|.\nFor any interface X, Id|X| ∈ S (X− ◦X).\nThe shapes of images along X\n&Y are usually diﬃcult to visualize, but we\nhave the following on “rectangles”:\nLemma 4. Let X and Y be interfaces; then for all x ⊆ | X| and y ⊆ | Y| we\nhave: PX ⊗ PY (x× y) = PX (x) × PY (y) ⊆ PX\n&PY (x× y).\nProof. That PX ⊗ PY (x× y) = PX (x) × PY (y) is straightforward.\nSuppose now a∈ PX (x) and b∈ PY (y), let’s show that ( a,b ) ∈ PX\n&PY (x× y):\nsuppose x′ × y′ ⊆ x× y\n⇒ { claim (see below) }\nx⊆ x′ ∨ y⊆ y′\n⇒ { monotonicity }\na∈ PX (x′) ∨ b∈ PY (y′).\n6\nClaim: x′ × y′ ⊆\nx× y⇒ x⊆ x′ ∨ y⊆ y′\nProof of claim: suppose ¬(x⊆ x′) ∧ ¬(y⊆ y′)\n⇒ x∩ x′ ̸= ∅ ∧ y∩ y′ ̸= ∅\n⇒ x× y∩ x′ × y′ ̸= ∅\n⇒ ¬ (x′ × y′ ⊆ x× y). ⊓ ⊔\nFurthermore, seeds in A and B are related to seeds in A⊗ B and A &B in\nthe following way:\nLemma 5. Let A and B be interfaces. We have:\n(i) if x∈ S (A) and y∈ S (B) then x× y∈ S (A⊗ B);\n(ii) if x∈ S (A) and y∈ S (B) then x× y∈ S (A\n&B).\nProof. The ﬁrst point is obvious; the second point is a direct consequence o f\nLemma 4. ⊓ ⊔\n4 Linear Proofs and Seeds\nThe previous section gave a way to interpret any linear formula F by a interface\nF∗. (When no confusion arises, F∗ is written F.) We now interpret linear proofs\nof F as subsets of the state space of F∗.6 We refer to [1] or the abundant literature\non the subject for the motivations governing those inference rule s.\n(1) If π is\n⊢ 1\nthen π∗ = {∗};\n(2) if π is\n⊢ Γ, ⊤\nthen π∗ = ∅;\n(3) if π is π1 ⊢ Γ\n⊢ Γ, ⊥\nthen π∗ =\n{\n(γ, ∗) | γ ∈ π∗\n1\n}\n;\n(4) if π is π1 ⊢ Γ,A,B\n⊢ Γ,A &B\nthen π∗ =\n{(\nγ, (a,b )\n)\n| (γ,a,b ) ∈ π∗\n1\n}\n;\n(5) if π is π1 ⊢ Γ,A π 2 ⊢ ∆,B\n⊢ Γ,∆,A ⊗ B\nthen π∗ = π∗\n1 ⊗ π∗\n2 =\n{(\nγ,δ, (a,b )\n)\n| (γ,a ) ∈ π∗\n1 ∧ (δ,b ) ∈ π∗\n2\n}\n;\n(6) if π is π1 ⊢ Γ,A\n⊢ Γ,A ⊕ B\nthen π∗ =\n{(\nγ, (1,a )\n)\n| (γ,a ) ∈ π∗\n1\n}\n;\n6 recall that a sequent A1, . . . A n is interpreted by A1\n&. . . A n and the notation π ⊢ Γ\nmeans “ π is a proof of sequent Γ ”\n7\n(7) if π is π1 ⊢ Γ,B\n⊢ Γ,A ⊕ B\nthen π∗ =\n{(\nγ, (2,b )\n)\n| (γ,b ) ∈ π∗\n1\n}\n;\n(8) if π is π1 ⊢ Γ,A π 2 ⊢ Γ,B\n⊢ Γ,A & B\nthen π∗ is\n{(\nγ, (1,a )\n)\n|(γ,a ) ∈ π∗\n1\n}\n∪\n{\n(γ, (2,b ))|\n(\nγ,b\n)\n∈ π∗\n2\n}\n;\n(9) if π is π1 ⊢ Γ,A π 2 ⊢ ∆,A ⊥\n⊢ Γ,∆\nthen π∗ =\n{\n(γ,δ ) | (∃ a) ( γ,a ) ∈ π∗\n1 ∧ (δ,a ) ∈ π∗\n2\n}\n.\nThis interpretation is correct in the following sense:\nProposition 1. If π a proof of F, then π∗ is a seed in F∗.\nProof. By induction on the structure of π: we will check that seeds propagate\nthrough the above constructions. It is mostly trivial computation , except for two\ninteresting cases:\n(5): suppose that π1 is a seed in Γ\n&Aand that π2 is a seed in ∆ &B. We need\nto show that π1 ⊗ π2 =\n{(\nγ,δ, (a,b )\n)\n| (γ,a ) ∈ π1 ∧ (δ,b ) ∈ π2\n}\nis a seed in the\nsequent Γ &∆ &(A⊗ B).\nLet\n(\nγ,δ, (a,b )\n)\n∈ π1 ⊗ π2\n⇔\n(γ,a ) ∈ π1 and ( δ,b ) ∈ π2\n⇒ { π1 and π2 are seeds in Γ, A and ∆, B }\n(γ,a ) ∈ Γ,A (π1) and ( δ,π 2) ∈ ∆,B (π2).\nBy contradiction, let\n(\nγ,δ, (a,b )\n)\n/∈ Γ,∆,A ⊗ B(π1 ⊗ π2)\n⇒(\nγ,δ, (a,b )\n)\n∈ Γ⊥ ⊗ ∆ ⊥ ⊗ (A⊗ B)⊥(π1 ⊗ π2)\n⇒ { for some u × v × r ⊆ π1 ⊗ π2: }\nγ ∈ Γ⊥(u) ∧ δ∈ ∆ ⊥(v) ∧ (a,b ) ∈ (A⊗ B)⊥(r)  ⇒\n... ∧\n(\n(∀x× y⊆ r) a∈ A⊥(x) ∨ b∈ B⊥(y)\n)\n.\nIn particular, deﬁne x= ⟨π1⟩u and y= ⟨π2⟩v; it is easy to show that x× y⊆ r,\nso that we have a∈ A⊥(x) or b∈ B⊥(y).\nSuppose a ∈ A⊥(x): we have γ ∈ Γ⊥(u) and u× x ⊆ π1 (easy lemma); so by\ndeﬁnition, ( γ,a ) ∈ Γ⊥ ⊗ A⊥(π1), i.e. (γ,a ) /∈ Γ,A (π1)! This is a contradiction.\nSimilarly, one can derive a contradiction from b∈ B⊥(y).\nThis ﬁnishes the proof that π1 ⊗ π2 is a seed of Γ,∆,A ⊗ B.\n(9): let π1 be a seed in Γ,A = Γ⊥ − ◦Aand π2 a seed in ∆,A ⊥, i.e. π∼\n2 is a seed\nin A− ◦∆ . Let’s show that π =\n{\n(γ,δ ) | (∃a) ( γ,a ) ∈ π1 ∧ (δ,a ) ∈ π2\n}\n= π∼\n2 · π1\nis a seed in Γ,∆ .\nSuppose ( γ,δ ) ∈ π∼\n2 · π1, i.e. that ( γ,a ) ∈ π1 and ( a,δ ) ∈ π∼\n2 for some a. We will\nprove that ( γ,δ ) is in Γ,∆ (π) = Γ⊥ − ◦∆ (π). According to Lemma 3, we need\nto show that if γ ∈ Γ⊥(u) then δ∈ ∆ (⟨π⟩u).\n8\nLet γ ∈ Γ⊥(u)\n⇒ { (γ, a ) ∈ π1 ⊆ Γ ⊥ − ◦A(π1) }\na∈ A\n(\n⟨π1⟩u\n)\n⇒ { (a, δ ) ∈ π ∼\n2 ⊆ A − ◦∆ (π ∼\n2 ) }\nδ∈ ∆\n(\n⟨π∼\n2 ⟩⟨π1⟩u\n)\n⇔\nδ∈ ∆\n(\n⟨π⟩u\n)\n. ⊓ ⊔\n5 Morphisms, Categorical Structure\nTo complete the formal deﬁnition of a category of interfaces, we n eed to deﬁne\nmorphisms between interfaces. This is done in the usual way:\nDeﬁnition 10. A linear arrow from X to Y is a seed in X− ◦Y.\nHere is a nicer characterization of linear arrows from X to Y:\nLemma 6. r∈ S (X− ◦Y) iﬀ ⟨r⟩\n(\nPX (x)\n)\n⊆ PY\n(\n⟨r⟩(x)\n)\nfor all x⊆ | X|.\nProof. Suppose r is a seed in X− ◦Y, let b∈ ⟨r⟩PX (x)\n⇒\nthere is some a s.t. ( a,b ) ∈ r and a∈ PX (x)\n⇒ { r is a seed in X − ◦Y }\n(a,b ) ∈ PX − ◦PY (r)\n⇒ { deﬁnition of − ◦}\nb∈ PY (⟨r⟩x).\nConversely, suppose ⟨r⟩PX (x) ⊆ PY ⟨r⟩(x); let ( a,b ) ∈ r, and a ∈ PX (x). We\nhave b∈ ⟨r⟩PX (x), and by hypothesis, b∈ PY (⟨r⟩x). ⊓ ⊔\nLemma 7. If r∈ S (X− ◦Y) and r′ ∈ S (Y − ◦Z) then r′ · r∈ S (X− ◦Z).\nProof. This is the essence of point (9) from Proposition 1; or a simple corollary\nto Lemma 6. ⊓ ⊔\nTaken together with Lemma 3, this makes interfaces into a categor y:\nDeﬁnition 11. We write Int for the category with interfaces as objects and\nlinear arrows as morphisms.\nThis category is an enrichment of the usual category Rel. The construction\ncan be summarized in the following way:\nLemma 8. Int is obtained by lifting Rel through the following speciﬁcation\nstructure ([9]):\n– if X is a set, PrX ≡ P (X) → P (X);\n– if r⊆ X× Y, P ∈ PrX and Q∈ PrY , then P{r}Q iﬀ ⟨r⟩ · P ⊆ Q· ⟨r⟩.\nLet’s now turn our attention to the structure of this category:\n9\nLemma 9. In Int, ⊤ is terminal and & is the cartesian product.\nProof. This is immediate. ⊓ ⊔\nLemma 10. ⊥ is an involutive contravariant functor.\nProof. Involutivity is trivial; contravariance is only slightly trickier:\nr is a seed in A− ◦B\n⇔ { Lemma 6 }\n∀x ⟨r⟩A(x) ⊆ B⟨r⟩x\n⇔\n∀x B⟨r⟩x⊆ ⟨r⟩A(x)\n⇔ { lemma: y ⊆ ⟨r⟩x iﬀ ⟨r∼⟩y ⊆ x }\n∀x ⟨r∼⟩B⟨r⟩x⊆ A(x)\n⇒ { in particular, for x of the form ⟨r∼⟩x; we have x ⊆ ⟨r⟩⟨r∼⟩x (lemma) }\n∀x ⟨r∼⟩B⊥(x) ⊆ A⊥(\n⟨r∼⟩x\n)\ni.e. r∼ is a seed in B⊥ − ◦A⊥. The action of ⊥ on morphisms is just ∼. ⊓ ⊔\nCorollary 1. Int is autodual through ⊥; 0 is initial; and ⊕ is the coproduct.\nIt is now easy to see that linear arrows transform seeds into seeds , and, in the\nother direction, antiseeds into antiseeds:\nProposition 2. Suppose r is a linear arrow from X to Y:\n(i) ⟨r⟩ is a sup-lattice morphism from S(X) to S(Y);\n(ii) ⟨r∼⟩ is a sup-lattice morphism from S(Y⊥) to S(X⊥).\nProof. Let r∈ S (X− ◦Y) and x⊆ X(x); we want to show that ⟨r⟩x⊆ Y(⟨r⟩x).\nLet b∈ ⟨r⟩x\n⇔\n(∃a) ( a,b ) ∈ r∧ a∈ x\n⇒ { r is a seed in X − ◦Y }\n(∃a) ( a,b ) ∈ X− ◦Y(r) ∧ a∈ x\n⇒ { deﬁnition of X − ◦Y with the fact that ⟨r⟩x ⊆ ⟨r⟩x }\nb∈ Y(⟨r⟩x).\nShowing that ⟨r⟩ commutes with sups is immediate: it commutes with arbitrary\nunions, even when the argument is not a seed.\nThe second point follows because r∼ ∈ S (Y⊥ − ◦X⊥). ⊓ ⊔\nLemma 11. ⊗ [\n&] is a categorical tensor product with neutral element 1 [⊥].\nProof. We need to show the bifunctoriality of ⊗. This was actually proved in\nthe previous section (Proposition 1, point (5)). The bifunctoriality of &follows\nby duality; and the rest is immediate. ⊓ ⊔\nAs a summary of this whole section, we have:\nProposition 3. Int is a ∗-autonomous category. (In particular, Int is symmet-\nric monoidal closed.)\n10\nProof. This amounts to checking trivial equalities, in particular, that the fo llow-\ning diagram commutes: (where d is the natural isomorphism X ≃ X⊥⊥)\nX− ◦Y\n⊥\n→→\nd− 1\nX · ·dY →→↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ Y⊥ − ◦X⊥\n⊥\n↓↓\nX⊥⊥ − ◦Y⊥⊥\nIt is immediate because d= Id and ⊥ = ∼. ⊓ ⊔\n6 Exponentials\nThe category Int is thus a denotational model for multiplicative additive linear\nlogic. Let’s now add the exponentials ! X and ? X.\nUnsurprisingly, we will use ﬁnite multisets; here are the necessary d eﬁnitions\nand notations:\nDeﬁnition 12. Let S be a set;\n– if (si)i∈I and (tj )j∈J are ﬁnite families on S, say (si) ≃ (tj ) iﬀ there is a\nbijection σ from I to J such that si = tσ (i) for all i in I.\n– A ﬁnite multiset over S is an equivalence class of ≃. We write [si] for the\nequivalence class containing (si).\n– Mf (S) is the collection of ﬁnite multisets over S.\n– Concatenation of ﬁnite families 7 can be lifted to multisets; it is written +.\n– If xand yare two subsets of S, we write x∗yfor the set {[a,b ] | a∈ x∧b∈ y}.\nIts indexed version is written /bigsqcap\ni∈I xi; it is a kind of commutative product.\n– If U and V are two subsets of Mf (A), the set {u+ v | u ∈ U ∧ v ∈ V} is\nwritten U ∗ V (same symbol, but no confusion arises).\nDeﬁnition 13. For X = ( |X|,P ), deﬁne !X = ( Mf (|X|), !P) where\n[a1,...a n] ∈ !P(U) ⇔\n(\n∃(xi)1≤i≤n\n) /hugesqcap\ni\nxi ⊆ U ∧ (∀i= 1 ,...n ) ai ∈ P(xi)\nLet ?X =\n(\n!(X⊥)\n) ⊥\n.\nRecall that a multiset [ ai] is in /bigsqcapxi iﬀ there is a bijection σ s.t. ∀i,a i ∈ xσ (i).\nA useful intuition is that [ a1,... ] ∈ !P(U) iﬀ [ a1,... ] is in a “weak inﬁnite\ntensor” ⨁\nn X⊗n(U). In terms of speciﬁcations and programs, it suggests multi-\nthreading: for an initial state [ a1,...a n], start n occurrences of the program in\nthe states a1,. . . an; the ﬁnal state is nothing but the multiset of all the n ﬁnal\nstates.8 The “weak” part means that we forget the link between a particular\nﬁnal state and a particular initial state.\nNote that this is a “non-uniform” model in the sense that the web of !X\ncontains all ﬁnite multisets, not just those whose underlying set is a seed. It is\nthus closer to non-uniform (hyper)coherence semantics (see [1 0] or [11]) than to\nthe traditional (hyper)coherence semantics.\n7 deﬁned on the disjoint sum of the diﬀerent index sets\n8 The interpretation of !, like that of ⊗ is a synchronous operation.\n11\nLet’s prove a simple lemma about the exponentials:\nLemma 12. Suppose U ⊆ Mf (|A|):\n(i) [a] ∈ !A(U) iﬀ there is some x “included” in U (i.e. ∀a ∈ x [a] ∈ U) s.t.\na∈ A(x);\n(ii) l+ l′ ∈ !A(U) iﬀ there are V ∗ V′ ⊆ U s.t. l∈ !A(V) and l′ ∈ !A(V′);\n(iii) [a] ∈ ?A(U) iﬀ for all\nx “included” in U, a∈ A(x);\n(iv) l+ l′ ∈ ?A(U) iﬀ for all V ∗ V′ ⊆ U, l∈ ?A(V) or l′ ∈ ?A(V′).\nProof. The ﬁrst point is immediate and the second is left as an exercise. The\nthird and last point are consequences of the deﬁnition of ? in terms o f !. ⊓ ⊔\nDeﬁne now the interpretation of proofs with exponentials:\n(10) if π is π1 ⊢ Γ,A\n⊢ Γ, ?A\nthen π∗ =\n{(\nγ, [a]\n)\n| (γ,a ) ∈ π∗\n1\n}\n;\n(11) if π is π1 ⊢ Γ\n⊢ Γ, ?A\nthen π∗ =\n{(\nγ, [ ]\n)\n| γ ∈ π∗\n1\n}\n;\n(12) if π is π1 ⊢ Γ, ?A, ?A\n⊢ Γ, ?A\nthen π∗ =\n{\n(γ,l + l′) | (γ,l,l ′) ∈ π∗\n1\n}\n;\n(13) if π is π1 ⊢ ?Γ,A\n⊢ ?Γ, !A\nthen we deﬁne\n(\nγ1,...γ l, [a1 ...a n]\n)\n∈ π∗ if for each j = 1 ,...l , there is\na partition γj = ∑\n1≤i≤n γi\nj and the following holds: for each i = 1 ,...n ,\n(γi\n1,...γ i\nl ,a i) ∈ π∗\n1 .\nProposition 4. If π a proof of ⊢ Γ, then π∗ is a seed of Γ.\nProof. Points (10) and (11) are immediate.\n(12): suppose π1 is a seed Γ, ?A, ?A and let ( γ,l + l′) be an element of π.\nBy contradiction, suppose that ( γ,l + l′) /∈ Γ, ?A(π)\n⇔\n(γ,l + l′) ∈ Γ⊥ ⊗ !A⊥(π)\n⇔ { for some u × U ⊆ π }\nγ ∈ Γ⊥(u) ∧ l+ l′ ∈ !A⊥(U)\n⇔ { Lemma 12 }\nγ ∈ Γ⊥(u) ∧ (∃V ∗ V′ ⊆ U) l∈ !A⊥(V) ∧ l′ ∈ !A⊥(V′)\n⇒ { lemma: u × V × V ′ ⊆ π1 }\nγ ∈ Γ⊥(u) ∧ l∈ !A⊥(V) ∧ l′ ∈ !A⊥(V′)\n⇒\n(γ,l,l ′) ∈ Γ⊥ ⊗ !A⊥ ⊗ !A⊥(π1)\n⇔\n(γ,l,l ′) /∈ Γ, ?A, ?A(π1), which contradicts the fact that π1 is a seed in Γ, ?A, ?A.\n12\n(13): suppose that Γ contains only one formula B. The general case will follow\nfrom a lemma proved below (Lemma 13). Suppose that π1 is a seed in ? B,A ;\nlet ( l, [a1,...a n]) be in π, i.e. (li,a i) ∈ π1 for i = 1 ,...n , for some partition\n(l1,...l n) of l.\nSuppose by contradiction that ( l, [a1 ...a n]) /∈ ?B, !A(π)\n⇔\n(l, [a1,...a n]) ∈ !B⊥ ⊗ ?A⊥(\nπ)\n⇔ { for some U × V ⊆ π }\nl∈ !B⊥(U) ∧ [a1,...a n] ∈ ?A⊥(V)\n⇒ { deﬁnition of ? A }\nl∈ !B⊥(U) ∧\n( (\n∀(xi)\n) /bigsqcapxi ⊆ V ⇒ (∃i) ai ∈ A(xi)\n)\n⇔ { Lemma 12 for l: for some ( Ui) s.t. /bigsqcap\ni Ui ⊆ U }\n(∀i) li ∈ !B⊥(Ui) ∧\n( (\n∀(xi)i\n) /bigsqcap\ni xi ⊆ V ⇒ (∃i) ...\n⇒ { deﬁne xi = ⟨π1⟩Ui; lemma: /bigsqcap\ni xi ⊆ V }(\n(∀i) li ∈ !B⊥(Ui)\n)\n∧\n(\n(∃i) ai ∈ A(xi)\n)\n⇒ { lemma: Ui × xi ⊆ π1 }\n(∃i) ( ∃Ui × xi ⊆ π1) li ∈ !B⊥(Ui) ∧ ai ∈ A(xi)\n⇔\n(li,a i) ∈ !B⊥ ⊗ A⊥(π1)\n⇔\n(li,a i) /∈ ?B,A (π1), which contradicts the fact that π1 is a seed in ? B,A . ⊓ ⊔\nLemma 13. For all interfaces X and Y, we have !(X& Y) = ! X⊗ !Y.\nProof. The state spaces are isomorphic via Mf (|X|+|Y|) ≃ Mf (|X|)×Mf (|Y|).\nWe will use this transparently, for example lX + lY ∈ R iﬀ ( lX ,l Y ) ∈ R. This is\npossible because the sets are disjoint: we can always split a multiset in x∗ y into\ntwo multisets in x and y. (In other words: if x∩ y= ∅ then x∗ y≃ x× y.)\nNotice also that (1 ,a ) ∈ X& Y(x,y ) ⇔ a∈ X(x) so that when considering a\nparticular element of X+ Y(x,y ), only one part of the argument ( x,y ) is really\nimportant; the other can be dropped (or replaced with ∅).\n⊆: suppose [ a1,...a n] + [ b1,...b m] ∈ !(X& Y)(R)\n⇔ { for some ( xi)i=1...n and ( yj )j=1...m }/bigsqcap\ni xi ∗ /bigsqcap\nj yj ⊆ R∧ (∀i) ai ∈ X(xi) ∧ (∀j)bj ∈ Y(yj )\n⇒ { deﬁne U′ = /bigsqcap\ni xi and V ′ = /bigsqcap\nj yj }\n(∃U′ × V′ ⊆ R) [ ai] ∈ !X(U′) ∧ [bj] ∈ !Y(V′)\n⇔\n([a1,...a n], [b1,...b m]) ∈ !X⊗ !Y(R).\n⊇: suppose ([ a1,...a n], [b1,...b m]) ∈ !X⊗ !Y(R)\n⇔ { for some U′ × V ′ ⊆ R }\n[a1,...a n] ∈ !X(U′) ∧ [b1,...b m] ∈ !Y(V′)\n⇔ { for some ( xi) s.t. /bigsqcapxi ⊆ U′ and ( yj ) s.t. /bigsqcapyj ⊆ V ′ }\n(∀i) ai ∈ X(xi) ∧ (∀j) bj ∈ Y(yj )\n⇒ { /bigsqcap\ni xi × /bigsqcap\nj yj ⊆ U × V and thus /bigsqcap\ni xi ∗ /bigsqcap\nj yj ⊆ R }\n[a1,...a n] + [ b1,...b m] ∈ !(X& Y)(R). ⊓ ⊔\n13\nThis allows us to transform any sequent ? Γ = ? B1\n&... ?Bn into ?( B1 ⊕ ...B n),\nand thus, formally ends the proof of Proposition 4 point (13).\n7 Linear Interfaces and Linear Seeds\nWhat is the structure of those interfaces that come from a linear f ormula? The\nanswer is unfortunately trivial:\nProposition 5. If F is a linear formula, then PF = IdP|F |.\nProof. Immediate induction. Let’s treat the case of the exponentials:\nsuppose F(x) = x; suppose moreover that [ a1,...a n] ∈ U\n⇒\nai ∈ F({ai}) for all i and /bigsqcap{ai} = {[a1,...a n]} ⊆ U\n⇒\n[a1,...a n] ∈ !F(U)\nSimilarly, suppose [ a1,...a n] ∈ !F(U)\n⇒\neach ai ∈ F(xi) = xi for some ( xi) s.t. /bigsqcapxi ⊆ U\n⇒ { [a1, . . . a n] ∈ /bigsqcapxi }\n[a1,...a n] ∈ U. ⊓ ⊔\nIn particular, every subset of |F| is a clique and an anticlique: the situation\nis thus quite similar to the purely relational model. In the presence of atoms\nhowever, interfaces become much more interesting.\nAdding atoms is sound because the proof of Proposition 1 doesn’t re ly on\nthe particular properties of interfaces. Note that we need to intr oduce a general\naxiom rule and its interpretation:\n(14) if π is\n⊢ X,X ⊥\nthen π∗ = Id|X| = {(a,a ) | a∈ | X|}.\nThis is correct in the sense that π∗ is always a clique in X &X⊥.\nWith such atoms, the structure of linear interfaces gets non trivia l.9 For\nexample, let’s consider the following atom X =\n(\n{−, +},P\n)\ndeﬁned by:\n– P(∅) = ∅ and P(|X|) = |X|;\n– P({+}) = {−} and P({−}) = {+}.\nThis is the simplest example of an interesting interface, and corresp onds to a\n“switch” speciﬁcation. (Interpret − as “oﬀ” and + as “on”.)\nLemma 14. if P is the above speciﬁcation:\n(i) P⊥ = P;\n(ii) P · P = Id;\n9 We can extend this to a model for Π 1 logic, and even to full second order, see [12].\n14\n(iii) S(X) =\n{\n∅, {+, −}\n}\n;\n(iv)\n{\n(+, −), (−, +)\n}\n∈ S (X⊗ X).\nProof. This is just trivial computation... ⊓ ⊔\nPoint (iv) shows in particular that a seed in X ⊗ Y needs not contain a\nproduct of seeds in X and Y. (Compare with Lemma 5.)\nThe hierarchy generated from this single interface is however still r elatively\nsimple: call a speciﬁcation deterministic if it commutes with non-empty unions\nand intersections.\nLemma 15. Let F be any speciﬁcation constructed from the above P and the\nlinear connectives. Then F is deterministic. Moreover, F is of the form ⟨f⟩\nwhere f is an obvious bijection on the state space of F.10\nA less trivial (in the sense that it is not deterministic) speciﬁcation is t he\nfollowing: if X is a set, magicX (x) = X. In terms of programming, the use of\nthe magic command allows to reach any predicate, even the empty one!\nLemma 16. Id |X| ⊊ magicX − ◦magicX (Id|X|) if X ̸= ∅.\nThus we cannot strengthen the deﬁnition of seeds to read “ x= P(x)” without\nimposing further constraints on our speciﬁcations. It is still an ope n question\nto ﬁnd a nice class of predicate transformers for which it would be po ssible.\n(However, considerations about second order seem to indicate th at strengthening\nthe deﬁnition of seeds in such a way is not a good idea.)\nIn the case with atoms, because the structure of seeds (sup-lat tice) is quite\ndiﬀerent from the structure of cliques in the ...-coherent model (do main), it is\ndiﬃcult to relate seeds and cliques. In particular, a seed needs not b e a clique\n(since the union of arbitrary cliques is not necessarily a clique); and a clique\nneeds not be a seed (since a subset of a seed is not necessarily a see d).\nConclusion\nOne aspect which was not really mentioned here is the fact that linear arrows\nfrom Ato B are equivalent to the notion of forward data reﬁnement (Lemma 6)\nfrom the reﬁnement calculus. In particular, a linear proof of A− ◦B is a proof\nthat speciﬁcation Bimplements speciﬁcation A. It would interesting to see if any\napplication to the reﬁnement calculus could be derived from this work . In the\nsame direction, trying to make sense of the notions of backward data reﬁnement ,\nor of general data reﬁnement in terms of linear logic could prove interesting. 11\n10 where ⟨f⟩(x) = {f(a) | a ∈ x}\n11 A data reﬁnement from speciﬁcation F to speciﬁcation G is a predicate transformer\nP s.t. P · F ⊆ G · P ; a forward [resp. backward] data reﬁnement is a data reﬁneme nt\nwhich commutes with arbitrary unions [resp. arbitrary inte rsections].\n15\nThe fact that this model is degenerate in the propositional case is d isappoint-\ning, but degeneracy disappear when we consider Π 1 logic, and a fortiori when we\nconsider full second-order (see [12]). The point of extending this p ropositional\nmodel to Π 1 is to remove the dependency on speciﬁc valuations for the atoms\npresent in a formula.\nOne the interesting consequences of this work is that a a proof of a formula F\ngives a guarantee that the system speciﬁed by the formula F can avoid dead-\nlocks seems to point toward other ﬁelds like process calculi and similar models\nfor “real” computations. This direction is currently being pursued t ogether with\nthe following link with the diﬀerential lambda-calculus ([2]): one prope rty of\nthis model which doesn’t reﬂect any logical property is the following; we have a\nnatural transformation A− ◦!A called co-dereliction, which has a natural inter-\npretation in terms of diﬀerential operators on formulas (see [3]). N ote that such\na natural transformation forbids any kind of completeness theor em, at least as\nfar as “pure” linear logic is concerned.\nReferences\n1. Girard, J.Y.: Linear logic. Theoretical Computer Scienc e 50 (1987)\n2. Ehrhard, T., Regnier, L.: The diﬀerential lambda calculu s. Theoretical Computer\nScience 309 (2003) 1–41\n3. Ehrhard, T., Regnier, L.: Diﬀerential interaction nets. unpublished note (2004)\n4. Gardiner, P.H.B., Martin, C.E., de Moor, O.: An algebraic construction of predi-\ncate transformers. Science of Computer Programming 22 (1994) 21–44\n5. Back, R.J., von Wright, J.: Reﬁnement Calculus: a systema tic introduction. Grad-\nuate texts in computer science. Springer-Verlag, New York ( 1998)\n6. Ehrhard, T.: Hypercoherences: a strongly stable model of linear logic. Mathemat-\nical Structures in Computer Science 3 (1993) 365–385\n7. Ehrhard, T.: Finiteness spaces. to appear in Mathematica l Structures in Computer\nScience (2004)\n8. Back, R.J., von Wright, J.: Product in the reﬁnement calcu lus. Technical Report\n235, Turku Center for Computer Science (1999)\n9. Abramsky, S., Gay, S.J., Nagarajan, R.: A speciﬁcation st ructure for deadlock-\nfreedom of synchronous processes. Theoretical Computer Sc ience 222 (1999) 1–53\n10. Bucciarelli, A., Ehrhard, T.: On phase semantics and den otational semantics: the\nexponentials. Annals of Pure and Applied Logic 109 (2001) 205–241\n11. Boudes, P.: Non-uniform hypercoherences. In Blute, R., Selinger, P., eds.: Elec-\ntronic Notes in Theoretical Computer Science. Volume 69., E lsevier (2003)\n12. Hyvernat, P.: Predicate transformers and linear logic: second order. unpublished\nnote (2004)",
  "topic": "Predicate transformer semantics",
  "concepts": [
    {
      "name": "Predicate transformer semantics",
      "score": 0.6883876323699951
    },
    {
      "name": "Computer science",
      "score": 0.6524953246116638
    },
    {
      "name": "Predicate logic",
      "score": 0.6035948395729065
    },
    {
      "name": "Programming language",
      "score": 0.5506078004837036
    },
    {
      "name": "Linear logic",
      "score": 0.5347933173179626
    },
    {
      "name": "Predicate (mathematical logic)",
      "score": 0.4723818302154541
    },
    {
      "name": "Denotational semantics",
      "score": 0.4633368253707886
    },
    {
      "name": "Transformer",
      "score": 0.45619305968284607
    },
    {
      "name": "Mathematical proof",
      "score": 0.4478788673877716
    },
    {
      "name": "Algebra over a field",
      "score": 0.4167451858520508
    },
    {
      "name": "Theoretical computer science",
      "score": 0.4069680869579315
    },
    {
      "name": "Algorithm",
      "score": 0.3818672299385071
    },
    {
      "name": "Mathematics",
      "score": 0.24024447798728943
    },
    {
      "name": "Operational semantics",
      "score": 0.18998190760612488
    },
    {
      "name": "Pure mathematics",
      "score": 0.1592179238796234
    },
    {
      "name": "Description logic",
      "score": 0.0956411361694336
    },
    {
      "name": "Semantics (computer science)",
      "score": 0.07835343480110168
    },
    {
      "name": "Quantum mechanics",
      "score": 0.0
    },
    {
      "name": "Geometry",
      "score": 0.0
    },
    {
      "name": "Physics",
      "score": 0.0
    },
    {
      "name": "Voltage",
      "score": 0.0
    }
  ]
}