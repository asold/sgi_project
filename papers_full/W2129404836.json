{
  "title": "Integrating Meta-modelling Aspects with Graph Transformation for Efficient Visual Language Definition and Model Manipulation",
  "url": "https://openalex.org/W2129404836",
  "year": 2004,
  "authors": [
    {
      "id": "https://openalex.org/A224137900",
      "name": "Roswitha Bardohl",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    },
    {
      "id": "https://openalex.org/A692045707",
      "name": "Hartmut Ehrig",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    },
    {
      "id": "https://openalex.org/A2157085504",
      "name": "Juan de Lara",
      "affiliations": [
        "Universidad Autónoma de Madrid"
      ]
    },
    {
      "id": "https://openalex.org/A1978163079",
      "name": "Gabriele Taentzer",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    },
    {
      "id": "https://openalex.org/A224137900",
      "name": "Roswitha Bardohl",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    },
    {
      "id": "https://openalex.org/A692045707",
      "name": "Hartmut Ehrig",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    },
    {
      "id": "https://openalex.org/A2157085504",
      "name": "Juan de Lara",
      "affiliations": [
        "Técnicas y Servicios de Ingeniería (Spain)"
      ]
    },
    {
      "id": "https://openalex.org/A1978163079",
      "name": "Gabriele Taentzer",
      "affiliations": [
        "Technische Universität Berlin"
      ]
    }
  ],
  "references": [
    "https://openalex.org/W1982754734",
    "https://openalex.org/W1750765779",
    "https://openalex.org/W1488983599",
    "https://openalex.org/W2103247738",
    "https://openalex.org/W2915014422",
    "https://openalex.org/W1512007370",
    "https://openalex.org/W1967473444",
    "https://openalex.org/W1537249814",
    "https://openalex.org/W2099529102",
    "https://openalex.org/W1804076355",
    "https://openalex.org/W2019952623",
    "https://openalex.org/W112398292",
    "https://openalex.org/W2134001468",
    "https://openalex.org/W4243006681",
    "https://openalex.org/W1847099921",
    "https://openalex.org/W4285719527",
    "https://openalex.org/W1518695183",
    "https://openalex.org/W1740797132",
    "https://openalex.org/W2118710739",
    "https://openalex.org/W2068536883"
  ],
  "abstract": null,
  "full_text": "Integrating Meta-modelling Aspects\nwith Graph Transformation for Efﬁcient Visual\nLanguage Deﬁnition and Model Manipulation\nRoswitha Bardohl1,H a r t m u tE h r i g1,J u a nd eL a r a2, and Gabriele Taentzer1\n1 Computer Science Department\nTechnische Universitat Berlin\nBerlin, Germany\n{rosi,ehrig,gabi}@cs.tu-berlin.de\n2 Escuela Polit´ecnica Superior\nIngenier´ıa Inform´atica\nUniversidad Aut´onoma de Madrid\nJuan.Lara@ii.uam.es\nAbstract. Visual languages (VLs) play a centr al role in modelling various sys-\ntem aspects. Besides standard languages like UML, a variety of domain-speciﬁc\nlanguages exist which are the more used the more tool support is available for\nthem. Different kinds of generators have been developed which produce visual\nmodelling environments based on VL speciﬁcations. To deﬁne a VL, declarative\nas well as constructive approaches are used. The meta modelling approach is a\ndeclarative one where classes of symbols and relations are deﬁned and associated\nto each other. Constraints describe additional language properties. Deﬁning a VL\nby a graph grammar, the constructive way is followed where graphs describe the\nabstract syntax of models and graph rules formulate the language grammar.\nIn this paper, we extend algebraic graph grammars by a node type inheritance\nconcept which opens up the possibility to integrate both approaches by identi-\nfying symbol classes with node types and associations with edge types of some\ngraph class. In this way, declarative as well as constructive elements may be used\nfor language deﬁnitio n and model manipulation. Tw o concrete approaches, the\nGEN GED and the A T oM3 approach, illustrate how VLs can be deﬁned and mod-\nels can be manipulated by the techniques described above.\n1 Introduction\nVisual languages (VLs) play a central role in modelling various system aspects. One,\nif not the main visual modelling language is the UML [19] which integrates a num-\nber of different diagram techniques, useful to describe structural as well as behavioural\naspects of object-oriented software systems. Although the UML deﬁnes a standard in\nvisual modelling, there are of course various further visual modelling techniques, of-\nten domain-speciﬁc and often for speciﬁc aspects. Especially for those domain-speciﬁc\nsolutions which are not widely known, a generator for visual modelling environments\nis useful. After specifying the VL in mind, a supporting modelling environment con-\nsisting of visual editors, simulators, compilers and animators is generated automatically\nand does not have to be coded by hand. Thus, rapid prototyping is supported.\nM. Wermelinger and T. Margaria-Steffen (Eds.): FASE 2004, LNCS 2984, pp. 214–228, 2004.\nc⃝Springer-Verlag Berlin Heidelberg 2004\nIntegrating Meta-modelling Aspects with Graph Transformation 215\nThere are mainly two different lines to deﬁne a VL: the declarative way and the\nconstructive way. UML is deﬁned by the Meta Object Facilities (MOF) approach [19]\nwhich uses classes and associations to deﬁne symbols and relations of a VL. Within this\nmeta modelling approach, multiplicities and OCL constraints [23] are additionally used\nto formulate desired language properties. While constraint-based formalisms provide a\ndeclarative approach to VL deﬁnition, grammars are more constructive, i.e. closer to\nthe implementation. In [18] for example, textual as well as graph grammar approaches\nare considered for VL deﬁnition. Due to its appealing visual form, graph grammars\ncan directly be used as high-level visual s peciﬁcation mechanism for VLs [4]. Deﬁn-\ning the abstract syntax of visual forms as graphs, a graph grammar deﬁnes directly\nthe language grammar. The induced graph language determines the corresponding VL.\nVisual language parsers can be immediately deduced from such a graph grammar. Fur-\nthermore, abstract syntax graphs are also the starting point for model simulation and\ntransformation, i.e., model manipulation [5, 10, 22, 13]. Also here, it is very natural to\nuse graph transformation to come up with a high-level and constructive speciﬁcation.\nIn this paper, we consider the integration of meta modelling with graph transforma-\ntion. As common basis we take into account the types of visual symbols and relations\nwithin a VL, i.e. the visual alphabet. While constraints describe additional requirements\non this alphabet, transformation rules formulate a constructive procedure. In the MOF\napproach, classes of symbols can be inherited, meaning that their attribute lists and\ntheir associations are also present at all their descendants. Considering graph transfor-\nmation on the other hand, an additional type graph [8] is used to ensure a certain type\nsafety on nodes and edges. Supporting node t ype inheritance in addition, leads to a\nmore dense form of a graph transformation system, since similar transformation rules\ncan be abstracted into one. We believe this work can be very valuable for the Model\nDriven Arquitecture [19] (MDA), where model transformation plays a central role. In\nSection 2, we present algebraic graph transformation with node type inheritance facil-\nities and show how this kind of graph transformation can be ﬂattened to simply typed\ngraph transformation.\nThe MOF and the graph transformation approach can be integrated by identifying\nsymbol classes with node types and associations with edge types. In this way, declara-\ntive as well as constructive elements may be used for language deﬁnition, but it is still\nopen how single parts of a VL speciﬁcation a re deﬁned. In Section 3, we discuss two\npossible approaches, the AToM3 and the GEN GED approach, which are quite different\nto each other.\nAll new concepts are illustrated at a running example which is a variant of UML\nStatecharts. We focus on the abstract syntax deﬁnition of the language as well as the\nsimulation of concrete state models. Last but not least, we compare our approaches to\nfurther ones in the literature.\n2 Typed Graph Transformation with Node Type Inheritance\nIn this section we present our new concepts of typed graph transformation with node\ntype inheritance. Due to the space limitations, we omitted all proofs and details. The\ninterested reader is asked to consult [2].\n216 Roswitha Bardohl et al.\n2.1 Type and Instance Graphs\nThe basic idea for specifying node type hierarchies is to introduce a special kind of\n(directed) edges, hierarchy edges, into type graphs. The source node of a hierarchy edge\nis said to be a sub-type of the target node, which is called the former one’s super-type.\nNodes are marked either as concrete or abstract. In host graphs only nodes of concrete\ntypes shall occur, while graphs in rules may contain nodes of both types.\nDeﬁnition 1. (Type Graph with Inheritance) A type graph with inheritance is a triple\n(TG ,I,A ) consisting of a type graph TG =( N,E,s,t ) ( w i t has e tN of nodes, a\nset E of edges, a source and a target function s, t : E → N), an inheritance graph I\nsharing the same set of nodes N, and a set A ⊆ N, called abstract nodes.\nFor each node n in I the inheritance clan is deﬁned by clanI (n)= {n′ ∈ N |\n∃ path n′ ∗\n−→n in I} where path of length 0 is included, i.e. n ∈ clanI (n).\nThe sub-graph spanned by the hierarchy edges must be acyclic.\nTo beneﬁt from the well-founded theory of g raph transformation [8], type graphs\nwith inheritance can be ﬂattened to ordinary ones.\nDeﬁnition 2. (Closure of Type Graph with Inheritance) Given (TG ,I,A ) with TG =\n(N,E,s,t ),t h e abstract closure of (TG ,I,A ) is the graph\n TG =( N,\n E,\n s,\n t) with\n–\n E = {(n1,e ,n2) | n1 ∈ clanI (s(e)),n 2 ∈ clanI (t(e)),e ∈ E},\n–\n s((n1,e ,n2)) = n1,\n–\n t((n1,e ,n2)) = n2, and\n– projE ((n1,e ,n2)) = e for e ∈ E.\nThe graph ˆTG =\n TG|N −A is called concrete closure of (TG ,I,A ).\nGiven a graph G =( N,E,s,t ) and a set X ⊆ N, we denote by G|X the sub-graph\n(X,E X = {e ∈ E | s(e),t (e) ∈ X},s |EX ,t |EX ).\nThe discrimination between the abstract and the concrete closure of a type graph is\nnecessary, since there are instance graphs with respect to either one. The left-hand side\n(LHS) and right-hand side (RHS) of abstract rules are typed over the abstract closure,\nwhile ordinary host graphs and concrete rules (see section 2.2 for rules) are typed over\nthe the concrete closure. Due to the existence of the canonical inclusionincTG : ˆTG↪ →\nTG all graphs typed over ˆTG are also typed over\n TG.\nDeﬁnition 3. (Instance Graph of Type Graph with Inheritance) An abstract instance\ngraph (G, type) of (TG ,I,A ) is an instance graph of\n TG,i . e .(G, type: G →\n TG).\nAnalogously, a concrete instance graph of (TG ,I,A ) is typed over ˆTG.\nThe choice of triples for the edges of a type graph’s closure allows expressing a\ntyping property with respect to the type graph with inheritance. The instance graph can\nbe typed over the type graph with inheritance (for convenience) by a pair of functions,\none assigning a node type to each node and the other one assigni ng an edge type to\neach edge. Both are deﬁned canonically. A gr aph morphism is not obtained this way,\nbut some mapping that will be introduced as clan morphism, uniquely characterizing\nthe type morphism into the ﬂattened type graph.\nIntegrating Meta-modelling Aspects with Graph Transformation 217\nDeﬁnition 4. (Clan Morphism) Given a type graph with inheritance (TG ,I,A ),\ntype′: G → TG is a clan-morphism, if for all e ∈ GE holds\n– type′\nN ◦ sG(e) ∈ clanI (sTG ◦ type′\nE (e)) and\n– type′\nN ◦ tG(e) ∈ clanI (tTG ◦ type′\nE (e)).\ntype′is called concrete,i f type′\nN (n) /∈ A for all n ∈ GN .\nThe notion of atype reﬁnement is used in order to formalize the relationship between\nabstract and concrete rules as they are proposed in Section 2.2. It deﬁnes an order over\npossible typing morphisms for a given instance graph. A typing morphism is said to\nbe ﬁner than another one, if it assigns more concrete node types to the nodes of the\ninstance graph.\nDeﬁnition 5. (Type Reﬁnement)\n(G, type′: G → TG) is a type reﬁnement of (G, type: G → TG),i f\n– type′\nN (n) ∈ clan(typeN (n)) for all n ∈ GN and\n– type′\nE = typeE .\ntype′is respectively called ﬁner than type, denoted type′ ≤ type.\nApplying graph transformation with node t ype inheritance to visual language def-\ninition, usually needs attributed nodes. Thus, we have to clarify how the concept of\nnode type inheritance can be extended to node attributes. Assuming node type A has\nattributes, a descendant node type B inher its not only all adjacent edge types but also\nits attribute list. Of course, it should be possible to enlargen the inherited list by new\nattributes.\nIf we use attributes only as labels, i.e. they are not changed during a transformation,\nthis kind of typed attributed graphs can be deﬁned by ordinary typed graphs. (Poten-\ntially inﬁnite) sets of data values are considered as nodes. They are called data nodes\nin contrast to object nodes denoting all othe r nodes of an attributed graph. Data nodes\nand object nodes are linked by attributes, i.e. edges with an object node as source and\na data node as target. We assume that there are no edges starting at some data node. If\nthis property is satisﬁed within the type graph, it also holds for the instance graphs due\nto the typing morphisms.\nSummarising, graphs and graph transformation with node attributes which are not\nchanged are already captured by our formalisation. If we need a more general attribution\nconcept where computations can take place on attributes, future work is needed to extent\nthe formal approach.\nExample: Type Graph for a Statechart Variant. Fig. 1 shows a type graph with\ninheritance for a slightly modiﬁed sub-set of the Statecharts meta model proposed in\nthe UML speciﬁcation [19]. For space limitations, the following simpliﬁcations have\nbeen performed. Only PseudoStates of theinitial kind (attributeind) are considered, i.e.,\nwe eliminated classes SynchState, StubState and concurrent states and concentrate on\nCallEvent and SignalEvent classes. Events are associated to the transitions they trigger\n(and not to states). For simulation, objects need to receive events, so we modelled an\nevent queue (by relationshipsreceives and next); the last event is a special one depicting\nits end. Additionally, we added a relationship current to depict the state a particular\nobject is in. Note how the triple(TG ,I,A ) has been expressed in a single graph, where\nthe nodes of TG and I are the same, regular edges represent edges in TG, hollow\narrow-head edges represent edges in I and the elements of A are represented in italics.\n218 Roswitha Bardohl et al.\nsubvertex\nState\ntop\nbehaviour\nname: Name\ntarget\nsource\nStateVertex\nModelElement\nTransition\nSignalEvent CallEventSimple\nStateState\nComposite\nPseudoState\nind: PseudostateKind\nStateMachine\nreceives\ncurrent\nnext\nEvent\nInstance\nObject\ntrigger\nFinal\nState\nFig. 1. Type graph with inheritance for a part of UML Statecharts.\n2.2 Rules and Derivations\nTransformations of graphs are described by graph rules. We follow the so-called Dou-\nble Pushout approach to graph transformation [8]. It is desired to allow abstract node\ninstances in rules, such that abstract rules actually represent a set of structurally similar\nrules, we call concrete rules. To get all concrete rules for an abstract rule, any combi-\nnation of node replacements in the rule’s LHS (being of concrete or abstract type) by\ninstances of respective concrete sub-types (reﬂexive and transitive, i.e. the type’s clan)\nmust be considered. The rule morphism’s image of an LHS node must always be re-\nplaced by an instance of the same type. The other nodes in the RHS remain the same\nand therefore must be instances of concrete types. Concrete rules are structurally equal\nto the abstract rule, their typing morphisms are ﬁner (cf. Def. 5) than the ones of the\nabstract rule and are concrete clan morphisms.\nDeﬁnition 6. (Abstract and Concrete Rules)\nAn abstract rule typed over a type graph TG with inheritance is given by r =( L\nl\n←−\nK\nr\n−→R, type, NAC ),w h e r el and r are graph morphisms, type is a triple of typing\nclan morphisms type =( typeL : L → TG, type K : K → TG, type R : R → TG),\nand NAC is a set of triples nac =( N,n,type N ) with N being a graph, n: L → N\nan injective graph morphism, and typeN : N → TG a typing clan morphism, such that\nthe following conditions hold:\n– typeL ◦ l = typeK = typeR ◦ r\n– typeR,N (R′\nN ) ∩ A = ∅,w h e r eR′\nN := RN − rN (KN )\n– typeN ◦ n ≤ typeL for all (N,n,type N ) ∈ NAC\nA concrete rule rt with respect to an abstract rule r is given by rt =( L\nl\n←− K\nr\n−→\nR,t,NAC ),w h e r et is a triple of concrete typing clan morphisms t =( tL : L →\nTG,t K : K → TG,t R : R → TG) such that the following conditions hold (cf. Fig. 2):\n– tL ◦ l = tK = tR ◦ r\n– tL ≤ typeL, tK ≤ typeK , tR ≤ typeR, and\n– tR,N (x)= typeR,N (x)∀x ∈ R′\nN .\nThe set of all concrete rules rt with respect to an abstract rule r is denoted by ˆr.\nIntegrating Meta-modelling Aspects with Graph Transformation 219\nN\ntypeN\n→→\ntNi\n→→\nL\nn←←\ntypeL\n↘↘↗↗↗↗↗↗↗↗↗↗↗↗↗↗↗↗\ntL\n↘↘↗↗↗↗↗↗↗↗↗↗↗↗↗↗↗↗ K\ntypeK\n↓↓\ntK\n↓↓\nl←←\n r →→\nR\ntypeR\n↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙tR\n↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙↙\nTG\nFig. 2. Abstract and concrete rules.\nThe main idea for the application of an abstract rule is to apply one of its concrete\nrules. Both the host graph and the concrete rule are typed by concrete clan morphisms\nsuch that we can deﬁne the application of concrete rules. Later we will also deﬁne the\napplication of an abstract rule and the equivalence of both (cf. Theorem 1).\nDeﬁnition 7. (Matching and Application of Concrete Rules)\nLet rt =( L\nl\n←− K\nr\n−→ R,t,NAC ) be a concrete rule, (G, typeG) a typed graph,\nwith typeG : G → TG being a concrete clan morphism, and m: L → G a graph\nmorphism. m is a match with respect to rt and (G, typeG),i f\n– m is a match with respect to the untyped rule L\nl\n←−K\nr\n−→R and the graph G,\n– typeG ◦ m = tL, and\n– m satisﬁes the negative application conditionsNAC ,i . e .f o re a c h(N,n,type N ) ∈\nNAC it holds, that there does not exist a morphismo: N → G, such thato◦n = m\nand typeG ◦ o ≤ typeN .\nGiven a match m, the concrete rule can be applied to the typed graph (G, typeG) via\nm. A direct derivation step is denoted by (G, typeG)\nrt ,m\n=⇒ (H,type H ) and can be\nconstructed similar to the classical theory of graph transformations [8].\nIn [2] we have shown that it is equivalent to apply concrete rules where typing\nis given by concrete clan morphisms or to apply classical rules with typing morphisms\nover a given type graph which is the concrete closure over a type graph with inheritance.\nNevertheless, it makes sense to examine whether it is possible to ﬁnd a more direct\nway to apply an abstract rule, because it is im practical for a tool implementing graph\ntransformation with node type inheritance to hold all concrete rules of an abstract rule in\nmemory or for each of them to ﬁnd a match morphism into a host graph. Since abstract\nand concrete rules differ only in typing, but have the same structure, a match morphism\nfrom the LHS of the concrete rule into a given instance graph is also a match morphism\nfor the abstract rule, for the latter one not being compatible with typing, though. Using\nthe notion of type reﬁnement, however, we can express a compatibility property.\nDeﬁnition 8. (Matching and Application of Abstract Rules)\nLet r =( L\nl\n←−K\nr\n−→R,type,NAC ) be an abstract rule typed overTG, (G, typeG)\na typed graph with typeG : G → TG being a concrete clan morphism, and m: L → G\na graph morphism. Then m is a match with respect to r and (G, typeG),i f\n220 Roswitha Bardohl et al.\n– m is a match with respect to the untyped rule L\nl\n←−K\nr\n−→R and the graph G.\n– typeG ◦ m ≤ typeL.\n– tK,N (x1)= tK,N (x2) for tK = typeG ◦ m ◦ l and all x1,x2 ∈ KN with\nrN (x1)= rN (x2).\n– m satisﬁes NAC ,i . e .f o re a c hnac =( N,n,type N ) ∈ NAC it holds that it does\nnot exists a morphism o: N → G such that o ◦ n = m and typeG ◦ o ≤ typeN .\nG i v e nam a t c hm, the abstract rule can be applied to (G, typeG) yielding an abstract\ndirect derivation (G, typeG)\nr,m\n=⇒ (H,type H ) with concrete type graph (H,type H ) as\nfollows:\n1. Construct the untyped direct derivation G\nr,m\n=⇒ H in the sense of [9].\n2. Construct typeD and typeH as follows\n– typeD = typeG ◦ l′\n– typeH (x)= if\n x = r′(x′) then\n typeD(x′) else\n typeR(x′′),\nwhere m′(x′′)= x and x ∈ HE or x ∈ HN\nTheorem 1. (Equivalence of Abstract and Concrete Direct Derivations)\nGiven an abstract rule r =( L ←− K −→ R,type,NAC ) over a type graph TG\nwith inheritance, a concrete typed graph (G, typeG) and a structural match morphism\nm: L → G (i.e. a match with respect to the untyped rule L ←− K −→ R). Then\nthe following statements are equivalent, where (H,type H ) is the same concrete typed\ngraph in both cases:\n1. m: L → G is a match with respect to the abstract ruler yielding an abstract direct\nderivation: (G, typeG)\nr,m\n=⇒ (H,type H ).\n2. m: L → G is a match with respect to the concrete rulert = L ←−K −→R with\nrt ∈ ˆr and tL = typeG ◦ m yielding a concrete direct derivation: (G, typeG)\nrt,m\n=⇒\n(H,type H ).\nTheorem 1 allows us to use the dense form of abstract rules for model manipulation\ninstead of generating and holding all concrete rules, i.e., abstract derivations are much\nmore efﬁcient than concrete derivations. In this sense, Theorem 1 allows us to use on\nthe one hand an efﬁcient procedure and on the other hand we are sure that the result\nis the same as in the classical theory using concrete rules. Moreover, as a consequence\nof Theorem 1, graph languages built over abstract rules and mechanisms are equivalent\nto graph languages that are built over a corresponding set of concrete rules. In general,\nrules together with a start graph deﬁne a graph grammar building up a graph language.\nIn the case of attribute labels, it might be convenient to add variable nodes of data\ntypes to rule graphs which are matched by concrete labels when applying such a rule.\nPlease note that in the following ﬁgures for our example, the same variable might occur\nseveral times in a rule. It corresponds to one variable node which has to be matched by\none data node. (Compare e.g. rule 2 in Fig. 3.)\nExample: Generation of Statecharts. The graph grammar for generating valid State-\nchart instances according to the type graph with inheritance presented in Fig. 1 is shown\nin Fig. 3, where especially the typeStateVertex(SV) is abstract. Please note that we omit\nthe gluing graph K for illustrational reasons. The st art graph contai ns a node of type\nIntegrating Meta-modelling Aspects with Graph Transformation 221\nStateMachine (SM) connected to an object (OB). The UML speciﬁcation establishes\nthat a StateMachine has a unique top state of type State, but the UML well-formedness\nrules establish that its type should be further reﬁned into a CompositeState (CS). For\nthis purpose, rule 1 checks whether the StateMachine SM has already a top state and\nif this is not the case, it creates a top state together with a CompositeState (CS) and a\nPseudoState (PS) of the initial kind.\nNAC\nOB\nSM\nCS CS CS CS\nSM CS SM SM name=CSname\nCS\nname=SSname\nSS\nname=FSname\nFS\nCS name=CSname\nCS PS\nname=’’\nind=initial\nsub sub1\nRHS\nCS\n1\nLHS\nRule 4: Create Composite State (CSname: Name)\nname=Ename\nname=Ename\nSEV\nCEV\nSV\nSV\nSV\nSV\nSV\n2\nSV\n1LHS\nFS\n1NACPS\nind=initial\n2\nSVTRPS\nind=initial\nts\n1NAC\nCSSM\n1\ntop\nNAC\nRule 5: Connect States SignalEvent (TRname, Ename: Name)\ns\ns1\n1\nTR\nTR t\nt\n2\n2\nname=TRname\nname=TRname\ntrigger\ntrigger\nRHS\nRHSNAC\nSV\n2\nSV\n1LHS\nFS\n1NACPS\nind=initial\n2\nSVTRPS\nind=initial\nts\n1NAC\nCSSM\n1\ntop\nNAC\nb\nStart Graph\nLHS\n1\nRHS\n1 sub\nRule 2: Create Simple State (SSname: Name)\n1\nLHS RHS\n1 sub\nsub\nRule 3: Create Final State (FSname: Name)\nLHSNAC\ntop1\nRule 1: Create Initial State (CSname: Name)\n1\nRHS\ntop1\n3\nPS\nname=’’\nind=initial\nRule 6: Connect States CallEvent (TRname, Ename: Name)\nFig. 3. Graph grammar for generating valid Statecharts.\nRules 2, 3 and 4 create new SimpleState (SS), FinalState (FS) and CompositeState\n(CS) objects inside a givenCompositeState. In contrast to rule 1 (where the multiplicity\nof relationship top in the side of the State class is “1..1”) the multiplicity of the sub-\nvertex relationship (from CompositeState to StateVertex in the side of the latter class)\nis “0..*”. This implies that there is no need for a negative application condition check-\ning the multiplicity. Additionally, each StateVertex should be connected to at most one\nCompositeState through relationship subvertex. This is achieved by the graph grammar\nas each newly created state is attached to a single CompositeState, and this relationship\ncannot be modiﬁed later.\nFinally, rules 5 and 6 allow connecting two objects of type StateVertex (SV). Rule\n5 describes the insertion of a transition with SignalEvent (SEV), while rule 6 handles\nthe case of CallEvent (CEV). They are abstract rules as StateVertexis an abstract class.\nAdditionally, the UML speciﬁcation establishes (by means of constraints expressed in\nOCL) that a FinalState should not have any outgoing connection, that an PseudoState\nof the initial kind should not have any incoming connection and at most one outgoing\n222 Roswitha Bardohl et al.\nconnection, and that the top state should not have any outgoing connection. We graph-\nically modelled these constraints by means of negative application conditions (NACs).\nThe advantages of using abstract rules here are clear, as otherwise we would have to\nmodel rules for the valid combinations of the states we want to connect. Additionally,\nthe typing in NACs is more concrete than the corresponding typing in the LHS.\nFig. 4 shows a Statechart obtained through the derivation of the previous graph\ngrammar. The concrete syntax of the ﬁnal Statechart is shown in the lower right corner.\nIn the third step in the derivation, abstract rule 5 is applied. Abstract types of nodes 1\nand 2 in the rule instantiate to PseudoState PS and SimpleState (node called ‘SS1’in\nthe graph), respectively. In the example, abstract rules 5 and 6 have been applied with\nother instantiations to connect nodes ‘SS1’(type SS)a n d‘CS2’(type CS), ‘CS2’(type\nCS)a n d‘FS1’(type FS), ‘SS2’(type SS)a n d’SS1’(type SS), as well as PseudoState\nPS and ‘SS2’(type SS). Without the possibility to model abstract rules, we would have\nhad to create concrete rules for these combinations.\nsub\nOB SM CS\n’CS1’\nPS\n’’\ninitial\nOB SM\nStart Graph\nb\nRule 1(’CS1’)\nOB SM CS\n’CS1’ SS\n’SS1’\nPS\n’’\ninitial\nSS1\nCS1\nTR3: E2\nFS1\nConcrete Syntax\nTR2: E1\nTR5: E1\nSS2\nCS2\nTR4:\nTR1:\nSS\n’SS1’\nPS\n’’\ninitial\nSEV\n’ ’\nTR\n’TR1’\nCS\n’CS2’\nPS\n’’\ninitial\nOB SM CS\n’CS1’\nbt o p\nOB SM CS\n’CS1’ SS\n’SS1’\nPS\n’’\ninitial\nTR\n’TR1’\ns\nt\nsub trigger\nsub\nsub\nsub\ns\nt\nbt o p\nsub\nsub trigger\nSEV\n’ ’\nRule 4 (’CS2’)\nRules 2, 3, 6(twice)\nand 5 (twice)\nOB SM CS\n’CS1’\nbt o p\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nb top sub\n(’SS1’)Rule 2\nRule 5\n(’TR1’, ’’)\nbt o p\nsub\nsub\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nFig. 4. A derivation of the graph grammar for generating Statecharts.\nExample: Simulation of Statecharts. Fig. 5 shows a rule set for simulating our sub-\nset of Statecharts. The ﬁrst rule adds the current relationship (c)t oa no b j e c t( O B )i f\nit does not already have one. The initial state is the only InitialState node which is a\nsubvertex (sub) of the top state. Rule 2 models a state change due to a transition from\nthe current state. This is an abstract rule, as StateVertexnodes are abstract. This feature\nallows us to condense in a single abstract rule the combinations of all concrete sub-\ntypes of StateVertex nodes. Rule 3 is similar to the previous one, but models a state\nchange into a composite state. In this case, the current state should be its initial state\nIntegrating Meta-modelling Aspects with Graph Transformation 223\n(that is, the PseudoState node is subvertex of the CompositeState). Rule 4 moves from\nthe initial state to another one without c onsidering events (one does not have to wait\nfor an event to move from this PseudoState.) Finally, rule 5 models the fact that we\ncan change the state due to transitions departing from any of the super-states of the\ncurrent state. Thus, this rule allows going up in the subvertex hierarchy starting from\nthe current state. We cannot apply this rule, if the current state is already a subvertex\nof the top state, or if the current state is indeed a PseudoState of the initial kind. The\nlatter restriction is modelled by assigning type State (ST)t ot h ecurrent state in rule 5\n(PseudoStates are not sub-classes ofState but of StateVertex). The reason for forbidding\nthis is that a transition in a PseudoState is still not ﬁnished, we have to end up in a node\nsub-class of State.\nRule 4: Change from Initial State\nOB\nSV\n1\nc\nOB SM\nCS\nPS\nind=initial\ntop\nsub\n3\n5\n6\n7\n4\nb\n2\n1\nLHS\nOB SM\nCS\nPS\nind=initial\nEVOB\nSV\n2\nSVTR\nname=x\nEV\nRHS 8\nrec\n1\ns\n3\n6\nt\n5\n7\ntrig8\nc\nOB\nSV\n2\nname=x\nEV\nSVTR\nname=x\nEV\n5\n6\nt\n4\n7\ntrig8\nEV\n1\nc\ns\n3\nrec\nnext\n8\nCS\nRule 2: Change State\nLHSNAC\n6\nname=x\nEVOB\nTRSV CS\nname=x\nEV\ntrig9\n10\nEV\nPS\nind=initial\nrec\n1\nst\n42 6\n53\nsub\n7\nc\nnext\n9LHS\n8\nTRSV CS\nname=x\nEV\ntrig9\n10\nPS\nind=initial\nEVOB\nst\n42 6\n53\nsub\n7\n8\nc\n9\nrec1\nCS\nSM\n4\ntop\nOB\nSTCS\nOB\nCS ST\nNAC\nRule 5: Hierarchy up\n1\nsub\n42\nc\n3\nLHS RHS\nsub\n3\n24\n1\nc\nPS\nind=initial\nTR SV\nOB\n24\n3\ns t\n5\n6\nc1RHS\nTR SVPS\nind=initial\nOB\n5\nt\n6\ns\n3\n2\n1\nc\n4\nLHS\nNAC\nRule 1: Create current\nRHS\nc\ntop\nsub\n3\n5\n6\n7\n4\nb\n2\n1\nRule 3: Change to Initial State\nRHS\nFig. 5. Graph grammar for simulating Statecharts.\nFig. 6 shows an execution of the previous grammar to the Statechart we built in\nFig. 4. In the ﬁrst step, we apply rule 1, setting the current state pointer to the Pseu-\ndoState (initial kind) of the top state. Then, abstract rule 4 moves the current state to\nnode ‘SS1’. Node 6 in the rule (StateVertextype) is matched to node ‘SS1’in the graph,\ntyped over SimpleState. Next, abstract rule 3 is applied and the pointer is moved to the\ninitial state of composite state ‘CS2’. Node 2 (of type StateVertex) in the rule matches\nnode ‘SS1’of type SimpleState in the graph; and the Event is of type CallEvent. Then,\nabstract rule 4 can be applied, which moves the pointer to node ‘SS2’. The type instan-\ntiation is from StateVertex in the rule to SimpleState in the graph. Now, abstract rule 5\nis applied, moving the current pointer up in the hierarchy to node ‘CS2’. The type of\n224 Roswitha Bardohl et al.\nnode 2 (CompositeState) in the rule is instantiated to SimpleState of node ‘SS2’in the\ngraph. For the following step, abstract rule 2 can be applied, and the pointer is set to\nnode ‘FS1’. The type instantiation is fromStateVertexand Event in the rules toCompos-\niteState, FinalState and CallEvent in the graph. Here, no rule can be applied anymore,\nand the simulation ﬁnishes. Thus, this graph grammar models all possible simulations\nof the initial model. Some derivations may lead to dead ends. This may happen for ex-\nample, going up in the hierarchy with rule 5, and ﬁnally discovering that none of the\nsuper-states have any outgoing transition.\nc\nOB SM CS\n’CS1’\nb top\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nCEV\n’none’\nCEV\n’E1’\nCEV\n’E2’\nrec\nnext\nnext\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nOB SM CS\n’CS1’\nbt o p\nCEV\n’none’\nCEV\n’E1’\nCEV\n’E2’\nrec\nnext\nnext\nsub\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nc\nRule 3\nOB SM CS\n’CS1’\nb top\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nPS\n’’\ninitial\nCEV\n’E2’\nCEV\n’none’\nrec\nnext\nOB SM CS\n’CS1’\nbt o p\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nCEV\n’E2’\nCEV\n’none’\nrec\nnext\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nc\nsub\nOB SM CS\n’CS1’\nb top\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nCEV\n’E2’\nCEV\n’none’\nrec\nnext\nsub\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nc\nOB SM CS\n’CS1’\nbt o p\nCS\n’CS2’\nPS\n’’\ninitial\nSS\n’SS1’\nTR\n’TR2’\nFS\n’FS1’\nSEV\n’ ’\nPS\n’’\ninitial\nSS\n’SS2’\nCEV\n’E1’\nCEV\n’E2’\nSEV\n’E1’\nSEV\n’ ’\nTR\n’TR5’\nTR\n’TR4’\nTR\n’TR1’\nCEV\n’none’\nsub\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nc\nRule 1 Rule 4\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nc\nsub\nRule 4\nRule 5\nRule 2 sub\nsub\nsub\nsub sub\ns\nt\ns\nt\nt\ns\ns\nt\nTR\n’TR3’t\ns\nsub\nrec\ntrigger\ntrigger\ntrigger\ntrigger\ntrigger\nFig. 6. A derivation of the simulation graph grammar starting from the graph generated in Fig. 4.\n3 Integration of Meta-modelling with Graph Transformation\nThe extension of algebraic graph transfor mation with node type inheritance facilitates\nits integration with meta modelling. If we identify model element classes with node\ntypes and associations with edge types, a unique basis for the description of symbols\nand their relations is laid. Model elements can share common attributes and relations\nto other model elements which is expressed by a generalisation relationship. Similarly,\nan inheritance relation is supported for node types (see Sec.2). Summarising, the in-\nformation expressed by class diagrams in the meta modelling approach is formulated\nby type graphs (with node type inheritance) for graph transformation. On top of this\nIntegrating Meta-modelling Aspects with Graph Transformation 225\ncommon basis, constraints are used to describe language properties in the meta mod-\nelling approach. On the other hand, typed graph grammars describe the modelling lan-\nguage as shown for the sample sub-language of Statecharts in Sec.2. In the following,\ntwo approaches for visual language (VL) de ﬁnition and model manipulation are pre-\nsented which distinguish in exactly this design decision. We ﬁrst shortly present these\napproaches and compare them afterwards.\nThe GENGED Approach. In GEN GED [1], a VL is deﬁned (or generated) by an al-\nphabet and a grammar. An alphabet establishes a type system for model elements (called\nsymbols) and their relations (calledlinks), i.e. it deﬁnes the vocabulary of a VL. The ab-\nstract syntax of symbols is represented by graph nodes, whereas graph edges represent\nthe abstract syntax of links. The layout of symbols is given by graphical objects deﬁn-\ning node attributes, and for each edge (abstract link) at least one graphical constraint is\ndeﬁned. An alphabet instance is given by an abstract syntax graph which is extended\nby graphical objects for the layout; the corresponding graphical constraints are solved\naccordingly. Usually, an abstract syntax gr aph is built up by VL rules (occurring in a\nVL grammar) which are modeled as graph rules. The grammar deﬁnition as well as the\nmanipulation of models like Statecharts [3] is done purely by graph transformation as\nGEN GED uses the graph transformation engine A GG [11] for this purpose.\nUp to now, neither meta modelling nor inheritance concepts are realized. For deﬁn-\ning all the features of Statecharts as we did by the type graph in Fig. 1, this type graph\nmust be ﬂattened in order to establish an alphabet. With the ﬂatting, some more links\nhave to be added. Moreover, the set of VL ru les would correspond to concrete rules,\ni.e. the grammar contains many similar rules. Using node type inheritance concepts as\nproposed in Sec. 2 would reduce the set of rules in a sense that the proposed abstract\nrules have to be deﬁned only. Such concise rule sets can be used to deﬁne concise ab-\nstract grammar rules for different purposes then, like syntax-directed editing, parsing,\nand simulation as it is supported by GEN GED.\nThe AToM3 Approach. AToM3 [10] is a multi-paradigm modelling tool, which in-\ncludes meta modelling, multi-formalism and modelling at different abstraction levels.\nIts main component is the kernel, responsible for loading, saving, creating and manip-\nulating models, as well as for generating c ode for the meta modelled formalisms. The\ngenerated code must be loaded on top of the kernel again to allow the user building\nmodels in the deﬁned formalism. The tool uses a pure meta modelling approach for\nVL deﬁnition, i.e. a VL is completely deﬁned by a meta model, which is a type graph\nwith inheritance with additional constraints. Some of them are assigned (pre- or post-\nconditions) to events (editing, connecting, etc.), the evaluation of which prohibits or\nenables the execution of the events and guarantees model correctness by construction.\nIn AToM3, models can be manipulated by means of Python or with graph gram-\nmars. Typical manipulations are simulation, optimization and formalism transforma-\ntion (which produces an instance model o f a different meta model). When deﬁning\ngraph grammar rules, one may choose either an “exact type matching” or a “sub-type\nmatching”. In the latter case, rules are consideredabstract and any node can be matched\nwith any of its sub-types. There is no distinction between abstract and concrete nodes\nand sub-typing relationships are found at runtime (by comparing nodes attributes and\nconnections). This is due to the fact that some of the formalisms for meta modelling\n226 Roswitha Bardohl et al.\ndo not provide for inheritance. This feature also allows applying transformation rules\nto instances of meta models that are not explicitly related through inheritance relation-\nships. In this way, the inheritance concept can be mapped to the semantics deﬁned in\nthis work, as AToM3 can be conﬁgured to work in the Double Pushout approach.\nComparison of Both Approaches. After having deﬁned the classes or types of model\nelements and their relations, AToM3 supports the meta modelling approach which yields\nin a free editor where the model is checked according to given language constraints at\nspeciﬁc events. Instead, G EN GED can generate two kinds of editors: Either editing is\ndone in a syntax-directed way where graph rules deﬁne the editor operations or free\nediting is supported where a parser has to ch eck, if the edited model is syntactically\ncorrect. While the deﬁnition of a language by corresponding langua ge constraints is\nusually easier, a parser is normally more efﬁcient than a constraint checker. Syntax-\ndirected editing assumes a language understa nding which knows well about the struc-\nture and dependencies of its elements. Pur e syntax-directed editors can be directly de-\nduced from a language grammar. Combining both kinds of editing, the corresponding\nspeciﬁcation can be purely rule-based or mix ed in the sense that ru les deﬁne complex\nediting operations while language constraints deﬁne syntactic correctness.\nBoth approaches use graph transformation for model manipulations such as simula-\ntion. Due to the availability ofnode type inheritance, graph transformation concepts can\nbuild up directly on meta modelling concepts as in AToM3.I nG EN GED, several kinds\nof graph transformation systems are used for different purposes as editing, parsing and\nsimulation. Node type inheritance can condense each of them.\n4 Related Work\nConsidering the node type inheritance concept for graph transformation, there are al-\nready tools like [21, 20] which support this concept in the same or nearly the same way.\nHowever, node type inheritance has been rarely considered in formal graph transfor-\nmation approaches. The graph transformation-based language PROGRES is formalised\nby programmed structure rewriting systems [21] where so-called schema consistent\nstructures are transformed. A schema corresponds to a type graph with node type inher-\nitance, while a schema consistent structure corresponds to a well-typed instance graph.\nThus, a formalisation of node type inheritance is available for PROGRES, but there\nis no theory building up on that. GME [16] e.g., is a meta modelling tool (for model\nintegrated computing) which has lately incorporated graph transformation techniques\nfor model manipulation, although its approach is not founded on the theory of graph\ntransformation and its formalization has not been shown.\nAt the “Symposium on Visual Languages and Formal Methods” in 2001 there was a\nso-called “statechart modeling contest” where declarative as well as constructive meth-\nods have been used to deﬁne Statecharts and their behaviour. No winner was selected,\nbut the speciﬁc strengths of the different methods have been discussed. There was not\nany approach integrating meta modelling with graph transformation, thus combining\ndeclarative with constructive methods. A number of graph transformation-based ap-\nproaches were presented where most of th e approaches could have been simpliﬁed us-\ning the hierarchy concept proposed in the p resent work. In addition, there is the work\nIntegrating Meta-modelling Aspects with Graph Transformation 227\nin [22] where Statecharts modelling is based on a meta model for extended hierarchical\nautomata and graph transformation rules for its simulation. A similar approach is taken\ninto account in [10] where a graph grammar is used to transform Statecharts to Petri\nnets which can be simulated, but there is no connection to formal graph transformation\napproaches.\nThe approach of [15] uses transformation units for generating and simulating stat-\necharts, and is a clear example where our approach could have simpliﬁed the graph\ngrammars. They encode the type hierarchy in graph grammar rules in such a way that\nthey deﬁne rules for replacing each super- type for each one of its sub-types. Nonethe-\nless, embedding conditions are needed for these rules and are not directly applicable in\nthe standard Double Pushout approach.\n5 Conclusions\nIn the literature, the main approaches to visual language deﬁnition are meta modelling\nand grammar-based approaches. We discussed how to integrate meta modelling with\ngraph grammar concepts in order to support an efﬁcient language deﬁnition and model\nmanipulation. We presented two concrete approaches which differ in the way how meta\nmodelling and graph transformation concepts are used and compared them.\nThe integration of meta modelling with gr aph transformation is based on a node\ntype inheritance concept for algebraic graph transformation. This concept allows the\ndeﬁnition of abstract rules, in which abstract nodes can appear. These can be matched\nwith nodes of any of its sub-types. The concept is extremely useful in practice as graph\ngrammars can be notably simpliﬁed. This has been demonstrated by showing a gen-\neration and a simulation grammar for a sub-set of UML Statecharts. The formalism\npresented is restricted to attributes being labels. It is up to future work to extend this\nwork to attributed graph transformation where computations on attributes can take place\nand also edges may be attributed.\nMoreover, analysis techniques available for attributed graph transformation such as\nconstraint checking [14, 17] and critical pair analysis [13], should be lifted to graph\ntransformation with node type inheritance. Having e.g. constraint checking available,\nlanguage requirements could be expressed by s yntactic consistency constraints in the\nmeta modelling approach ﬁrst. If parsing rules are developed thereafter, their correct-\nness with respect to requirements could be checked. In this way we ensure that the\nlanguage deﬁned by the parser is at least a sub-language of that deﬁned by constraints.\nCritical pair analysis can be useful to optimise the visual language parser (see [7]).\nReferences\n1. Bardohl, R., 2002 A Visual Environment for Visual Languages Science of Computer Pro-\ngramming 44, pages 181-203. The GEN GED home page: http://tfs.cs.tu-berlin.de/genged\n2. Bardohl,R., Ehrig, H., de Lara, J., Runge, O., Taentzer, G., Weinhold, I. 2003. Node Type\nInheritance Concept for Typed Graph TransformationTechnical Report 2003–19, TU Berlin.\n3. Bardohl, R., and Ermel, C. 2001. Visual Speciﬁcation and Parsing of a Statechart Variant\nusing GEN GED. In Statechart Modeling Contest, part of VLFM 2001.\n228 Roswitha Bardohl et al.\n4. Bardohl, R., Taentzer, G., Minas, M., Sch¨urr, A. 1999. Application of Graph Transformation\nto Visual Languages. In Handbook of Graph Grammars and Computing by Graph Transfor-\nmation, V olume 2, H.Ehrig, G.Engels, H.-J.Kreowski, and G.Rozenberg (eds.), pages 105–\n181. World Scientiﬁc.\n5. Baresi, L., Pezze, M. 2002. A Toolbox for Automating Visual Software Engineering.I nF A S E\n2002, R. Kutsche and H. Weber (eds.), pages 189 – 202. Springer LNCS 2306.\n6. Bottoni, P., Koch, M., Parisi-Presicce, F., Taentzer, G. 2001. A Visualization of OCL using\nCollaborations. In UML 2001, M.Gogolla and C.Kobryn (eds.), Springer LNCS 2185.\n7. Bottoni, P., Sch¨urr, A., Taentzer, G. 2000. Efﬁcient Parsing of Visual Languages based on\nCritical Pair Analysis and Contextual Layered Graph Transformation. Technical Report no.\nsi-2000-06, University of Rome.\n8. Corradini, A., Montanari, H., Rossi, F. 1996. Graph Processes. Special Issue of Fundamenta\nInformaticae, V ol 26(3-4), pages 241–266.\n9. Corradini, A., Montanari, U., Rossi, F., Ehrig, H., Heckel, R., L¨ owe, M. 1997 Algebraic\nApproaches to Graph Transformation I: Basic Concepts and Double Pushout Approach .\nIn Handbook of Graph Grammars and Computing by Graph Transformation, V olume 1,\nG.Rozenberg (ed.), pages 163–245. World Scientiﬁc.\n10. de Lara, J., Vangheluwe, H., Alfonseca, M. 2003. Meta-Modelling and Graph Grammars\nfor Multi-Paradigm Modelling in AToM 3. To appear in Software and Systems Modelling.\nSpringer. See also the AToM3 home page at: http://atom3.cs.mcgill.ca\n11. Ermel, C., Rudolf, M., Taentzer, G. 1999 The AGG Approach: Language and Tool Environ-\nment. In Handbook of Graph Grammars and Computing by Graph Transformation, V olume\n2, H.Ehrig, G.Engels, H.-J.Kreowski, and G.Rozenberg (eds.), pages 551 – 603. World Sci-\nentiﬁc. See also the AGG Home Page: http://tfs.cs.tu-berlin.de/agg\n12. Harel, D. 1987. Statecharts: A Visual Formalism for Complex Systems. Science of Computer\nProgramming, 8:231-274.\n13. Heckel, R., K¨ uster, J., Taentzer, G. 2002. Towards Automatic Translation of UML Models\ninto Semantic Domains. In Proc. AGT 2002, H.-J. Kreowski (ed.), pages 11 – 22.\n14. Heckel, R., Wagner, A., 1995. Ensuring Consistency of Conditional Graph Grammars – A\nconstructive Approach. In ENTCS no. 2, Elsevier.\n15. Kuske, S., 2001. A Formal Semantics of UML State Machines Based on Structured Graph\nTransformation. In UML 2001, M.Gogolla and C.Kobryn (eds.), Springer LNCS 2185.\n16. L´edczi, A., Bakay, A., Mar´oi, M., V¨ogyesi, P., Nordstrom, G., Sprinkle, J., Karsai, G. 2001.\nComposing Domain-Speciﬁc Design Environments. IEEE Computer, pages 44-51. See also\nt h eG M Eh o m ep a g e :http://www.isis.vanderbilt.edu/Projects/gme/default.html\n17. Matz, M., 2002. Konzeption und Implementierung eines Konsistenznachweisverfahrens f¨ur\nattributierte Graphtransformation. Master’s thesis, TU Berlin, Fak. IV .\n18. Marriot, K., Meyer, B. 1998. Visual Language Theory. Springer.\n19. MDA, MOF and UML speciﬁcations at the OMG web page: http://www.omg.org/\n20. Nickel, U., Niere, J., Z¨undorf, A. 2000. The Fujaba Environment. In ICSE 2000, pages 742–\n745. See also the Fujaba Home Page: http://www.fujaba.de/\n21. Sch¨urr, A. 1996. Programmed Graph Replacement Systems. In Handbook of Graph Gram-\nmars and Computing by Graph Transformation, V olume 1, G.Rozenberg (ed.), pages 479–\n546. World Scientiﬁc. See also the PROGRES home page: http://www-i3.informatik.\nrwth-aachen.de/research/projects/progres/\n22. Varro, D. 2002. A Formal Semantics of UML Statecharts by Model Transition Systems .I n\nICGT 2002, A. Corradini, H. Ehrig, H.-J. Kreowski, and G. Rozenberg (eds.), pages 378–\n392, Springer LNCS 2505.\n23. Warmer, J. B., Kleppe, A. 1998. The Object Constraint Language: Precise Modeling with\nUML. Addison-Wesley Object Technology Services.",
  "topic": "Computer science",
  "concepts": [
    {
      "name": "Computer science",
      "score": 0.8634308576583862
    },
    {
      "name": "Graph rewriting",
      "score": 0.6796934008598328
    },
    {
      "name": "Programming language",
      "score": 0.6721848249435425
    },
    {
      "name": "Constructive",
      "score": 0.5566495656967163
    },
    {
      "name": "Rule-based machine translation",
      "score": 0.5185887813568115
    },
    {
      "name": "Graph",
      "score": 0.4668824076652527
    },
    {
      "name": "Grammar",
      "score": 0.4498275816440582
    },
    {
      "name": "Theoretical computer science",
      "score": 0.43857550621032715
    },
    {
      "name": "Parsing",
      "score": 0.4367332458496094
    },
    {
      "name": "Artificial intelligence",
      "score": 0.4194958209991455
    },
    {
      "name": "Formal grammar",
      "score": 0.41054925322532654
    },
    {
      "name": "Natural language processing",
      "score": 0.3770166039466858
    },
    {
      "name": "Process (computing)",
      "score": 0.09385502338409424
    },
    {
      "name": "Philosophy",
      "score": 0.0
    },
    {
      "name": "Linguistics",
      "score": 0.0
    }
  ]
}